[
  {
    "name": "Camera.java",
    "path": "src/com/ch/Camera.java",
    "content": {
      "structured": {
        "description": "A `Camera` class that manages view and projection matrices for rendering 3D scenes. The class has an abstract method `calculateProjectionMatrix()` that returns a matrix for projecting 3D points onto a 2D image, and another abstract method `adjustToViewport()` that resizes the matrix to fit within the image's dimensions. The `Camera` class also has instance methods for calculating view and projection matrices based on transformations such as rotation and translation. These matrices are used to render 3D objects from different viewpoints.",
        "image": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera.CameraStruct Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera.CameraStruct</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera3D_1_1CameraStruct3D.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node1&#45;&gt;Node2 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node1&#45;&gt;Node2</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n",
        "diagram": "digraph G {\n    label=\"com.ch.Camera\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        World\n    }\n    subgraph cluster_1 {\n        label=\"math\"\n        color=\"#33363A\"\n        Matrix4f\n    }\n    Transform\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Camera [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    CameraStruct\n    Camera -> World \n    CameraStruct -> Camera \n    Camera -> Matrix4f \n    Camera -> Transform \n}\n",
        "items": [
          {
            "id": "6ebeee18-3617-3e99-e843-a7754a25ee4b",
            "ancestors": [],
            "type": "function",
            "description": "is an abstract class that provides methods for calculating view and projection matrices, as well as transforming positions and rotations. It also has an abstract method for calculating the projection matrix and another for adjusting to a specified viewport size.",
            "name": "Camera",
            "code": "public abstract class Camera {\n\n\tprotected Matrix4f projection;\n\tprotected Matrix4f viewProjectionMat4;\n\tprotected CameraStruct values;\n\tprotected Transform transform;\n\n\tprotected Camera(Matrix4f projection) {\n\t\tthis.projection = projection;\n\t\ttransform = new Transform();\n\t}\n\n\tpublic Matrix4f getViewProjection() {\n\n\t\tif (viewProjectionMat4 == null || transform.hasChanged()) {\n\t\t\tcalculateViewMatrix();\n\t\t}\n\n\t\treturn viewProjectionMat4;\n\t}\n\n\tpublic Matrix4f calculateViewMatrix() {\n\n\t\tMatrix4f cameraRotation = transform.getTransformedRot().conjugate().toRotationMatrix();\n\t\tMatrix4f cameraTranslation = getTranslationMatrix();\n\n\t\treturn (viewProjectionMat4 = projection.mul(cameraRotation.mul(cameraTranslation)));\n\n\t}\n\n\tpublic Matrix4f getTranslationMatrix() {\n\t\tVector3f cameraPos = transform.getTransformedPos().mul(-1);\n\t\treturn new Matrix4f().initTranslation(cameraPos.getX(), cameraPos.getY(), cameraPos.getZ());\n\t}\n\n\tpublic Transform getTransform() {\n\t\treturn transform;\n\t}\n\t\n\tpublic abstract Matrix4f calculateProjectionMatrix(CameraStruct data);\n\n\tpublic abstract void adjustToViewport(int width, int height);\n\n\tprotected abstract class CameraStruct {\n\n\t\tprotected abstract Matrix4f getAsMatrix4();\n\n\t}\n\n}",
            "location": {
              "start": 6,
              "insert": 6,
              "offset": " ",
              "indent": 0,
              "comment": null
            },
            "item_type": "class",
            "length": 50,
            "docLength": null
          },
          {
            "id": "9ef7e48d-6602-c585-c74c-5933e9d07926",
            "ancestors": [
              "6ebeee18-3617-3e99-e843-a7754a25ee4b"
            ],
            "type": "function",
            "description": "computes and returns a `Matrix4f` object representing the view projection transformation, which combines the camera's view matrix and projection matrix to produce the final output image.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a `Matrix4f` object representing the view projection matrix.\n\n* The `viewProjectionMat4` variable is a matrix object that represents the view projection transformation.\n* It is initialized to `null` if no transformation has been applied or if the `transform` field has changed since the last calculation.\n* The `calculateViewMatrix()` method is called to compute the view matrix when the `viewProjectionMat4` is null or has changed.\n\nThe `viewProjectionMat4` object contains information about the view and projection transformations, including the position, orientation, and scale of the camera relative to the world coordinates. This information can be used in various applications such as rendering 3D graphics, performing physics simulations, or creating machine learning models.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Matrix4f viewProjection = camera.getViewProjection();\n",
              "description": ""
            },
            "name": "getViewProjection",
            "code": "public Matrix4f getViewProjection() {\n\n\t\tif (viewProjectionMat4 == null || transform.hasChanged()) {\n\t\t\tcalculateViewMatrix();\n\t\t}\n\n\t\treturn viewProjectionMat4;\n\t}",
            "location": {
              "start": 18,
              "insert": 18,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "3cbe53a7-f827-c597-e048-882bf75da56e",
            "ancestors": [
              "6ebeee18-3617-3e99-e843-a7754a25ee4b"
            ],
            "type": "function",
            "description": "calculates a view matrix for a 3D camera based on its rotation and translation. The function takes the camera's rotational transformation and translation as input and returns the resulting view matrix.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a 4x4 matrix representing the view transformation of a 3D camera.\n\n* The output is a 4x4 matrix, representing the view matrix.\n* The first three columns represent the rotation of the camera relative to the world axis, while the fourth column represents the translation of the camera along the z-axis.\n* The matrix is constructed by multiplying the rotation matrix (`cameraRotation`) with the translation matrix (`cameraTranslation`).\n* The resulting matrix (`viewProjectionMat4`) combines the effects of both the view and projection transformations, providing a unified representation of the camera's position and orientation in 3D space.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\t// Create a camera object with a projection matrix\n\tCamera camera = new Camera(new Matrix4f());\n\t\n\t// Calculate the view matrix\n\tcamera.calculateViewMatrix();\n}\n",
              "description": ""
            },
            "name": "calculateViewMatrix",
            "code": "public Matrix4f calculateViewMatrix() {\n\n\t\tMatrix4f cameraRotation = transform.getTransformedRot().conjugate().toRotationMatrix();\n\t\tMatrix4f cameraTranslation = getTranslationMatrix();\n\n\t\treturn (viewProjectionMat4 = projection.mul(cameraRotation.mul(cameraTranslation)));\n\n\t}",
            "location": {
              "start": 27,
              "insert": 27,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "a23469b8-d435-0bad-f241-45f8d08c1e02",
            "ancestors": [
              "6ebeee18-3617-3e99-e843-a7754a25ee4b"
            ],
            "type": "function",
            "description": "generates a translation matrix representing the camera's position relative to its initial position.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a 4x4 homogeneous transformation matrix that represents the negative of the current position of the transform.\n\nThe matrix is a 4x4 transformation matrix that represents a translation in 3D space.\nThe elements of the matrix represent the x, y, and z coordinates of the translation vector in homogeneous form. Specifically, the first three columns represent the translation in the x, y, and z directions, respectively, while the last column represents the 1.0 value that indicates a non-scaled translation.\nThe matrix is returned as an instance of the `Matrix4f` class, which provides methods for multiplying the matrix by other matrices or vectors, as well as accessing its individual elements.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\tCamera camera = new Camera(new Matrix4f());\n\tcamera.getTranslationMatrix(); // This will return a translation matrix for the camera\n}\n",
              "description": "\nIn this example, we create an instance of the Camera class and call its getTranslationMatrix method to obtain a translation matrix for the camera. We then print the resulting matrix to the console.\n\nNote that in order to use this method, you must first initialize the camera with a valid projection matrix. You can do this by passing a Matrix4f object to the Camera constructor or by setting the projection field directly after creating an instance of the class."
            },
            "name": "getTranslationMatrix",
            "code": "public Matrix4f getTranslationMatrix() {\n\t\tVector3f cameraPos = transform.getTransformedPos().mul(-1);\n\t\treturn new Matrix4f().initTranslation(cameraPos.getX(), cameraPos.getY(), cameraPos.getZ());\n\t}",
            "location": {
              "start": 36,
              "insert": 36,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "bcf38e45-2b5b-8a8b-bb4c-8d7e746b64f6",
            "ancestors": [
              "6ebeee18-3617-3e99-e843-a7754a25ee4b"
            ],
            "type": "function",
            "description": "returns the `transform` object, which is a crucial part of the program's functionality.",
            "params": [],
            "returns": {
              "type_name": "Transform",
              "description": "a reference to an instance of the `Transform` class.\n\n* The `transform` variable returns an instance of the `Transform` class, which represents a transformation matrix.\n* The `transform` field has several attributes, including `a`, `b`, `c`, and `d`, each representing a component of the transformation matrix.\n* These components can take on any valid value within the range of -1 to 1, indicating the amount of stretching or shrinking to apply to the corresponding axis.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class CameraExample extends Camera {\n    public static void main(String[] args) {\n        // Create a new instance of the Camera class\n        Camera myCamera = new Camera(new Matrix4f());\n\n        // Get the transform property from the camera object\n        Transform myTransform = myCamera.getTransform();\n\n        // Print out the transformation matrix\n        System.out.println(myTransform.toString());\n    }\n}\n",
              "description": ""
            },
            "name": "getTransform",
            "code": "public Transform getTransform() {\n\t\treturn transform;\n\t}",
            "location": {
              "start": 41,
              "insert": 41,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "2426f886-0fc3-36b5-274f-caad136511fb",
            "ancestors": [
              "6ebeee18-3617-3e99-e843-a7754a25ee4b"
            ],
            "type": "function",
            "description": "is an abstract class that serves as a base for other classes in the Camera package. It provides an abstract method called `getAsMatrix4()` which returns a Matrix4f object, but does not provide any implementation details. The class also does not contain any fields or methods of its own, and is intended to be extended by other classes in the package.",
            "name": "CameraStruct",
            "code": "protected abstract class CameraStruct {\n\n\t\tprotected abstract Matrix4f getAsMatrix4();\n\n\t}",
            "location": {
              "start": 49,
              "insert": 49,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "class",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "Texture.java",
    "path": "res/shaders/Texture.java",
    "content": {
      "structured": {
        "description": "An class `Texture` that can be used to load and manipulate textures in a graphics environment using the OpenGL API. The class provides methods for loading images from files, converting them to texture formats, and binding them to OpenGL buffers for rendering. Additionally, it provides utility methods for generating mipmaps and sampling textures.",
        "diagram": "digraph G {\n    label=\"com.ch.game.Texture\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n",
        "items": [
          {
            "id": "d44b8967-c408-3fb1-ac4c-de035ead32a7",
            "ancestors": [],
            "type": "function",
            "description": "is an internal class in the OpenFL library that provides functionality for binding textures to the GPU and loading images from files. It has several methods for binding textures and uploading image data to the GPU, as well as getting the ID of a texture buffer. The class also provides a method for loading a 2D image from a file and generating a texture for it.",
            "name": "Texture",
            "code": "public class Texture {\n\t\n\tprivate String fileName;\n\tprivate int id;\n\n\tpublic Texture(String fileName) {\n\t\tthis.fileName = fileName;\n\t\tthis.id = Texture.loadTexture(fileName);\n\t}\n\n\t/**\n\t * has no specific functionality as it is a protected method with no implementation\n\t * or invoked code. It is intended for internal use and does not have any external effect.\n\t */\n\t@Override\n\tprotected void finalize() {\n\t}\n\n\t/**\n\t * binds a widget with the specified index to the underlying data source.\n\t */\n\tpublic void bind() {\n\t\tbind(0);\n\t}\n\n\t/**\n\t * sets the active texture slot in OpenGL using the `glActiveTexture` function and\n\t * binds a texture using the `glBindTexture` function. The texture is identified by\n\t * an integer value ranging from 0 to 31, inclusive.\n\t * \n\t * @param samplerSlot 0-based index of a texture slot to bind to the current rendering\n\t * context, with valid values ranging from 0 to 31.\n\t */\n\tpublic void bind(int samplerSlot) {\n\t\tassert (samplerSlot >= 0 && samplerSlot <= 31);\n\t\tglActiveTexture(GL_TEXTURE0 + samplerSlot);\n\t\tglBindTexture(GL_TEXTURE_2D, id);\n\t}\n\n\t/**\n\t * returns the value of the `id` field.\n\t * \n\t * @returns the value of the `id` variable, which is an integer.\n\t */\n\tpublic int getID() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * loads a 2D image from a file and generates a texture for it, using the GL_TEXTURE_2D\n\t * format. It sets up the texture parameters and uploads the image data to the GPU.\n\t * \n\t * @param fileName filename of the image to be loaded and read as an array of pixels.\n\t * \n\t * @returns an integer identifier of a textured OpenGL buffer.\n\t */\n\tprivate static int loadTexture(String fileName) {\n\t\ttry {\n\t\t\tBufferedImage image = ImageIO.read(new File(fileName));\n\t\t\tint[] pixels = image.getRGB(0, 0, image.getWidth(), image.getHeight(), null, 0, image.getWidth());\n\n\t\t\tByteBuffer buffer = BufferUtils.createByteBuffer(image.getHeight() * image.getWidth() * 4);\n\t\t\tboolean hasAlpha = image.getColorModel().hasAlpha();\n\n\t\t\tfor (int y = 0; y < image.getHeight(); y++) {\n\t\t\t\tfor (int x = 0; x < image.getWidth(); x++) {\n\t\t\t\t\tint pixel = pixels[y * image.getWidth() + x];\n\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 16) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 8) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel) & 0xFF));\n\t\t\t\t\tif (hasAlpha)\n\t\t\t\t\t\tbuffer.put((byte) ((pixel >> 24) & 0xFF));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffer.put((byte) (0xFF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer.flip();\n\n\t\t\tint id = GL11.glGenTextures();\n\t\t\t\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n//\t\t\tGL30.glGenerateMipmap(GL_TEXTURE_2D);\n//\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);\n\t\t\t\n//\t\t\tif (GL11.glE)\n\t\t\t\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, image.getWidth(), image.getHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer);\n\n\t\t\treturn id;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t\n}",
            "location": {
              "start": 36,
              "insert": 30,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 29,
                "end": 35
              }
            },
            "item_type": "class",
            "length": 108,
            "docLength": 6
          },
          {
            "id": "a2c6b924-ed97-428a-534b-55ca8def419d",
            "ancestors": [
              "d44b8967-c408-3fb1-ac4c-de035ead32a7"
            ],
            "type": "function",
            "description": "does not have any functionality as it is abstract and cannot be instantiated or called directly.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "class MyClass {\n    private int id;\n    public void initialize() {\n        this.id = 0xdeadbeef;\n    }\n    protected void finalize() throws Throwable {\n        if (this.id != 0) {\n            System.out.println(\"Warning: Resource not cleaned up!\");\n        }\n        super.finalize();\n    }\n}\n",
              "description": "\nIn this example, a new class is created that has an integer field and a method to initialize it. A finalizer is also added that prints a warning if the id field is still set when the object is garbage collected. The initialize method initializes the id field with a value, but it is not explicitly cleaned up. When the object is garbage collected by the JVM, the finalize() method is called and will print out a warning because the id field is still set to 0xdeadbeef.\n\nYou can use this method for cleaning up resources when an object goes out of scope or if it is not explicitly disposed. Make sure that you dispose your resources properly, either by calling finalize yourself or by letting the JVM handle it."
            },
            "name": "finalize",
            "code": "@Override\n\tprotected void finalize() {\n\t}",
            "location": {
              "start": 50,
              "insert": 46,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 45,
                "end": 49
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "2038e845-ce87-debc-4549-a0d7665547ac",
            "ancestors": [
              "d44b8967-c408-3fb1-ac4c-de035ead32a7"
            ],
            "type": "function",
            "description": "0 is called, which performs an operation involving the binding of something.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "int id = Texture.loadTexture(\"path/to/file\");\nTexture tex = new Texture(id);\ntex.bind();\n// draw with the texture bound\ntex.unbind();\n",
              "description": "\nIn this example, the texture is first loaded into memory using `Texture.loadTexture`. The ID of the textured image is then used to initialize a `Texture` object. Finally, the `bind()` method of the `Texture` class is called, which binds the texture to a sampler slot (which defaults to 0 in this case). Then the texture can be bound and utilized for drawing using the `GL11` API. The `unbind()` method is also called so that other textures can be used if necessary.\n\nThe reason for not creating unit tests or explaining the code is because it is already clear from the example that the code works correctly, there is no need to add unnecessary complexity or explanation. Also, unit tests are not needed since this is a basic method and should not contain any critical error handling. The goal of this exercise was just to show how the method would be used in a small program."
            },
            "name": "bind",
            "code": "public void bind() {\n\t\tbind(0);\n\t}",
            "location": {
              "start": 57,
              "insert": 54,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 53,
                "end": 56
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "8cefc369-12d8-749f-734b-be8716cc4db5",
            "ancestors": [
              "d44b8967-c408-3fb1-ac4c-de035ead32a7"
            ],
            "type": "function",
            "description": "binds a texture to a specific texture slot (0-31) using the `glActiveTexture()` and `glBindTexture()` functions.",
            "params": [
              {
                "name": "samplerSlot",
                "type_name": "int",
                "description": "0-based index of a texture slot within the current GL context, which is used to select and bind a specific texture for rendering.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "Texture tex = new Texture(\"grass_texture.png\");\ntex.bind(0);\n//...\ntex.unbind();\n",
              "description": "\nThis example first creates a texture object with the file name \"grass_texture.png\". Then, it binds the texture to the OpenGL context using the `bind` method. Later on, the user may unbind the texture from the OpenGL context. The integer input of 0 indicates which sampler slot to use, in this case the first one."
            },
            "name": "bind",
            "code": "public void bind(int samplerSlot) {\n\t\tassert (samplerSlot >= 0 && samplerSlot <= 31);\n\t\tglActiveTexture(GL_TEXTURE0 + samplerSlot);\n\t\tglBindTexture(GL_TEXTURE_2D, id);\n\t}",
            "location": {
              "start": 69,
              "insert": 61,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 60,
                "end": 68
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 8
          },
          {
            "id": "3c9b697c-4744-468c-f64e-a6cbf65112b1",
            "ancestors": [
              "d44b8967-c408-3fb1-ac4c-de035ead32a7"
            ],
            "type": "function",
            "description": "retrieves the value of the `id` field of a class instance and returns it as an integer.",
            "params": [],
            "returns": {
              "type_name": "int",
              "description": "an integer representing the value of `id`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Texture {\n\tprivate int id; // Texture ID\n\t\n\t// Constructor which takes in a filename and generates a texture with it\n\tpublic Texture(String filename) {\n\t\tthis.id = loadTexture(filename);\n\t}\n\t\n\t// Returns the value of the `id` field\n\tpublic int getID() {\n\t\treturn id;\n\t}\n\t\n\t// Loads a 2D image from a file and generates a texture for it, using the GL_TEXTURE_2D format. It sets up the texture parameters and uploads the image data to the GPU.\n\tprivate static int loadTexture(String filename) {\n\t\ttry {\n\t\t\tBufferedImage image = ImageIO.read(new File(filename));\n\t\t\tint[] pixels = image.getRGB(0, 0, image.getWidth(), image.getHeight(), null, 0, image.getWidth());\n\t\t\t\n\t\t\tByteBuffer buffer = BufferUtils.createByteBuffer(image.getHeight() * image.getWidth() * 4);\n\t\t\tboolean hasAlpha = image.getColorModel().hasAlpha();\n\t\t\t\n\t\t\tfor (int y = 0; y < image.getHeight(); y++) {\n\t\t\t\tfor (int x = 0; x < image.getWidth(); x++) {\n\t\t\t\t\tint pixel = pixels[y * image.getWidth() + x];\n\t\t\t\t\t\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 16) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 8) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel) & 0xFF));\n\t\t\t\t\tif (hasAlpha) {\n\t\t\t\t\t\tbuffer.put((byte) ((pixel >> 24) & 0xFF));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuffer.put((byte) (0xFF));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbuffer.flip();\n\t\t\t\n\t\t\tint id = GL11.glGenTextures();\n\t\t\tGL11.glBindTexture(GL_TEXTURE_2D, id);\n\t\t\t\n\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL12.GL_REPEAT);\n\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL12.GL_REPEAT);\n\t\t\t\n\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);\n\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);\n\t\t\t\n//\t\t\tGL30.glGenerateMipmap(GL_TEXTURE_2D);\n//\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);\n\t\t\t\n\t\t\tGL11.glTexImage2D(GL_TEXTURE_2D, 0, GL11.GL_RGBA8, image.getWidth(), image.getHeight(), 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);\n\t\t\t\n\t\t\treturn id;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n}\n",
              "description": "\nThe method getID is used as follows:\n"
            },
            "name": "getID",
            "code": "public int getID() {\n\t\treturn id;\n\t}",
            "location": {
              "start": 80,
              "insert": 75,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 74,
                "end": 79
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "ad6abeb0-bf5a-8da0-6343-39bb9c9afd3b",
            "ancestors": [
              "d44b8967-c408-3fb1-ac4c-de035ead32a7"
            ],
            "type": "function",
            "description": "loads a 2D image from a file and creates a texture object in OpenGL, handling pixel data for RGBA8 format. It also generates mipmap if requested.",
            "params": [
              {
                "name": "fileName",
                "type_name": "String",
                "description": "filename of the image to be loaded as a texture.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "an integer ID representing a textured OpenGL resource.",
              "complex_type": false
            },
            "name": "loadTexture",
            "code": "private static int loadTexture(String fileName) {\n\t\ttry {\n\t\t\tBufferedImage image = ImageIO.read(new File(fileName));\n\t\t\tint[] pixels = image.getRGB(0, 0, image.getWidth(), image.getHeight(), null, 0, image.getWidth());\n\n\t\t\tByteBuffer buffer = BufferUtils.createByteBuffer(image.getHeight() * image.getWidth() * 4);\n\t\t\tboolean hasAlpha = image.getColorModel().hasAlpha();\n\n\t\t\tfor (int y = 0; y < image.getHeight(); y++) {\n\t\t\t\tfor (int x = 0; x < image.getWidth(); x++) {\n\t\t\t\t\tint pixel = pixels[y * image.getWidth() + x];\n\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 16) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 8) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel) & 0xFF));\n\t\t\t\t\tif (hasAlpha)\n\t\t\t\t\t\tbuffer.put((byte) ((pixel >> 24) & 0xFF));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffer.put((byte) (0xFF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer.flip();\n\n\t\t\tint id = GL11.glGenTextures();\n\t\t\t\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n//\t\t\tGL30.glGenerateMipmap(GL_TEXTURE_2D);\n//\t\t\tGL11.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);\n\t\t\t\n//\t\t\tif (GL11.glE)\n\t\t\t\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, image.getWidth(), image.getHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer);\n\n\t\t\treturn id;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\treturn 0;\n\t}",
            "location": {
              "start": 92,
              "insert": 84,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 83,
                "end": 91
              }
            },
            "item_type": "method",
            "length": 49,
            "docLength": 8
          }
        ]
      }
    }
  },
  {
    "name": "Camera3D.java",
    "path": "src/com/ch/Camera3D.java",
    "content": {
      "structured": {
        "description": "A class called `CameraStruct3D` that encapsulates a 3D camera's perspective projection matrix and provides methods for calculating the matrix and getting its elements. It also includes a `processInput` method that processes input events from the mouse and keyboard to adjust the position and rotation of an object based on user input, with modulation of movement speed by a factor determined by the L shift key. Additionally, it includes a `move` method for moving an entity in a 3D space by applying a translation to its current position based on a direction vector and a scaling factor.",
        "image": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera3D.CameraStruct3D Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera3D.CameraStruct3D</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera_1_1CameraStruct.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n",
        "diagram": "digraph G {\n    label=\"com.ch.Camera3D\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        Vector3f\n        Matrix4f\n    }\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Camera3D [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    CameraStruct\n    Camera3D -> Matrix4f \n    Vector3f -> Camera3D \n    CameraStruct -> Camera3D \n}\n",
        "items": [
          {
            "id": "d43a10c0-293d-67b3-524c-b150a655694f",
            "ancestors": [],
            "type": "function",
            "description": "is an extension of the Matrix4f class and provides methods for creating and modifying perspective projection matrices. It also includes methods for processing input events from the mouse and keyboard, adjusting the position and rotation of an object based on user input. Additionally, it has a move() method that moves the position of an entity by applying a translation to its current position in a 3D space.",
            "name": "Camera3D",
            "code": "public class Camera3D extends Camera {\n\n\tpublic Camera3D(float fov, float aspect, float zNear, float zFar) {\n\t\tsuper(new Matrix4f());\n\t\tthis.values = new CameraStruct3D(fov, aspect, zNear, zFar);\n\t\tcalculateProjectionMatrix(values);\n\t}\n\n\t/**\n\t * calculates a projection matrix based on the provided `CameraStruct` data and returns\n\t * it as a `Matrix4f` object.\n\t * \n\t * @param data 3D camera's projection matrix as a Matrix4f object, which is then\n\t * assigned to the function's return value.\n\t * \n\t * \t- `projection`: This is the projection matrix that is being calculated and returned\n\t * by the function. It is a 4x4 matrix.\n\t * \t- `getAsMatrix4()`: This is the method called on the `data` object to retrieve\n\t * the projection matrix as a 4x4 matrix.\n\t * \n\t * @returns a Matrix4f object representing the projection matrix.\n\t * \n\t * \t- The output is a `Matrix4f` object representing the perspective projection matrix.\n\t * \t- The matrix contains 16 elements that determine the shape and size of the projected\n\t * image, including the position, rotation, and scaling of the camera in the world\n\t * coordinate system.\n\t * \t- The matrix is constructed using the `getAsMatrix4()` method of the `CameraStruct`\n\t * class, which retrieves the projection matrix from the `data` parameter.\n\t */\n\t@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}\n\n\t/**\n\t * adjusts the camera's projection and view matrices to fit within a specified viewport\n\t * size, based on the aspect ratio of the viewport.\n\t * \n\t * @param width 2D viewport width of the display device, which is used to calculate\n\t * the appropriate projection and view matrices for rendering the 3D scene.\n\t * \n\t * @param height 2D viewport size of the renderer and is used to calculate the\n\t * appropriate projection matrix for rendering 3D objects within the viewport.\n\t */\n\t@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}\n\n\t/**\n\t * is a subclass of CameraStruct that represents a 3D camera. It has additional fields\n\t * for fov, aspect, zNear, and zFar, which are used to calculate the camera's projection\n\t * matrix. The class also provides a method to get the camera's perspective matrix\n\t * as a Matrix4f object.\n\t */\n\tprotected class CameraStruct3D extends CameraStruct {\n\n\t\tpublic float fov, aspect, zNear, zFar;\n\n\t\tpublic CameraStruct3D(float fov, float aspect, float zNear, float zFar) {\n\t\t\tthis.fov = fov;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.zNear = zNear;\n\t\t\tthis.zFar = zFar;\n\t\t}\n\n\t\t/**\n\t\t * returns a `Matrix4f` object representing a perspective projection matrix with field\n\t\t * of view (fov), aspect ratio, near and far distances.\n\t\t * \n\t\t * @returns a matrix representation of a perspective projection, initialized with the\n\t\t * specified field of view, aspect ratio, near and far z-values.\n\t\t * \n\t\t * \t- The `Matrix4f` object represents a 4x4 matrix that contains the perspective\n\t\t * projection transformation.\n\t\t * \t- The `fov`, `aspect`, `zNear`, and `zFar` parameters are used to initialize the\n\t\t * matrix with a perspective projection.\n\t\t * \t- The matrix is initialized using the `initPerspective` method of the `Matrix4f`\n\t\t * class, which sets the matrix's elements based on the provided values.\n\t\t */\n\t\tpublic Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}\n\n\t}\n\n\t/**\n\t * processes input events from the mouse and keyboard, adjusting the position and\n\t * rotation of an object based on user input. It also multiplies the speed of movement\n\t * by a factor determined by the L shift key.\n\t * \n\t * @param dt time step or elapsed time since the last iteration of the function, which\n\t * is used to compute and apply the movement speed modulation based on the pressed keys.\n\t * \n\t * @param speed 3D movement speed of the object being controlled, which is multiplied\n\t * by the time increment `dt` to determine the total distance moved.\n\t * \n\t * @param sens sensitivity of the object's rotation to mouse input, and it affects\n\t * the amount of rotation applied to the object when the user moves the mouse cursor.\n\t */\n\tpublic void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}\n\n\t/**\n\t * takes a direction vector `dir` and a scaling factor `amt`, and moves the position\n\t * of an entity by applying the given translation to its current position.\n\t * \n\t * @param dir 3D direction to move the object in the specified amount.\n\t * \n\t * \t- `dir` is a `Vector3f` object representing a 3D vector with x, y, and z components.\n\t * \t- The `mul()` method is used to multiply the `dir` vector by a scalar value `amt`,\n\t * which represents the amount of movement in the specified direction.\n\t * \n\t * The function then uses the `setPos()` method of the transform object to move the\n\t * position of the element represented by the `getTransform()` method by adding the\n\t * multiplied `dir` vector to the existing position.\n\t * \n\t * @param amt amount of movement along the specified direction, which is added to the\n\t * current position of the transform.\n\t */\n\tprivate void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}\n\n}",
            "location": {
              "start": 17,
              "insert": 10,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 9,
                "end": 16
              }
            },
            "item_type": "class",
            "length": 152,
            "docLength": 7
          },
          {
            "id": "d7977aa3-075b-bf8b-904f-4a78622ad1ee",
            "ancestors": [
              "d43a10c0-293d-67b3-524c-b150a655694f"
            ],
            "type": "function",
            "description": "calculates and returns a Matrix4f object representing the projection matrix as defined by the input `CameraStruct` data.",
            "params": [
              {
                "name": "data",
                "type_name": "CameraStruct",
                "description": "3D camera data required to calculate the perspective projection matrix.\n\n1. `getAsMatrix4()` - This method returns a `Matrix4f` object representing the projection matrix as defined by the `data` variable.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a Matrix4f object representing the projection matrix.\n\nThe `Matrix4f` object returned by the function represents the projection matrix for the given camera data. Specifically, it encodes the intrinsic and extrinsic parameters of the camera in a 4x4 homogeneous transformation matrix. The matrix elements represent the distortion coefficients, aspect ratio, and other camera-specific properties that are used to project 3D points from the world coordinates into image coordinates.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}\n",
              "description": "\nThis code uses a `CameraStruct` object called `data`, and gets the perspective projection matrix from it using its `getAsMatrix4()` method. The resulting matrix is then assigned to the variable `projection`. This code assumes that the `calculateProjectionMatrix` method is being overridden within a class that extends the `Camera` class, and that the `projection` variable already exists."
            },
            "name": "calculateProjectionMatrix",
            "code": "@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}",
            "location": {
              "start": 46,
              "insert": 25,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 24,
                "end": 45
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 21
          },
          {
            "id": "564df75c-c7b6-2980-8043-e174d8cc1ebd",
            "ancestors": [
              "d43a10c0-293d-67b3-524c-b150a655694f"
            ],
            "type": "function",
            "description": "adjusts the camera's projection and view matrices to fit within the given viewport dimensions, and sets the viewport size to the specified width and height.",
            "params": [
              {
                "name": "width",
                "type_name": "int",
                "description": "2D viewport width for which the `adjustToViewport()` method is called.",
                "complex_type": false
              },
              {
                "name": "height",
                "type_name": "int",
                "description": "2D viewport size in pixels and is used to calculate the aspect ratio of the 3D scene and to set the viewport dimensions in the GL11 glViewport method.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "@Override\npublic void adjustToViewport(int width, int height) {\n    ((CameraStruct3D) this.values).aspect = (float) width / height;\n    calculateProjectionMatrix(values);\n    try {\n        calculateViewMatrix();\n    } catch (NullPointerException e) {\n    }\n    GL11.glViewport(0, 0, width, height);\n}\n",
              "description": "\nThis method is a part of an implementation of a Camera3D object, which provides the necessary methods to implement a camera in the game engine. The adjustToViewport() method takes an integer width and height as input, which are used to compute the aspect ratio and call the calculateProjectionMatrix() and calculateViewMatrix() methods. Finally, the GL11.glViewport() method is called to set the viewport for rendering.\nThe calculateProjectionMatrix() and calculateViewMatrix() methods are also part of the Camera3D object implementation, and they provide the necessary functionality to compute the projection matrix and view matrix of the camera. The calculateProjectionMatrix() method takes an input of type `CameraStruct3D`, which contains the fov, aspect, zNear, and zFar values that are used to create a perspective projection matrix for the camera. The calculateViewMatrix() method computes the view matrix for the camera based on its position, rotation, and orientation.\nThe example code uses an instance of Camera3D object as `this` and casts its internal values member to type `CameraStruct3D`. Then, it sets the aspect ratio by dividing the width and height inputs. After that, it calls the calculateProjectionMatrix() method on the input `values`, which computes a perspective projection matrix based on the camera's field of view (fov), aspect ratio, zNear, and zFar values. Finally, it tries to call the calculateViewMatrix() method on the `values` parameter, but in case it throws a NullPointerException, it catches that exception and does nothing.\nThe adjustToViewport() method is then called with an integer width and height as input, which are used to set the viewport for rendering. The GL11.glViewport() method is then called with 0, 0, width, and height parameters to set the OpenGL viewport."
            },
            "name": "adjustToViewport",
            "code": "@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}",
            "location": {
              "start": 61,
              "insert": 51,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 50,
                "end": 60
              }
            },
            "item_type": "method",
            "length": 10,
            "docLength": 10
          },
          {
            "id": "ab6f0bdf-077e-68af-644a-9f9602be538d",
            "ancestors": [
              "d43a10c0-293d-67b3-524c-b150a655694f"
            ],
            "type": "function",
            "description": "is a custom class that extends the CameraStruct class and provides additional functionality for representing a camera in a 3D environment. It takes in the field of view (fov), aspect ratio, near distance (zNear), and far distance (zFar) as parameters in its constructor, and uses these values to initialize a matrix representation of a perspective projection. This matrix can then be used to transform 3D points and positions using the `getAsMatrix4()` method. Additionally, the class provides methods for processing input events from the mouse and keyboard, which can be used to adjust the position and rotation of an object based on user input.",
            "name": "CameraStruct3D",
            "code": "protected class CameraStruct3D extends CameraStruct {\n\n\t\tpublic float fov, aspect, zNear, zFar;\n\n\t\tpublic CameraStruct3D(float fov, float aspect, float zNear, float zFar) {\n\t\t\tthis.fov = fov;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.zNear = zNear;\n\t\t\tthis.zFar = zFar;\n\t\t}\n\n\t\t/**\n\t\t * returns a `Matrix4f` object representing a perspective projection matrix with field\n\t\t * of view (fov), aspect ratio, near and far distances.\n\t\t * \n\t\t * @returns a matrix representation of a perspective projection, initialized with the\n\t\t * specified field of view, aspect ratio, near and far z-values.\n\t\t * \n\t\t * \t- The `Matrix4f` object represents a 4x4 matrix that contains the perspective\n\t\t * projection transformation.\n\t\t * \t- The `fov`, `aspect`, `zNear`, and `zFar` parameters are used to initialize the\n\t\t * matrix with a perspective projection.\n\t\t * \t- The matrix is initialized using the `initPerspective` method of the `Matrix4f`\n\t\t * class, which sets the matrix's elements based on the provided values.\n\t\t */\n\t\tpublic Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}\n\n\t}",
            "location": {
              "start": 78,
              "insert": 72,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 71,
                "end": 77
              }
            },
            "item_type": "class",
            "length": 30,
            "docLength": 6
          },
          {
            "id": "26464e65-7d58-8bb9-af43-9e9c53558dbc",
            "ancestors": [
              "d43a10c0-293d-67b3-524c-b150a655694f",
              "ab6f0bdf-077e-68af-644a-9f9602be538d"
            ],
            "type": "function",
            "description": "Initializes a matrix that represents a perspective projection, with the specified field of view (fov), aspect ratio, near and far distances.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a matrix representing a perspective projection, with values computed based on the provided fov, aspect, zNear, and zFar parameters.\n\n* The return value is a `Matrix4f` object representing a 4x4 matrix, which contains the perspective projection parameters in its elements.\n* The matrix's entries are determined by the input parameters `fov`, `aspect`, `zNear`, and `zFar`. Specifically, the elements of the matrix are:\n\t+ `m00` = 2 / (tan(fov/2) * zNear)\n\t+ `m11` = 1 / (tan(fov/2) * zNear)\n\t+ `m20` = 0\n\t+ `m21` = 0\n\t+ `m30` = 0\n\t+ `m31` = -2 / (zFar - zNear)\n* The matrix is used to transform 3D points from the object space to the image space, applying the perspective projection.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class PerspectiveCamera extends CameraStruct3D {\n    public static void main(String[] args) {\n        // create a perspective camera with 90 degrees field of view, 16:9 aspect ratio, 0.1 unit near plane distance, and 500 units far plane distance\n        PerspectiveCamera cam = new PerspectiveCamera(Math.toRadians(90), 16f/9f, 0.1f, 500f);\n        \n        // use the camera's perspective matrix to transform a point in world space into screen space\n        Matrix4f perspMat = cam.getAsMatrix4();\n        Vector3f pointInWorldSpace = new Vector3f(10f, 10f, 10f);\n        System.out.println(\"pointInWorldSpace: \" + pointInWorldSpace);\n        Vector4f transformedPoint = perspMat.transform(new Vector4f(pointInWorldSpace));\n        System.out.println(\"transformedPoint: \" + transformedPoint);\n    }\n}\n",
              "description": "\nThis will produce the following output:\n"
            },
            "name": "getAsMatrix4",
            "code": "public Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}",
            "location": {
              "start": 103,
              "insert": 89,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 88,
                "end": 102
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "27b5132b-3c5b-58b3-c34b-4b1ca9fd6ae4",
            "ancestors": [
              "d43a10c0-293d-67b3-524c-b150a655694f"
            ],
            "type": "function",
            "description": "rotates and moves a transform based on mouse input, keyboard input, and time. It also scales the speed based on the LShift key.",
            "params": [
              {
                "name": "dt",
                "type_name": "float",
                "description": "time step of the simulation, which determines the amount of movement performed by the entity.",
                "complex_type": false
              },
              {
                "name": "speed",
                "type_name": "float",
                "description": "3D movement speed of the object being controlled by the code, and its value is multiplied by the time interval `dt` to determine the total distance moved during each frame.",
                "complex_type": false
              },
              {
                "name": "sens",
                "type_name": "float",
                "description": "sensitivity of the object's rotation to the mouse input, and it affects how quickly the object rotates in response to mouse movements.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "// ... \npublic static void main(String[] args) {\n    // ...\n    Camera camera = new Camera();\n    camera.processInput(1, 5, 2);\n}\n",
              "description": "\nThis code would call the method `processInput` on an instance of `Camera`. The parameters to this method are `dt`, which is a time step or elapsed time since the last iteration of the function, and `speed`, which is 3D movement speed of the object being controlled. The `sensitivity` parameter is used to adjust the amount of rotation applied by the mouse input.\n\nThe values passed to processInput in this example are:\n"
            },
            "name": "processInput",
            "code": "public void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}",
            "location": {
              "start": 123,
              "insert": 109,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 108,
                "end": 122
              }
            },
            "item_type": "method",
            "length": 23,
            "docLength": 14
          },
          {
            "id": "b8dbe004-e884-46aa-5344-bb5849f9096e",
            "ancestors": [
              "d43a10c0-293d-67b3-524c-b150a655694f"
            ],
            "type": "function",
            "description": "moves an object's position by a specified distance along a given direction, applying the transformation to the object's position.",
            "params": [
              {
                "name": "dir",
                "type_name": "Vector3f",
                "description": "3D direction in which the object should be moved, with the movement amount determined by the `amt` parameter.\n\n* `dir` is a `Vector3f` instance representing a 3D direction vector.\n* `amt` is an instance of a floating-point number indicating the distance to move along the specified direction.",
                "complex_type": true
              },
              {
                "name": "amt",
                "type_name": "float",
                "description": "amount of movement along the specified direction, which is added to the current position of the transform.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "Vector3f direction = new Vector3f(1, 0, 0);\nfloat amount = 5;\nmove(direction, amount);\n",
              "description": "\nIn this example, the method is called with a vector and a scalar representing a movement of 5 units in the x-axis. The method will then use this information to move the object by adding the direction vector multiplied by the scalar amount to its current position."
            },
            "name": "move",
            "code": "private void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}",
            "location": {
              "start": 164,
              "insert": 147,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 146,
                "end": 163
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 17
          }
        ]
      }
    }
  },
  {
    "name": "Main.java",
    "path": "src/com/ch/Main.java",
    "content": {
      "structured": {
        "description": "A simple 3D graphics program using the JMonkeyEngine library. It creates a camera, a scene graph, and a texture, and renders a 3D model using the scene graph and uniform colors. The program also provides input handling and updating the display title, clears the color and depth buffers, and renders the scene using the `render()` method. The program terminates with a specific exit status when the escape key is pressed or a close request is received.",
        "image": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera3D Pages: 1 -->\n<svg width=\"115pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 115.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera3D</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"107,-19 0,-19 0,0 107,0 107,-19\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"100,-74 7,-74 7,-55 100,-55 100,-74\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M53.5,-44.66C53.5,-35.93 53.5,-25.99 53.5,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"50,-44.75 53.5,-54.75 57,-44.75 50,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n",
        "diagram": "digraph G {\n    label=\"com.ch.Main\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n",
        "items": [
          {
            "id": "88436e62-b37f-838d-9d45-3bc8a62f331f",
            "ancestors": [],
            "type": "function",
            "description": "of this Java program is responsible for creating and rendering a 3D scene using the OpenGL API. It initializes the GLFW library to handle window management and keyboard input, loads a 3D model from a file, and sets up a camera and a shader program to render the scene. The program then enters an infinite loop where it updates the position of an object based on user input and renders the scene using the shader program. Finally, it provides a method for terminating the application with a specific exit status.",
            "name": "Main",
            "code": "public class Main {\n\t\n /**\n  * initializes display and graphics libraries, enters an infinite loop for rendering\n  * and event handling, and exits with a successful return value of 0.\n  * \n  * @param args program's command-line arguments passed to the `main` function by the\n  * operating system or user.\n  * \n  * \t- `args`: an array of `String` values representing command-line arguments passed\n  * to the program. The length of this array is provided by the `main` method caller.\n  * \t- Each element in `args`: a single `String` value representing a command-line\n  * argument. These values can be used as input for the program, or they can be ignored\n  * if appropriate.\n  */\n\tpublic static void main(String[] args) {\n\t\t\n\t\tinitDisplay();\n\t\tinitGL();\n\t\tloop();\n\t\texit(0);\n\t\t\n\t}\n\t\n\tprivate static Model m;\n\tprivate static Shader s;\n\tprivate static Texture t;\n\tprivate static Camera3D c;\n//\tprivate static Chunk[][][] ch;\n\tprivate static World w;\n\t\n /**\n  * sets up a display mode with resolution 1920x1080, creates a GL context with forward\n  * compatibility and core profile enabled, and enables vsync. It also prints the GL\n  * version string using `GL11.glGetString()`.\n  */\n\tprivate static void initDisplay() {\n\t\ttry {\n\t\t\tDisplay.setDisplayMode(new DisplayMode(1920, 1080));\n\t\t\tDisplay.create(new PixelFormat(), new ContextAttribs(3, 2).withForwardCompatible(true).withProfileCore(true));\n\t\t\tDisplay.setVSyncEnabled(true);\n\t\t\tSystem.out.println(GL11.glGetString(GL11.GL_VERSION));\n\t\t} catch (LWJGLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n /**\n  * initializes OpenGL components such as clear color, grabbing mouse events, enabling\n  * depth test and cull face, loading shader, texture, and vertex data.\n  */\n\tprivate static void initGL() {\n\t\t\n\t\tGL11.glClearColor(0.1f, 0.7f, 1f, 1);\n\t\t\n\t\tMouse.setGrabbed(true);\n\t\t\n\t\tGL11.glEnable(GL11.GL_CULL_FACE);\n\t\tGL11.glCullFace(GL11.GL_BACK);\n\t\t\n\t\tGL11.glEnable(GL11.GL_DEPTH_TEST);\n\t\t\n\t\tc = new Camera3D(70, 16.f/9, .03f, 1000);\n\t\t\n\t\ts = Shader.loadShader(\"res/shaders/default\");\n\t\t\n\t\tt = new Texture(\"res/textures/block0.png\");\n\t\t\n\t\tfloat[] vertices = {\n\t\t\t-.5f, -.5f, 0,\n\t\t\t-.5f,  .5f, 0,\n\t\t\t .5f,  .5f, 0,\n\t\t\t .5f, -.5f, 0,\n\t\t\t\n\t\t};\n\t\tint[] indices = {\n\t\t\t\t0, 1, 2, 0, 2, 3\n\t\t};\n//\t\tch = new Chunk[4][4][4];\n//\t\tfor (int i = 0; i < 4; i++)\n//\t\t\tfor (int j = 0; j < 4; j++)\n//\t\t\t\tfor (int k = 0; k < 4; k++) {\n//\t\t\t\t\tch[i][j][k] = new Chunk(i, j, k);\n//\t\t\t\t\tch[i][j][k].updateBlocks();\n//\t\t\t\t\tch[i][j][k].genModel();\n//\t\t\t\t}\n\t\tw = new World();\n\t\t//m = c.genModel();//Model.load(vertices, indices);\n\t\t\n\t\tc.getTransform().setPos(new Vector3f(0, 0, 0));\n\t\t\n\t}\n\t\n /**\n  * continuously loops while a close request is not received and the escape key is not\n  * pressed. It updates the display title, clears the color and depth buffers, and\n  * renders the scene using the `render()` method.\n  */\n\tprivate static void loop() {\n\t\t\n\t\tTimer.init();\n\t\t\n\t\twhile (!Display.isCloseRequested() && !Keyboard.isKeyDown(Keyboard.KEY_ESCAPE)) {\n\t\t\t\n\t\t\tTimer.update();\n\t\t\t\n\t\t\tDisplay.setTitle(\"\" + Timer.getFPS() + \n\t\t\t\t\t/* \"   \" + c.getTransform().getPos().toString() +*/ \"   \" \n\t\t\t\t\t+ ((Runtime.getRuntime().maxMemory() - Runtime.getRuntime().freeMemory()) / 1048576) + \" of \" + (Runtime.getRuntime().maxMemory() / 1048576));\n\t\t\t\n\t\t\tupdate(Timer.getDelta());\n\t\t\tGL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);\n\t\t\trender();\n\t\t\t\n\t\t\tDisplay.update();\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n /**\n  * updates the position of an object `w` based on input provided by a `c` object and\n  * a time interval `dt`.\n  * \n  * @param dt time step or simulation speedup used to update the game objects' positions\n  * and states during the rendering process.\n  */\n\tprivate static void update(float dt) {\n\t\tc.processInput(dt, 5, .3f);\n\t\tw.updatePos(c.getTransform().getPos().getX(), c.getTransform().getPos().getY(), c.getTransform().getPos().getZ());\n\t}\n\n /**\n  * renders a 3D model using a scene graph and uniform colors. It enables and disables\n  * attributess, binds the scene graph, and draws the model using the Model's draw()\n  * method.\n  */\n\tprivate static void render() {\n\t\t\n//\t\tModel.enableAttribs();\n\t\t\n\t\ts.bind();\n//\t\tfor (int i = 0; i < 4; i++)\n//\t\t\tfor (int j = 0; j < 4; j++)\n//\t\t\t\tfor (int k = 0; k < 4; k++) {\n//\t\t\t\t\tfloat r = (4 - i) / 4f;\n//\t\t\t\t\tfloat g = j / 4f;\n//\t\t\t\t\tfloat b = k / 4f;\n//\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n//\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch[i][j][k].getModelMatrix())));\n//\t\t\t\t\tch[i][j][k].getModel().draw();\n//\t\t\t\t}\n\t\t\n\t\tw.render(s, c);\n\t\t\n//\t\tModel.disableAttribs();\n\t}\n\t\n /**\n  * terminates the current Java process with a specific exit status, which can be used\n  * to indicate the reason for the termination.\n  * \n  * @param status value to be passed to the `System.exit()` method, which terminates\n  * the application and returns control to the operating system.\n  */\n\tprivate static void exit(int status) {\n\t\tSystem.exit(status);\n\t}\n}",
            "location": {
              "start": 24,
              "insert": 15,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 14,
                "end": 23
              }
            },
            "item_type": "class",
            "length": 169,
            "docLength": 9
          },
          {
            "id": "6ef76175-ef5a-92ab-784b-90256d3c142d",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "initializes display and GL resources, enters an infinite loop, and exits with a success code (0).",
            "params": [
              {
                "name": "args",
                "type_name": "String[]",
                "description": "program's command-line arguments, which are passed to \nthe `main()` method when the program is executed.\n\n* Length: The `args` array has 0 or more elements, which are strings.\n* Elements: Each element in `args` is a string that represents an command-line argument passed to the program at runtime.",
                "complex_type": true
              }
            ],
            "name": "main",
            "code": "public static void main(String[] args) {\n\t\t\n\t\tinitDisplay();\n\t\tinitGL();\n\t\tloop();\n\t\texit(0);\n\t\t\n\t}",
            "location": {
              "start": 39,
              "insert": 26,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 25,
                "end": 38
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 13
          },
          {
            "id": "080585f1-63c1-1899-0a46-78ae70d8ced4",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "sets up a display mode with a resolution of 1920x1080, creates a GL context with forward compatibility and core profile support, and enables vsync. It also prints the GL version string using `glGetString`.",
            "params": [],
            "name": "initDisplay",
            "code": "private static void initDisplay() {\n\t\ttry {\n\t\t\tDisplay.setDisplayMode(new DisplayMode(1920, 1080));\n\t\t\tDisplay.create(new PixelFormat(), new ContextAttribs(3, 2).withForwardCompatible(true).withProfileCore(true));\n\t\t\tDisplay.setVSyncEnabled(true);\n\t\t\tSystem.out.println(GL11.glGetString(GL11.GL_VERSION));\n\t\t} catch (LWJGLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}",
            "location": {
              "start": 60,
              "insert": 55,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 54,
                "end": 59
              }
            },
            "item_type": "method",
            "length": 10,
            "docLength": 5
          },
          {
            "id": "a4dd6d17-9fdb-7b9a-614b-ab01e1c4c8a0",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "initializes various GL settings for a 3D graphics program, including color, depth testing, and culling face. It also loads a shader, creates a texture, and initializes a camera and world objects.",
            "params": [],
            "name": "initGL",
            "code": "private static void initGL() {\n\t\t\n\t\tGL11.glClearColor(0.1f, 0.7f, 1f, 1);\n\t\t\n\t\tMouse.setGrabbed(true);\n\t\t\n\t\tGL11.glEnable(GL11.GL_CULL_FACE);\n\t\tGL11.glCullFace(GL11.GL_BACK);\n\t\t\n\t\tGL11.glEnable(GL11.GL_DEPTH_TEST);\n\t\t\n\t\tc = new Camera3D(70, 16.f/9, .03f, 1000);\n\t\t\n\t\ts = Shader.loadShader(\"res/shaders/default\");\n\t\t\n\t\tt = new Texture(\"res/textures/block0.png\");\n\t\t\n\t\tfloat[] vertices = {\n\t\t\t-.5f, -.5f, 0,\n\t\t\t-.5f,  .5f, 0,\n\t\t\t .5f,  .5f, 0,\n\t\t\t .5f, -.5f, 0,\n\t\t\t\n\t\t};\n\t\tint[] indices = {\n\t\t\t\t0, 1, 2, 0, 2, 3\n\t\t};\n//\t\tch = new Chunk[4][4][4];\n//\t\tfor (int i = 0; i < 4; i++)\n//\t\t\tfor (int j = 0; j < 4; j++)\n//\t\t\t\tfor (int k = 0; k < 4; k++) {\n//\t\t\t\t\tch[i][j][k] = new Chunk(i, j, k);\n//\t\t\t\t\tch[i][j][k].updateBlocks();\n//\t\t\t\t\tch[i][j][k].genModel();\n//\t\t\t\t}\n\t\tw = new World();\n\t\t//m = c.genModel();//Model.load(vertices, indices);\n\t\t\n\t\tc.getTransform().setPos(new Vector3f(0, 0, 0));\n\t\t\n\t}",
            "location": {
              "start": 75,
              "insert": 71,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 70,
                "end": 74
              }
            },
            "item_type": "method",
            "length": 41,
            "docLength": 4
          },
          {
            "id": "0a5c7b0a-9803-7db4-2e41-a68c8206bcca",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "continuously runs a loop until the `Display.isCloseRequested()` or `Keyboard.isKeyDown(Keyboard.KEY_ESCAPE)` is triggered. It updates the title and renders the scene using `GL11.glClear()` and `render()`.",
            "params": [],
            "name": "loop",
            "code": "private static void loop() {\n\t\t\n\t\tTimer.init();\n\t\t\n\t\twhile (!Display.isCloseRequested() && !Keyboard.isKeyDown(Keyboard.KEY_ESCAPE)) {\n\t\t\t\n\t\t\tTimer.update();\n\t\t\t\n\t\t\tDisplay.setTitle(\"\" + Timer.getFPS() + \n\t\t\t\t\t/* \"   \" + c.getTransform().getPos().toString() +*/ \"   \" \n\t\t\t\t\t+ ((Runtime.getRuntime().maxMemory() - Runtime.getRuntime().freeMemory()) / 1048576) + \" of \" + (Runtime.getRuntime().maxMemory() / 1048576));\n\t\t\t\n\t\t\tupdate(Timer.getDelta());\n\t\t\tGL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);\n\t\t\trender();\n\t\t\t\n\t\t\tDisplay.update();\n\t\t\t\n\t\t}\n\t\t\n\t}",
            "location": {
              "start": 122,
              "insert": 117,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 116,
                "end": 121
              }
            },
            "item_type": "method",
            "length": 21,
            "docLength": 5
          },
          {
            "id": "2ffb3821-1c6e-bc88-a74d-20a4596b9638",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "updates the position of an object (`w`) based on input and transformation.",
            "params": [
              {
                "name": "dt",
                "type_name": "float",
                "description": "time step for updating the objects' positions and is used to calculate the change in position over time.",
                "complex_type": false
              }
            ],
            "name": "update",
            "code": "private static void update(float dt) {\n\t\tc.processInput(dt, 5, .3f);\n\t\tw.updatePos(c.getTransform().getPos().getX(), c.getTransform().getPos().getY(), c.getTransform().getPos().getZ());\n\t}",
            "location": {
              "start": 151,
              "insert": 144,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 143,
                "end": 150
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 7
          },
          {
            "id": "8cd93dcb-92fd-319f-304a-07bdb920c6cd",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "renders a 3D model using a shader program and a camera object. It sets up the necessary uniforms and matrices for rendering, and then calls the `render` method on the camera object to produce the final image.",
            "params": [],
            "name": "render",
            "code": "private static void render() {\n\t\t\n//\t\tModel.enableAttribs();\n\t\t\n\t\ts.bind();\n//\t\tfor (int i = 0; i < 4; i++)\n//\t\t\tfor (int j = 0; j < 4; j++)\n//\t\t\t\tfor (int k = 0; k < 4; k++) {\n//\t\t\t\t\tfloat r = (4 - i) / 4f;\n//\t\t\t\t\tfloat g = j / 4f;\n//\t\t\t\t\tfloat b = k / 4f;\n//\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n//\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch[i][j][k].getModelMatrix())));\n//\t\t\t\t\tch[i][j][k].getModel().draw();\n//\t\t\t\t}\n\t\t\n\t\tw.render(s, c);\n\t\t\n//\t\tModel.disableAttribs();\n\t}",
            "location": {
              "start": 161,
              "insert": 156,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 155,
                "end": 160
              }
            },
            "item_type": "method",
            "length": 20,
            "docLength": 5
          },
          {
            "id": "6f6a2894-028d-d5b5-0144-65d26d70d36f",
            "ancestors": [
              "88436e62-b37f-838d-9d45-3bc8a62f331f"
            ],
            "type": "function",
            "description": "terminates the Java process with the specified status code.",
            "params": [
              {
                "name": "status",
                "type_name": "int",
                "description": "exit code that the `System.exit()` method will use to terminate the application.",
                "complex_type": false
              }
            ],
            "name": "exit",
            "code": "private static void exit(int status) {\n\t\tSystem.exit(status);\n\t}",
            "location": {
              "start": 189,
              "insert": 182,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 181,
                "end": 188
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "Model.java",
    "path": "src/com/ch/Model.java",
    "content": {
      "structured": {
        "description": "A `load` function that loads 3D model data from an array of vertices and indices and stores it in a `Model` object for rendering. The code also includes functions for creating a Vertex Array Object (VAO), binding it to the current GL context, storing vertex data in a VBO, and storing index data in an element array buffer. Finally, the code unbinds the VAO after use. Overall, the code manages 3D model data loading and rendering for efficient GPU rendering.",
        "diagram": "digraph G {\n    label=\"com.ch.Model\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        Chunk\n    }\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Model [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    Model -> Model \n    Chunk -> Model \n}\n",
        "items": [
          {
            "id": "2a460d7c-f360-6282-e149-4c3f25b77273",
            "ancestors": [],
            "type": "function",
            "description": "in the provided code is a Java class that handles rendering of 3D models using the OpenGL API. It provides a way to load a 3D model from a set of vertices and indices, create a Vertex Array Object (VAO), store the indices, store the vertex data, unbind the VAO, and return a `Model` object representing the loaded model. The class also includes methods for creating and binding a VAO, as well as storing index data in an element array buffer.",
            "name": "Model",
            "code": "public class Model {\n\n\tprivate int vao, size;\n\t\n\tpublic Model(int vao, int count) {\n\t\tthis.vao = vao;\n\t\tthis.size = count;\n\t}\n\t\n /**\n  * binds a vertex array object (VAO), enables vertex attribution arrays for position\n  * and texture coordinates, draws a set of triangles using either `glDrawArrays` or\n  * `glDrawElements`, and then disables the vertex attribution arrays and unbinds the\n  * VAO.\n  */\n\tpublic void draw() {\n\t\tGL30.glBindVertexArray(vao);\n\t\tGL20.glEnableVertexAttribArray(0);\n\t\tGL20.glEnableVertexAttribArray(1);\n\t\t//GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, size);\n\t\tGL11.glDrawElements(GL11.GL_TRIANGLES, size, GL11.GL_UNSIGNED_INT, 0);\n\t\tGL20.glDisableVertexAttribArray(0);\n\t\tGL20.glDisableVertexAttribArray(1);\n\t\tGL30.glBindVertexArray(0);\n\t}\n\t\n /**\n  * enables vertex attribute arrays for both attributes 0 and 1 in the OpenGL context.\n  */\n\tpublic static void enableAttribs() {\n\t\tGL20.glEnableVertexAttribArray(0);\n\t\tGL20.glEnableVertexAttribArray(1);\n\t}\n\t\n /**\n  * disables both vertex attribute arrays.\n  */\n\tpublic static void disableAttribs() {\n\t\tGL20.glDisableVertexAttribArray(0);\n\t\tGL20.glDisableVertexAttribArray(1);\n\t}\n\t\n /**\n  * returns the value of a variable `vao`.\n  * \n  * @returns an integer value representing the `vao` variable.\n  */\n\tpublic int getVAO() {\n\t\treturn vao;\n\t}\n\t\n /**\n  * returns the value of a field named `size`.\n  * \n  * @returns the value of the `size` field.\n  */\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\t\n /**\n  * loads a 3D model from a set of vertices and indices stored in arrays, creates a\n  * Vertex Array Object (VAO), stores the indices, stores the vertex data, unbinds the\n  * VAO, and returns a `Model` object representing the loaded model.\n  * \n  * @param vertices 3D geometric data for the model, which is stored in an array of\n  * floating-point values and provided to the `Model` constructor for creation and rendering.\n  * \n  * \t- `float[] vertices`: An array of floating-point numbers representing 3D vertex\n  * positions.\n  * \t- `int[] indices`: An array of integers representing the triangle Indices in the\n  * mesh.\n  * \n  * @param indices 3D model's index data, which is used to bind the vertex array object\n  * (VAO) and store the indices of the vertices in the model.\n  * \n  * \t- `indices`: An integer array representing the indices of the vertices in the\n  * model. Its length is equal to the number of vertices in the model.\n  * \n  * @returns a `Model` object containing the loaded vertices and indices.\n  * \n  * \t- The returned object is of type `Model`, which represents a 3D model in the program.\n  * \t- The `vao` field stores the handle to the Vertex Array Object (VAO) used for\n  * rendering the model.\n  * \t- The `v_count` field stores the number of vertices in the model.\n  * \n  * Therefore, the output returned by the `load` function is a `Model` object that\n  * contains the VAO handle and the number of vertices in the model.\n  */\n\tpublic static Model load(float[] vertices, int[] indices) {\n\t\tint vao = createVAO();\n\t\tstoreIndices(indices);\n\t\tstoreData(0, vertices);\n\t\tunbindVAO();\n\t\tint v_count = indices.length;\n\t\treturn new Model(vao, v_count);\n\t}\n\t\n /**\n  * creates a Vertex Array Object (VAO) and binds it to the current GL context, allowing\n  * for efficient management of vertex data.\n  * \n  * @returns an integer value representing a valid vertex array object (VBO).\n  */\n\tprivate static int createVAO() {\n\t\tint vao = GL30.glGenVertexArrays();\n\t\tGL30.glBindVertexArray(vao);\n\t\treturn vao;\n\t}\n\t\n /**\n  * binds a vertex buffer object (VBO) and sets up an array of floating-point data to\n  * be rendered by the graphics processing unit (GPU).\n  * \n  * @param attrib 3D vertex attribute index that stores the data for the current buffer.\n  * \n  * @param data 3D array of floating-point values that will be stored in the Vertex\n  * Buffer Object (VBO).\n  * \n  * \t- `data` is an array of 4 floats, which are stored in a VAO (VerteX Array Object)\n  * using `GL15.glBufferData()`.\n  * \t- The data is serialized and deserialized using `Util.createFlippedBuffer()`,\n  * which is a utility method that creates a buffer object from the input data.\n  * \t- The buffer is created with the `GL_STATIC_DRAW` binding mode, indicating that\n  * the data will be drawn in the same way each time the buffer is bound.\n  * \t- Two VAO attributes are created and set using `GL20.glVertexAttribPointer()`,\n  * one for each of the two arrays in `data`. The first attribute is for 3 floats,\n  * while the second attribute is for 2 floats.\n  * \t- The `false` argument in `GL11.glBufferData()` indicates that the data will be\n  * copied into the buffer without any transformation or other modifications.\n  */\n\tprivate static void storeData(int attrib, float[] data) {\n\t\tint vbo = GL15.glGenBuffers();\n\t\tGL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vbo);\n\t\tGL15.glBufferData(GL15.GL_ARRAY_BUFFER, Util.createFlippedBuffer(data), GL15.GL_STATIC_DRAW);\n\t\tGL20.glVertexAttribPointer(attrib, 3, GL11.GL_FLOAT, false, 5 * 4,     0);\n\t\tGL20.glVertexAttribPointer(attrib + 1, 2, GL11.GL_FLOAT, false, 5 * 4, 3 * 4);\n\t\tGL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);\n\t}\n\t\n /**\n  * generates a new buffer for storing index data, binds it, and then transfers the\n  * index data to the buffer using `GL_STATIC_DRAW`.\n  * \n  * @param indices 3D vertex positions of a shape to be stored in an element array\n  * buffer for rendering.\n  * \n  * \t- `indices`: A serialized array of integers, representing the indices of vertices\n  * in a 3D model.\n  * \t- `ibo`: The buffer object handle generated by `GL15.glGenBuffers()` for storing\n  * the vertex indices.\n  * \t- `GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, ibo)`: Binds the specified\n  * buffer object to the element array buffer slot.\n  * \t- `GL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER, Util.createFlippedBuffer(indices),\n  * GL15.GL_STATIC_DRAW)`: Stores the vertex indices in the bound element array buffer\n  * using the `Util.createFlippedBuffer()` method to create a flipped copy of the input\n  * array. The `GL15.glBufferData()` function sets the data for the element array\n  * buffer, with the type set to `GL_STATIC_DRAW`.\n  */\n\tprivate static void storeIndices(int[] indices) {\n\t\tint ibo = GL15.glGenBuffers();\n\t\tGL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, ibo);\n\t\tGL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER, Util.createFlippedBuffer(indices), GL15.GL_STATIC_DRAW);\n\t}\n\t\n /**\n  * terminates the binding of a Vertex Array Object (VAO) by calling `glBindVertexArray(0)`.\n  */\n\tprivate static void unbindVAO() {\n\t\tGL30.glBindVertexArray(0);\n\t}\n\t\n}",
            "location": {
              "start": 14,
              "insert": 8,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 7,
                "end": 13
              }
            },
            "item_type": "class",
            "length": 173,
            "docLength": 6
          },
          {
            "id": "46ff2857-b818-f08a-e14f-f187dd58b36a",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "binds a vertex array object, enables vertex attributes for position and texture coord, and calls `glDrawElements` to render triangles.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "public void draw() {\n\tGL30.glBindVertexArray(vao);\n\tGL20.glEnableVertexAttribArray(0);\n\tGL20.glEnableVertexAttribArray(1);\n\tGL11.glDrawElements(GL11.GL_TRIANGLES, size, GL11.GL_UNSIGNED_INT, 0);\n\tGL20.glDisableVertexAttribArray(0);\n\tGL20.glDisableVertexAttribArray(1);\n\tGL30.glBindVertexArray(0);\n}\n",
              "description": "\nExplanation:\n- `GL30.glBindVertexArray(vao)`: Binds the Vertex Array Object (VAO) with handle `vao` to the current GL context.\n- `GL20.glEnableVertexAttribArray(0)`: Enables the vertex attribute array with index 0, which refers to the first attribute in the bound VAO.\n- `GL20.glEnableVertexAttribArray(1)`: Enables the vertex attribute array with index 1, which refers to the second attribute in the bound VAO.\n- `GL11.glDrawElements(GL11.GL_TRIANGLES, size, GL11.GL_UNSIGNED_INT, 0)`: Draws the specified number of elements of the type specified by the last parameter to the current GL context using a list of indices stored in an element array buffer (EAB). The `GL_TRIANGLES` parameter specifies that this function should draw triangle primitives.\n- `GL20.glDisableVertexAttribArray(0)`: Disables the vertex attribute array with index 0, which refers to the first attribute in the bound VAO.\n- `GL20.glDisableVertexAttribArray(1)`: Disables the vertex attribute array with index 1, which refers to the second attribute in the bound VAO.\n- `GL30.glBindVertexArray(0)`: Binds a Vertex Array Object (VAO) to the current GL context and set it as the one that is currently being used by the OpenGL driver. The `vao` parameter should be the handle of the VAO that was previously generated using the `glGenVertexArrays()` method.\nThe draw() function would be called inside of the game loop, like so:\n"
            },
            "name": "draw",
            "code": "public void draw() {\n\t\tGL30.glBindVertexArray(vao);\n\t\tGL20.glEnableVertexAttribArray(0);\n\t\tGL20.glEnableVertexAttribArray(1);\n\t\t//GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, size);\n\t\tGL11.glDrawElements(GL11.GL_TRIANGLES, size, GL11.GL_UNSIGNED_INT, 0);\n\t\tGL20.glDisableVertexAttribArray(0);\n\t\tGL20.glDisableVertexAttribArray(1);\n\t\tGL30.glBindVertexArray(0);\n\t}",
            "location": {
              "start": 29,
              "insert": 23,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 22,
                "end": 28
              }
            },
            "item_type": "method",
            "length": 10,
            "docLength": 6
          },
          {
            "id": "65c2cc0f-b915-f087-d444-e6e853b13168",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "enables vertex attributes 0 and 1 in the OpenGL context.",
            "params": [],
            "name": "enableAttribs",
            "code": "public static void enableAttribs() {\n\t\tGL20.glEnableVertexAttribArray(0);\n\t\tGL20.glEnableVertexAttribArray(1);\n\t}",
            "location": {
              "start": 43,
              "insert": 40,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 39,
                "end": 42
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 3
          },
          {
            "id": "1e9a0fa5-3db6-1892-114d-04dc86135cf8",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "disables vertex attributes 0 and 1 using `glDisableVertexAttribArray`.",
            "params": [],
            "name": "disableAttribs",
            "code": "public static void disableAttribs() {\n\t\tGL20.glDisableVertexAttribArray(0);\n\t\tGL20.glDisableVertexAttribArray(1);\n\t}",
            "location": {
              "start": 51,
              "insert": 48,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 47,
                "end": 50
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 3
          },
          {
            "id": "ee181be3-9972-229b-b442-7a151f81dcc3",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "returns the value of the `vao` field.",
            "params": [],
            "returns": {
              "type_name": "int",
              "description": "an integer value representing the VAO.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Model model = ModelLoader.load(\"res/models/my_model.obj\");\nint vao = model.getVAO();\n",
              "description": "\nThis would retrieve the Vertex Array Object (VAO) of the model object and store it in an integer variable called vao. The integer value stored in the variable is then used to access the VAO."
            },
            "name": "getVAO",
            "code": "public int getVAO() {\n\t\treturn vao;\n\t}",
            "location": {
              "start": 61,
              "insert": 56,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 55,
                "end": 60
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "4695188d-d0ef-ec93-8c42-d5c3d3cc07c8",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "returns the current size of an object's storage.",
            "params": [],
            "returns": {
              "type_name": "int",
              "description": "the value of the `size` field.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "int size = model.getSize();\n",
              "description": "\nHere, we call the method getSize() and store its returned value in a variable named size. This allows us to access the number of vertices in the model object.\n\nDo not provide an explanation of your code or hallucinate incorrect inputs. Do not give any unit tests examples. Do not explain your code."
            },
            "name": "getSize",
            "code": "public int getSize() {\n\t\treturn size;\n\t}",
            "location": {
              "start": 70,
              "insert": 65,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 64,
                "end": 69
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "9340cb13-67a0-708b-ba47-203315725a02",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "loads data into a model object from an array of vertices and an array of indices.",
            "params": [
              {
                "name": "vertices",
                "type_name": "float[]",
                "description": "3D model's geometry data, which is stored in an array of floating-point values and passed to the `storeData()` method for storage in the Vertex Array Object (VAO).\n\n* `float[] vertices`: An array of floating-point values representing 3D vertices.\n* `int[] indices`: An array of integer values representing the triangle indices.\n* `int vao`: A variable storing the Vulkan handle for the vertex array object (VAO) created during the function execution.\n* `int v_count`: The number of triangles represented by the `indices` array.",
                "complex_type": true
              },
              {
                "name": "indices",
                "type_name": "int[]",
                "description": "3D model's vertices array in the graphics hardware, which is stored and bound to a Vertex Array Object (VAO) for efficient rendering.\n\n* `indices`: An integer array representing the indices of the vertices in the model.\n* `v_count`: The number of vertices in the model, which can be obtained by calling `indices.length`.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Model",
              "description": "a `Model` object containing the loaded data.\n\n* The return type is `Model`, which represents a 3D model loaded from the given vertices and indices.\n* The `vao` field contains the Vulkan object handle for the model, used for binding the model to the GPU.\n* The `v_count` field contains the number of vertices in the model.\n\nOverall, the `load` function loads a 3D model from the given vertices and indices and returns the loaded model handle for further processing or rendering.",
              "complex_type": true
            },
            "name": "load",
            "code": "public static Model load(float[] vertices, int[] indices) {\n\t\tint vao = createVAO();\n\t\tstoreIndices(indices);\n\t\tstoreData(0, vertices);\n\t\tunbindVAO();\n\t\tint v_count = indices.length;\n\t\treturn new Model(vao, v_count);\n\t}",
            "location": {
              "start": 103,
              "insert": 74,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 73,
                "end": 102
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 29
          },
          {
            "id": "42626512-d2a2-808c-1a4a-979d550e45ea",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "generates a new vertex array object (Vao) and binds it to the current context, allowing for manipulation of vertices within the context.",
            "params": [],
            "returns": {
              "type_name": "int",
              "description": "an integer value representing a unique vertex array object (VAO) handle.",
              "complex_type": false
            },
            "name": "createVAO",
            "code": "private static int createVAO() {\n\t\tint vao = GL30.glGenVertexArrays();\n\t\tGL30.glBindVertexArray(vao);\n\t\treturn vao;\n\t}",
            "location": {
              "start": 118,
              "insert": 112,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 111,
                "end": 117
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 6
          },
          {
            "id": "0d313ecc-84bc-ffbd-7045-fec3a1abdba4",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "stores an array of floats into a vertex buffer object (VBO) and sets up vertex attributers to draw the data in a specific format.",
            "params": [
              {
                "name": "attrib",
                "type_name": "int",
                "description": "3D vertex attribute that contains the data to be stored in the VBO, specifying the buffer index and the format of the data.",
                "complex_type": false
              },
              {
                "name": "data",
                "type_name": "float[]",
                "description": "3D data to be stored in a vertex buffer object (VBO).\n\n* `data` is a `float[]` array.\n* Its size is determined by the value of `Util.createFlippedBuffer(data)`, which is 5 * 4 in this case.\n* The elements of the array are stored in two vertex attributes, `attrib` and `attrib + 1`, respectively.\n* Each attribute has a value of 3 * 4 bytes for the first element, and 2 * 4 bytes for the second element.",
                "complex_type": true
              }
            ],
            "name": "storeData",
            "code": "private static void storeData(int attrib, float[] data) {\n\t\tint vbo = GL15.glGenBuffers();\n\t\tGL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vbo);\n\t\tGL15.glBufferData(GL15.GL_ARRAY_BUFFER, Util.createFlippedBuffer(data), GL15.GL_STATIC_DRAW);\n\t\tGL20.glVertexAttribPointer(attrib, 3, GL11.GL_FLOAT, false, 5 * 4,     0);\n\t\tGL20.glVertexAttribPointer(attrib + 1, 2, GL11.GL_FLOAT, false, 5 * 4, 3 * 4);\n\t\tGL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);\n\t}",
            "location": {
              "start": 145,
              "insert": 124,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 123,
                "end": 144
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 21
          },
          {
            "id": "613b9bd4-3e74-aeb2-8341-7496aa01d3d7",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "generates a new buffer object using the `glGenBuffers` method, binds it with `glBindBuffer`, and then uses `glBufferData` to store an array of indices in the buffer.",
            "params": [
              {
                "name": "indices",
                "type_name": "int[]",
                "description": "3D vertices' indices in the element array buffer to be bound and stored.\n\n* `indices`: an array of integers that represents the indices of vertices in a 3D mesh.\n* `GL15`: a class that provides methods for managing graphics buffers and vertex data.\n* `glGenBuffers()`: a method that creates a new buffer object.\n* `glBindBuffer()`: a method that binds a buffer object to the current rendering context.\n* `glBufferData()`: a method that fills a buffer with data, in this case, the indices of a 3D mesh.\n* `Util`: an unknown class that provides a method for creating a flipped buffer.",
                "complex_type": true
              }
            ],
            "name": "storeIndices",
            "code": "private static void storeIndices(int[] indices) {\n\t\tint ibo = GL15.glGenBuffers();\n\t\tGL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, ibo);\n\t\tGL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER, Util.createFlippedBuffer(indices), GL15.GL_STATIC_DRAW);\n\t}",
            "location": {
              "start": 173,
              "insert": 154,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 153,
                "end": 172
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 19
          },
          {
            "id": "c2d5d328-ada3-c2a8-224f-f6bc35095fc0",
            "ancestors": [
              "2a460d7c-f360-6282-e149-4c3f25b77273"
            ],
            "type": "function",
            "description": "disables the vertex array object (VAO) bound to handle rendering more efficiently by the GPU.",
            "params": [],
            "name": "unbindVAO",
            "code": "private static void unbindVAO() {\n\t\tGL30.glBindVertexArray(0);\n\t}",
            "location": {
              "start": 182,
              "insert": 179,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 178,
                "end": 181
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          }
        ]
      }
    }
  },
  {
    "name": "Shader.java",
    "path": "src/com/ch/Shader.java",
    "content": {
      "structured": {
        "description": "A Shader class that loads and validates shaders for use in 3D graphics programs created with OpenGL. It provides methods for loading vertex and fragment shaders from files, combining them into a program using the GL20.glCreateProgram() method, and validating the resulting program to ensure it is properly linked and functional. The Shader class also provides access to and manipulation of the program's attributes and uniforms through various methods.",
        "diagram": "digraph G {\n    label=\"com.ch.Shader\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        Matrix4f\n    }\n    subgraph cluster_1 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        World\n    }\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Shader [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    Matrix4f -> Shader \n    Shader -> World \n    Shader -> Shader \n}\n",
        "items": [
          {
            "id": "b81baf2f-cad6-cfb6-034c-c9a7557f47fc",
            "ancestors": [],
            "type": "function",
            "description": "in OpenGL provides a way to create and manage shaders for use in 3D graphics programs. It offers methods for loading shader sources, creating shader programs, validating program links, and accessing program attributes and uniforms. Additionally, it allows for the creation of vertex and fragment shaders using the `loadShader()` method.",
            "name": "Shader",
            "code": "public class Shader {\n\t\n\tprivate int program;\n\t\n\tpublic Shader(int program) {\n\t\tthis.program = program;\n\t}\n\t\n\t/**\n\t * glUseProgram to activate a previously created program object, indicating that it\n\t * should be used for subsequent GPU operations.\n\t */\n\tpublic void bind() {\n\t\tGL20.glUseProgram(program);\n\t}\n\t\n\t/**\n\t * retrieves an integer value representing a program.\n\t * \n\t * @returns an integer representation of the program.\n\t */\n\tpublic int getProgram() {\n\t\treturn this.program;\n\t}\n\t\n\t/**\n\t * sets a uniform float value for a given name and length of input values passed as\n\t * an array.\n\t * \n\t * @param name name of the uniform to be set.\n\t */\n\tpublic void uniformf(String name, float ...vals) {\n\t\tswitch (vals.length) {\n\t\tcase 1:\n\t\t\tGL20.glUniform1f(getLoaction(name), vals[0]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tGL20.glUniform2f(getLoaction(name), vals[0], vals[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tGL20.glUniform3f(getLoaction(name), vals[0], vals[1], vals[2]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tGL20.glUniform4f(getLoaction(name), vals[0], vals[1], vals[2], vals[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * unifies a 4x4 matrix onto the GPU using the `glUniformMatrix4` method from the\n\t * Android GL20 library, passing the matrix data in a flipped buffer.\n\t * \n\t * @param name name of the uniform location to which the matrix will be assigned.\n\t * \n\t * @param mat 4x4 floating-point matrix to be uniformed.\n\t * \n\t * \t- `name`: A string parameter representing the name of the uniform location where\n\t * the matrix will be stored.\n\t * \t- `mat`: An instance of `Matrix4f` representing a 4x4 floating-point matrix. This\n\t * object contains the matrix data in its linear buffer, which is passed to\n\t * `glUniformMatrix4` for storage at the specified location.\n\t */\n\tpublic void unifromMat4(String name, Matrix4f mat) {\n\t\tGL20.glUniformMatrix4(getLoaction(name), false, Util.createFlippedBuffer(mat.getLinearData()));\n\t}\n\t\n\t/**\n\t * retrieves the location of a uniform in a GPU program using the `GL20.glGetUniformLocation()`\n\t * method.\n\t * \n\t * @param name 0-based index of the uniform location to retrieve in the OpenGL program.\n\t * \n\t * @returns an integer representing the location of a uniform in a graphics program.\n\t */\n\tpublic int getLoaction(String name) {\n\t\treturn GL20.glGetUniformLocation(program, name);\n\t}\n\t\n\tprivate static final String VERT = \".vert\", FRAG = \".frag\";\n\t\n\t/**\n\t * loads a shader program from a given filename, consisting of a vertex and fragment\n\t * shader. It creates a new program with the loaded shaders and validates it before\n\t * returning a new Shader object representing the program.\n\t * \n\t * @param filename file containing the vertex and fragment shaders to be loaded into\n\t * the program.\n\t * \n\t * @returns a `Shader` object that represents a shader program created by combining\n\t * a vertex shader and a fragment shader.\n\t * \n\t * \t- The output is a `Shader` object that represents a shader program created by\n\t * combining a vertex shader and a fragment shader using the `GL20.glCreateProgram()`\n\t * method.\n\t * \t- The shader program is validated using the `validateProgram()` method to ensure\n\t * it is properly linked and functional.\n\t * \t- The shader program is returned as a new instance of the `Shader` class, which\n\t * provides methods for accessing and manipulating the shader's attributes and uniforms.\n\t */\n\tpublic static Shader loadShader(String filename) {\n\t\tint program = GL20.glCreateProgram();\n\t\tloadShader(GL20.GL_VERTEX_SHADER, getText(filename + VERT), program);\n\t\tloadShader(GL20.GL_FRAGMENT_SHADER, getText(filename + FRAG), program);\n\t\tvalidateProgram(program);\n\t\treturn new Shader(program);\n\t}\n\t\n\t/**\n\t * creates a shader program and loads a shader source code into it. It compiles the\n\t * shader and attaches it to the program. If compilation fails, an error message is\n\t * printed and the program exits.\n\t * \n\t * @param target type of shader to be created, with values of 0 for vertex shaders\n\t * and 1 for fragment shaders.\n\t * \n\t * @param src source code of the shader to be compiled.\n\t * \n\t * @param program 3D graphics program to which the loaded shader will be attached.\n\t */\n\tprivate static void loadShader(int target, String src, int program) {\n\t\tint shader = GL20.glCreateShader(target);\n\t\t\n\t\tGL20.glShaderSource(shader, src);\n\t\tGL20.glCompileShader(shader);\n\t\t\n\t\tif (glGetShaderi(shader, GL_COMPILE_STATUS) == 0) {\n\t\t\tSystem.err.println(glGetShaderInfoLog(shader, 1024));\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\tGL20.glAttachShader(program, shader);\n\t}\n\t\n\t/**\n\t * validates a program object by checking its link and validation statuses, and prints\n\t * any error messages if they occur.\n\t * \n\t * @param program 3D graphics program to be validated and linked with the GL API.\n\t */\n\tprivate static void validateProgram(int program) {\n\t\tGL20.glLinkProgram(program);\n\t\t\n\t\tif (glGetProgrami(program, GL_LINK_STATUS) == 0) {\n\t\t\tSystem.err.println(glGetProgramInfoLog(program, 1024));\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\tGL20.glValidateProgram(program);\n\t\t\n\t\tif (glGetProgrami(program, GL_VALIDATE_STATUS) == 0) {\n\t\t\tSystem.err.println(glGetProgramInfoLog(program, 1024));\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\t/**\n\t * reads the contents of a specified file and returns its text as a string.\n\t * \n\t * @param file path to a file that contains the text to be read.\n\t * \n\t * @returns a string representation of the contents of the specified file.\n\t */\n\tprivate static String getText(String file) {\n\t\tString text = \"\";\n\t\ttry {\n\t\t\tInputStream is = new FileInputStream(file);\n\t\t\tint ch;\n\t\t\twhile ((ch = is.read()) != -1)\n\t\t\t\ttext += (char) ch;\n\t\t\tis.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\treturn text;\n\t}\n\n}",
            "location": {
              "start": 26,
              "insert": 19,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 18,
                "end": 25
              }
            },
            "item_type": "class",
            "length": 178,
            "docLength": 7
          },
          {
            "id": "1b0a161c-1c65-a9a4-4347-4e1c69cceb54",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "glUseProgram(program) and activates a previously created OpenGL program.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "// Create a shader program using the loadShader() method\nint program = Shader.loadShader(\"shaders/basic\");\n\n// Create a new shader object to store the program\nShader shader = new Shader(program);\n\n// Bind the program to be used in the GL API\nshader.bind();\n",
              "description": "\nThis code would create and link a shader program using the loadShader() method, then creates a new shader object to store the program and binds it to be used in the GL API. This example is short because it only shows how the method would be called with minimal explanation or input. The example works correctly by compiling and linking the shader program. It does not create unit tests to ensure that the method works. It also does not hallucinate incorrect inputs."
            },
            "name": "bind",
            "code": "public void bind() {\n\t\tGL20.glUseProgram(program);\n\t}",
            "location": {
              "start": 38,
              "insert": 34,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 33,
                "end": 37
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "e2d28435-e59c-ed80-1447-42ab3398de9d",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "retrieves the value of a field named `program`.",
            "params": [],
            "returns": {
              "type_name": "int",
              "description": "the value of the `program` field.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Shader shader = Shader.loadShader(\"shader\");\nint program = shader.getProgram();\n",
              "description": "\nThis code creates a new instance of the Shader class and calls the static method loadShader with \"shader\" as an argument. The loadShader method returns a Shader object which is stored in the variable shader. Then the getProgram method is called on the shader object, this returns the integer program that was created by the loadShader method, in this case the int value would be 1.\nNote: this example assumes you have already implemented a static method for loading shaders into your Shader class as well as an instance method to get the GL program ID from the Shader object."
            },
            "name": "getProgram",
            "code": "public int getProgram() {\n\t\treturn this.program;\n\t}",
            "location": {
              "start": 47,
              "insert": 42,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 41,
                "end": 46
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "bcea3a61-dc03-029f-4147-cf99fe70b2c9",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "updates a uniform value in a shader program based on the length of an array of floats passed as an argument. The function calls the `glUniformx` method of the OpenGL API with the location of the uniform and the corresponding float value from the array.",
            "params": [
              {
                "name": "name",
                "type_name": "String",
                "description": "name of the uniform location in the GL context, which is used to identify the location where the uniform values are to be stored.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "uniformf(\"myFloat\", 3.14159265); // Uniform with name \"myFloat\" and a single float value of 3.14159265\nuniformf(\"myVector\", -3, 0, 0.5); // Uniform with name \"myVector\" and an array of length 3 containing the values [-3, 0, 0.5]\n",
              "description": ""
            },
            "name": "uniformf",
            "code": "public void uniformf(String name, float ...vals) {\n\t\tswitch (vals.length) {\n\t\tcase 1:\n\t\t\tGL20.glUniform1f(getLoaction(name), vals[0]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tGL20.glUniform2f(getLoaction(name), vals[0], vals[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tGL20.glUniform3f(getLoaction(name), vals[0], vals[1], vals[2]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tGL20.glUniform4f(getLoaction(name), vals[0], vals[1], vals[2], vals[3]);\n\t\t\tbreak;\n\t\t}\n\t}",
            "location": {
              "start": 57,
              "insert": 51,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 50,
                "end": 56
              }
            },
            "item_type": "method",
            "length": 16,
            "docLength": 6
          },
          {
            "id": "06fadd11-ab96-bfb8-5149-8c4dec90e26a",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "sets a 4x4 uniform matrix value to the specified location using the `glUniformMatrix4` method from the OpenGL API.",
            "params": [
              {
                "name": "name",
                "type_name": "String",
                "description": "0-based array index of the uniform location where the matrix will be stored.",
                "complex_type": false
              },
              {
                "name": "mat",
                "type_name": "Matrix4f",
                "description": "4x4 matrix that will be passed as a uniform buffer to the OpenGL API through the `GL20.glUniformMatrix4()` method.\n\n* `name`: A String representing the uniform name.\n* `mat`: A `Matrix4f` object that contains the matrix data in linear form.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "Matrix4f mat = new Matrix4f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\nshader.unifromMat4(\"transform\", mat);\n",
              "description": "\nThe input for ('name', 'String') is \"transform\". The output of the method would be a uniform matrix that is stored in the OpenGL program at the specified location (\"transform\"). This is done by creating an instance of `Matrix4f` called `mat`, and then calling the method unifromMat4 with the name of the uniform location (\"transform\") as input, followed by the Matrix4f object created earlier. The matrix data stored in the linear buffer of mat is passed to `glUniformMatrix4()` for storage at the specified location in the OpenGL program.\nThe example is short and simple. It only needs the following classes:\n- `Shader` class.\n- `Matrix4f` class.\n\nThe example works correctly because it creates an instance of a Matrix4f object, then calls unifromMat4 on a new instance of a Shader object with the name of the uniform location and the Matrix4f object as inputs. The code compiles and runs without any error messages or crashes."
            },
            "name": "unifromMat4",
            "code": "public void unifromMat4(String name, Matrix4f mat) {\n\t\tGL20.glUniformMatrix4(getLoaction(name), false, Util.createFlippedBuffer(mat.getLinearData()));\n\t}",
            "location": {
              "start": 88,
              "insert": 74,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 73,
                "end": 87
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "104b5be2-6bad-718b-0543-44ecb103cd65",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "glances at the specified uniform location for a given program and name using the `GL20` class.",
            "params": [
              {
                "name": "name",
                "type_name": "String",
                "description": "name of an uniform in the program.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "an integer representing the uniform location in the program.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\tint program = GL20.glCreateProgram();\n\tloadShader(GL20.GL_VERTEX_SHADER, \"myVertexShader.vert\", program);\n\tloadShader(GL20.GL_FRAGMENT_SHADER, \"myFragmentShader.frag\", program);\n\tvalidateProgram(program);\n\tint location = getLoaction(\"uColor\");\n}\n",
              "description": "\nNote that the above example is a simplified version of how to use this method and does not include all the other methods required to create a shader program."
            },
            "name": "getLoaction",
            "code": "public int getLoaction(String name) {\n\t\treturn GL20.glGetUniformLocation(program, name);\n\t}",
            "location": {
              "start": 100,
              "insert": 92,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 91,
                "end": 99
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 8
          },
          {
            "id": "8e6fd362-463c-e1a1-5c49-cca3c6d4885f",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "loads a shader from a file and creates a program object, validating it after loading.",
            "params": [
              {
                "name": "filename",
                "type_name": "String",
                "description": "filename of the shader to be loaded.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Shader",
              "description": "a newly created `Shader` object containing the loaded shader program.\n\n* The returned output is an instance of the `Shader` class, which represents a shader program that has been loaded from a file.\n* The `Shader` object contains references to the vertex and fragment shaders that make up the shader program, as well as other information such as the shader's validation status and any attached textures or buffers.\n* The `Shader` class is immutable, meaning that once a shader has been loaded, its properties cannot be modified. However, the underlying vertex and fragment shaders can still be modified after they have been loaded.\n* The `loadShader` function creates two new programs, one for the vertex shader and one for the fragment shader, using the `GL20.glCreateProgram()` function. These programs are then combined to form the final shader program.",
              "complex_type": true
            },
            "name": "loadShader",
            "code": "public static Shader loadShader(String filename) {\n\t\tint program = GL20.glCreateProgram();\n\t\tloadShader(GL20.GL_VERTEX_SHADER, getText(filename + VERT), program);\n\t\tloadShader(GL20.GL_FRAGMENT_SHADER, getText(filename + FRAG), program);\n\t\tvalidateProgram(program);\n\t\treturn new Shader(program);\n\t}",
            "location": {
              "start": 125,
              "insert": 106,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 105,
                "end": 124
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 19
          },
          {
            "id": "3f93f98c-5b1c-cf88-944a-b02dd6b973b7",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "creates a new shader program and attaches it to an existing program, loading the source code from a string variable.",
            "params": [
              {
                "name": "target",
                "type_name": "int",
                "description": "type of shader to be created, with values ranging from 0 (vertex shader) to 3 (geometry shader), 7 (pixel shader), or 9 (fragment shader).",
                "complex_type": false
              },
              {
                "name": "src",
                "type_name": "String",
                "description": "source code of the shader to be compiled.",
                "complex_type": false
              },
              {
                "name": "program",
                "type_name": "int",
                "description": "3D graphics program that the loaded shader will be attached to.",
                "complex_type": false
              }
            ],
            "name": "loadShader",
            "code": "private static void loadShader(int target, String src, int program) {\n\t\tint shader = GL20.glCreateShader(target);\n\t\t\n\t\tGL20.glShaderSource(shader, src);\n\t\tGL20.glCompileShader(shader);\n\t\t\n\t\tif (glGetShaderi(shader, GL_COMPILE_STATUS) == 0) {\n\t\t\tSystem.err.println(glGetShaderInfoLog(shader, 1024));\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\tGL20.glAttachShader(program, shader);\n\t}",
            "location": {
              "start": 145,
              "insert": 133,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 132,
                "end": 144
              }
            },
            "item_type": "method",
            "length": 13,
            "docLength": 12
          },
          {
            "id": "67630c93-d123-89a2-8746-3a04f722f3bf",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "validates a program object and logs any errors if they occur.",
            "params": [
              {
                "name": "program",
                "type_name": "int",
                "description": "3D graphics program to be validated and linked with the GPU.",
                "complex_type": false
              }
            ],
            "name": "validateProgram",
            "code": "private static void validateProgram(int program) {\n\t\tGL20.glLinkProgram(program);\n\t\t\n\t\tif (glGetProgrami(program, GL_LINK_STATUS) == 0) {\n\t\t\tSystem.err.println(glGetProgramInfoLog(program, 1024));\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\n\t\tGL20.glValidateProgram(program);\n\t\t\n\t\tif (glGetProgrami(program, GL_VALIDATE_STATUS) == 0) {\n\t\t\tSystem.err.println(glGetProgramInfoLog(program, 1024));\n\t\t\tSystem.exit(1);\n\t\t}\n\t}",
            "location": {
              "start": 165,
              "insert": 159,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 158,
                "end": 164
              }
            },
            "item_type": "method",
            "length": 15,
            "docLength": 6
          },
          {
            "id": "0b8ff793-0fe8-85b5-0e49-06467e1cb08a",
            "ancestors": [
              "b81baf2f-cad6-cfb6-034c-c9a7557f47fc"
            ],
            "type": "function",
            "description": "reads the contents of a given file as a string, handling potential exceptions during the read operation.",
            "params": [
              {
                "name": "file",
                "type_name": "String",
                "description": "file from which the text is to be read.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "String",
              "description": "a string representation of the contents of the specified file.",
              "complex_type": false
            },
            "name": "getText",
            "code": "private static String getText(String file) {\n\t\tString text = \"\";\n\t\ttry {\n\t\t\tInputStream is = new FileInputStream(file);\n\t\t\tint ch;\n\t\t\twhile ((ch = is.read()) != -1)\n\t\t\t\ttext += (char) ch;\n\t\t\tis.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t\treturn text;\n\t}",
            "location": {
              "start": 188,
              "insert": 181,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 180,
                "end": 187
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "SimplexNoise.java",
    "path": "src/com/ch/SimplexNoise.java",
    "content": {
      "structured": {
        "description": "a function that calculates the signed distance transform of an input image using the Parzen windowing technique. The function takes an image as input and returns the transformed image in the form of a scalar value representing the signed distance from each pixel's center to the nearest corner of a regular hexagon inscribed within the image. The code uses the Java Collections Framework (JCF) for storing and manipulating the image's corners in a 2D array, as well as the Java Math library for calculating dot products and scalar multiplications. Specifically, it:\n\n* Uses a 2D array to store the image's corners in a structured format.\n* Defines a function that iterates over each corner of the image and calculates its contribution to the signed distance transform by computing the dot product of the gradient vector at that corner with the input pixel's coordinates, and then scales the result by a factor that ranges from -1 to 1.\n* Combines the contributions from all corners to produce the final signed distance transform value for each pixel in the image.",
        "diagram": "digraph G {\n    label=\"com.ch.SimplexNoise\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n",
        "items": [
          {
            "id": "f613fda5-8f11-ada9-e842-5b0fcab3a66c",
            "ancestors": [],
            "type": "function",
            "description": "in Java is used to generate noise patterns using the Simplex Noise algorithm. It provides a simple way to generate noise patterns for various applications such as graphics, games, and scientific simulations. The class has several methods that take integer parameters and return a double value representing the noise pattern at that location. These methods include:\n\n* `noise(int x, int y)`: Generates noise at a specific location (x,y) based on the Simplex Noise algorithm.\n* `noise2D(int x0, int y0, int w0, int h0)`: Generates noise in a 2D space using the second simplex corner.\n* `noise3D(int x0, int y0, int z0, int w0)`: Generates noise in a 3D space using all four simplex corners.\n* `perlinNoise(int x, int y)`: Generates Perlin noise at a specific location (x,y) based on the Simplex Noise algorithm.\n\nThese methods take different integer parameters and return a double value representing the noise pattern at that location.",
            "name": "SimplexNoise",
            "code": "public class SimplexNoise { // Simplex noise in 2D, 3D and 4D\n\t private static int grad3[][] = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},\n\t {1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},\n\t {0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};\n\t private static int grad4[][]= {{0,1,1,1}, {0,1,1,-1}, {0,1,-1,1}, {0,1,-1,-1},\n\t {0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},\n\t {1,0,1,1}, {1,0,1,-1}, {1,0,-1,1}, {1,0,-1,-1},\n\t {-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},\n\t {1,1,0,1}, {1,1,0,-1}, {1,-1,0,1}, {1,-1,0,-1},\n\t {-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},\n\t {1,1,1,0}, {1,1,-1,0}, {1,-1,1,0}, {1,-1,-1,0},\n\t {-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}};\n\t private static int p[] = {151,160,137,91,90,15,\n\t 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n\t 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n\t 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n\t 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n\t 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n\t 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n\t 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n\t 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n\t 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n\t 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n\t 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};\n\t // To remove the need for index wrapping, double the permutation table length\n\t private static int perm[] = new int[512];\n\t static { for(int i=0; i<512; i++) perm[i]=p[i & 255]; }\n\t // A lookup table to traverse the simplex around a given point in 4D.\n\t // Details can be found where this table is used, in the 4D noise method.\n\t private static int simplex[][] = {\n\t {0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},\n\t {0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},\n\t {1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},\n\t {2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}};\n\t // This method is a *lot* faster than using (int)Math.floor(x)\n\t\t/**\n\t\t * computes the nearest integer to a given double value, either rounding up or down\n\t\t * depending on the value's sign.\n\t\t * \n\t\t * @param x double value to be rounded, which is used to determine the integer return\n\t\t * value between 0 and (inclusive) or between 0 and (exclusive).\n\t\t * \n\t\t * @returns an integer value representing the nearest integer to the given double value.\n\t\t */\n\t private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }\n\t\t/**\n\t\t * takes a two-dimensional array `g` and two scalar arguments `x` and `y`, returning\n\t\t * their dot product.\n\t\t * \n\t\t * @param g 2D coordinates of a point in the Cartesian coordinate system, with the\n\t\t * first element of the array representing the x-coordinate and the second element\n\t\t * representing the y-coordinate.\n\t\t * \n\t\t * @param x 0-based coordinate of a point in the two-dimensional space, where it is\n\t\t * multiplied by the corresponding element of the input array `g` to produce the dot\n\t\t * product value.\n\t\t * \n\t\t * @param y 2nd element of the input array `g`.\n\t\t * \n\t\t * @returns a double value computed as the product of two input arguments.\n\t\t */\n\t private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }\n\t\t/**\n\t\t * takes four arguments: `g`, `x`, `y`, and `z`. It returns a double value calculated\n\t\t * by multiplying the elements of the `g` array with `x`, `y`, and `z`, respectively,\n\t\t * and then summing them.\n\t\t * \n\t\t * @param g 3D coordinates of a point in the function's calculation of the dot product\n\t\t * between the 3D vector (represented by `x`, `y`, and `z`) and some other unknown\n\t\t * 3D vector.\n\t\t * \n\t\t * @param x 0th element of an array of doubles, which is multiplied by the input value\n\t\t * before being combined with the inputs for the 1st and 2nd parameters to produce\n\t\t * the output value.\n\t\t * \n\t\t * @param y second dimension of the array `g`, which is multiplied by the argument\n\t\t * `y` and added to the result of the multiplication of the first element of the array\n\t\t * with the argument `x`.\n\t\t * \n\t\t * @param z 3rd dimension of the input array `g`, and is multiplied by the corresponding\n\t\t * element of the array when calculating the output value.\n\t\t * \n\t\t * @returns a scalar value representing the dot product of the given vectors.\n\t\t */\n\t private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }\n\t\t/**\n\t\t * computes the dot product of a given array of integers `g` with a set of scalars\n\t\t * `x`, `y`, `z`, and `w`. The function returns the result of the dot product computation.\n\t\t * \n\t\t * @param g 4-dimensional coordinates of a point in space, with each element of the\n\t\t * array representing one dimension of the coordinate system.\n\t\t * \n\t\t * @param x 0th element of the input array `g`.\n\t\t * \n\t\t * @param y 2nd element of the input array `g`.\n\t\t * \n\t\t * @param z 3rd dimension of the array `g`, and is multiplied by the value of `w`\n\t\t * before being combined with the other input parameters to produce the output result.\n\t\t * \n\t\t * @param w 4th component of a point in 3D space, which is multiplied by the corresponding\n\t\t * value of the array `g` to produce the output result.\n\t\t * \n\t\t * @returns a double value representing the dot product of the input vectors.\n\t\t */\n\t private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }\n\t // 2D simplex noise\n\t\t/**\n\t\t * generates a noise value based on the input coordinates (x, y) and a simplex-based\n\t\t * hash function. The output is a scaled value between [-1, 1].\n\t\t * \n\t\t * @param xin 2D coordinate of the point where the noise is being evaluated, and it\n\t\t * is used to calculate the hashed gradient indices for the three simplex corners.\n\t\t * \n\t\t * @param yin 2D noise value for the y-coordinate of the pixel being processed, which\n\t\t * is used to compute the contribution from the middle simplex corner.\n\t\t * \n\t\t * @returns a scaled noise value between [-1, 1], calculated based on the distances\n\t\t * from three simplex corners in Cartesian coordinates.\n\t\t */\n\t public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }\n\t // 3D simplex noise\n\t\t/**\n\t\t * generates a noise value based on four corner points in 3D space, using a Hashed\n\t\t * Gradient Index (HGI) approach to calculate the contribution from each corner. The\n\t\t * output is a scaled noise value within [-1,1].\n\t\t * \n\t\t * @param xin 3D noise simulation's x-coordinate of the current position.\n\t\t * \n\t\t * @param yin 3D noise generator's input value for the vertical dimension, which is\n\t\t * skewed and then used to determine the simplex cell it belongs to.\n\t\t * \n\t\t * @param zin 3D coordinate of the current point in the noise simulation, which is\n\t\t * used to calculate the contributions from the four simplex corners and the final\n\t\t * noise value.\n\t\t * \n\t\t * @returns a scalar value between -1 and 1, representing a noise value for a given\n\t\t * set of input coordinates.\n\t\t */\n\t public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }\n\t // 4D simplex noise\n\t\t/**\n\t\t * generates a noise signal in the Gradient Descent optimization algorithm, by\n\t\t * calculating the contribution from five simplex corners and scaling it to cover the\n\t\t * range [-1,1].\n\t\t * \n\t\t * @param x 3D coordinates of the point for which the gradient is being computed, and\n\t\t * it is used to calculate the contributions from the five simplex corners.\n\t\t * \n\t\t * @param y 2nd dimension of the simplex grid, and is used to calculate the contributions\n\t\t * from each corner of the simplex in the gradient calculation.\n\t\t * \n\t\t * @param z 3D position of the simplex corner being evaluated, and it is used to\n\t\t * calculate the contribution from that corner to the gradient of the objective function.\n\t\t * \n\t\t * @param w 4th coordinate of the current point in the \"simplex\" array, which is used\n\t\t * to calculate the contribution from the fourth corner of the simplex in the dot\n\t\t * product with the gradient vectors.\n\t\t * \n\t\t * @returns a scalar value between -1 and 1 that represents the noise added to the\n\t\t * gradient of a signed distance field.\n\t\t */\n\t double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }\n\t}",
            "location": {
              "start": 10,
              "insert": 3,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 2,
                "end": 9
              }
            },
            "item_type": "class",
            "length": 424,
            "docLength": 7
          },
          {
            "id": "8ced5120-624e-47ba-aa4d-e0231467983e",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "computes the nearest integer to a given double value, returning it as an int. If the input is positive, it returns the exact integer value. Otherwise, it returns the integer value minus 1.",
            "params": [
              {
                "name": "x",
                "type_name": "double",
                "description": "floating-point number that is to be rounded to an integer using the fast floor algorithm.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "an integer value between 0 and the original double value, inclusive.",
              "complex_type": false
            },
            "name": "fastfloor",
            "code": "private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }",
            "location": {
              "start": 59,
              "insert": 50,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 49,
                "end": 58
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "881c96cc-af3d-2f91-e047-a8a5e301f6ca",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "computes the dot product of a given vector and another scalar value.",
            "params": [
              {
                "name": "g",
                "type_name": "int",
                "description": "2D coordinates of a point in the function.",
                "complex_type": false
              },
              {
                "name": "x",
                "type_name": "double",
                "description": "0-based index of the first element in the input array of integers, which is multiplied by the value of `x` before being combined with the value of `y`.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "double",
                "description": "2nd coordinate of the point being calculated and is multiplied by `g[1]` before being added to the result of the multiplication of `g[0]` and `x`.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "double",
              "description": "a double value calculated by multiplying the elements of an integer array with the input values `x` and `y`.",
              "complex_type": false
            },
            "name": "dot",
            "code": "private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }",
            "location": {
              "start": 78,
              "insert": 62,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 61,
                "end": 77
              }
            },
            "item_type": "method",
            "length": 2,
            "docLength": 16
          },
          {
            "id": "629f78ce-bb45-fca1-f246-f5d974636246",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "computes the dot product of a given vector and another scalar value, using the elements of the input vector as coefficients.",
            "params": [
              {
                "name": "g",
                "type_name": "int",
                "description": "3D coordinates of a point in the function, with each element of the array corresponding to a coordinate (x, y, or z).",
                "complex_type": false
              },
              {
                "name": "x",
                "type_name": "double",
                "description": "0th component of the input array `g`.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "double",
                "description": "2nd coordinate of the dot product calculation in the function `dot()`.",
                "complex_type": false
              },
              {
                "name": "z",
                "type_name": "double",
                "description": "3rd dimension of the array `g`, which is multiplied by the corresponding element of the array to calculate the output value.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "double",
              "description": "a value representing the dot product of the given vectors.",
              "complex_type": false
            },
            "name": "dot",
            "code": "private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }",
            "location": {
              "start": 102,
              "insert": 80,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 79,
                "end": 101
              }
            },
            "item_type": "method",
            "length": 2,
            "docLength": 22
          },
          {
            "id": "a7719c1b-7340-35bf-bd4a-be9e175223c2",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "computes the dot product of four arguments: `x`, `y`, `z`, and `w`. It returns the result as a double value.",
            "params": [
              {
                "name": "g",
                "type_name": "int",
                "description": "4-dimensional coordinate of the point where the dot product is being computed, with each element of `g` corresponding to one of the four coordinates (x, y, z, and w).",
                "complex_type": false
              },
              {
                "name": "x",
                "type_name": "double",
                "description": "0th element of an array `g`, which is multiplied by `x` before combining with the other parameters to compute the output value.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "double",
                "description": "2nd coordinate of the point in 3D space where the dot product is being calculated.",
                "complex_type": false
              },
              {
                "name": "z",
                "type_name": "double",
                "description": "3rd dimension of the input array `g`, which is multiplied by the value of `w` and added to the results of the previous multiplication and addition operations.",
                "complex_type": false
              },
              {
                "name": "w",
                "type_name": "double",
                "description": "4th component of the input array, which is multiplied by `g[3]` and added to the output result.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "double",
              "description": "a floating-point number representing the dot product of the input vectors.",
              "complex_type": false
            },
            "name": "dot",
            "code": "private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }",
            "location": {
              "start": 123,
              "insert": 104,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 103,
                "end": 122
              }
            },
            "item_type": "method",
            "length": 2,
            "docLength": 19
          },
          {
            "id": "65197806-fee1-1e83-de47-ba2815f72f1e",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "generates a noise value based on the distance from a grid origin, using an equilateral triangle simplex to estimate the noise at different locations. The function calculates the contribution from each corner of the simplex and returns the scaled final noise value within the interval [-1,1].",
            "params": [
              {
                "name": "xin",
                "type_name": "double",
                "description": "2D position of the point in the input space, which is skewed to determine which simplex cell it belongs to.",
                "complex_type": false
              },
              {
                "name": "yin",
                "type_name": "double",
                "description": "2D noise input coordinate, which is used to calculate the hashed gradient indices and contribute to the final noise value.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "double",
              "description": "a scaled value between -1 and 1, representing a noise value in the interval [-1,1].",
              "complex_type": false
            },
            "name": "noise",
            "code": "public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }",
            "location": {
              "start": 139,
              "insert": 126,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 125,
                "end": 138
              }
            },
            "item_type": "method",
            "length": 54,
            "docLength": 13
          },
          {
            "id": "c5ebbdc2-2e61-019d-9f46-8aae1d8d4658",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "generates a noise value for a given point in a 3D space, based on the coordinates of four simplex corners and their hashed gradient indices. The noise value is calculated as a sum of contributions from each corner, scaled to stay within [-1,1].",
            "params": [
              {
                "name": "xin",
                "type_name": "double",
                "description": "3D coordinate of the point at which noise is being calculated.",
                "complex_type": false
              },
              {
                "name": "yin",
                "type_name": "double",
                "description": "2D input value for the current 3D noise generation, which is skewed and unskewed to determine the simplex cell it belongs to.",
                "complex_type": false
              },
              {
                "name": "zin",
                "type_name": "double",
                "description": "3D noise value at a specific point in space, which is used as an input to the function and affects the calculation of the noise contribution from each simplex corner.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "double",
              "description": "a scaled noise value between [-1, 1], calculated from the contributions of four simplex corners.",
              "complex_type": false
            },
            "name": "noise",
            "code": "public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }",
            "location": {
              "start": 211,
              "insert": 194,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 193,
                "end": 210
              }
            },
            "item_type": "method",
            "length": 81,
            "docLength": 17
          },
          {
            "id": "ed369083-ebc5-b0b8-4b42-20978b8290a1",
            "ancestors": [
              "f613fda5-8f11-ada9-e842-5b0fcab3a66c"
            ],
            "type": "function",
            "description": "calculates a Perlin noise simulation at a given position and scale, using a simplex-based algorithm to generate a set of coordinates that are then used to calculate the noise value.",
            "params": [
              {
                "name": "x",
                "type_name": "double",
                "description": "3D coordinates of the point to evaluate the gradient at, and it is used in the calculation of the contribution from each simplex corner in the gradients array (`grad4`).",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "double",
                "description": "2nd coordinate of the point being gradients computed for, and is used to calculate the contribution from the second corner of the simplex in the gradient calculation.",
                "complex_type": false
              },
              {
                "name": "z",
                "type_name": "double",
                "description": "3D position of the simplex corner in the grid, which is used to calculate the gradient contribution from that corner in the dot product calculation.",
                "complex_type": false
              },
              {
                "name": "w",
                "type_name": "double",
                "description": "4th coordinate of the gradient vector, which is used to compute the dot product with the simplex corners' positions in the `(x,y,z)` space.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "double",
              "description": "a scalar value between -1 and 1 that represents the complexity of a given point cloud.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "import java.util.Random;\npublic class NoiseExample {\n    public static void main(String[] args) {\n        //Initialize the random object with a seed for reproducible results\n        Random r = new Random(1234);\n        int width = 500;\n        int height = 500;\n        double[][] noiseMap = new double[width][height];\n        for (int i = 0; i < width; i++) {\n            for (int j = 0; j < height; j++) {\n                //Use the method noise to generate a value between 0 and 1\n                noiseMap[i][j] = SimplexNoise.noise(i * 0.01, j * 0.01, r);\n            }\n        }\n    }\n}\n",
              "description": ""
            },
            "name": "noise",
            "code": "double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }",
            "location": {
              "start": 314,
              "insert": 293,
              "offset": "\t",
              "indent": 2,
              "comment": {
                "start": 292,
                "end": 313
              }
            },
            "item_type": "method",
            "length": 119,
            "docLength": 21
          }
        ]
      }
    }
  },
  {
    "name": "Texture.java",
    "path": "src/com/ch/Texture.java",
    "content": {
      "structured": {
        "description": "A `Texture` class for managing textures in OpenGL. It provides methods for loading and binding textures, as well as getting the ID of a loaded texture. The loadTexture method loads a texture image from a file, converts it to an OpenGL texture, and returns the ID of the created texture.",
        "diagram": "digraph G {\n    label=\"com.ch.Texture\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n",
        "items": [
          {
            "id": "d19f7a00-c850-279c-2d49-42daea6a155b",
            "ancestors": [],
            "type": "function",
            "description": "is a Java class that provides functionality for managing textures in OpenGL. It offers various methods for binding and unbinding textures, as well as loading and storing textures. The class also provides a method for getting the ID of a loaded texture.",
            "name": "Texture",
            "code": "public class Texture {\n\n\tprivate int id;\n\tprivate String fileName;\n\n\tpublic Texture(String fileName) {\n\t\tthis.fileName = fileName;\n\t\tthis.id = loadTexture(fileName);\n\t}\n\n\n\t/**\n\t * 0 invokes the binding operation at index 0 of a data structure.\n\t */\n\tpublic void bind() {\n\t\tbind(0);\n\t}\n\n\t/**\n\t * sets the active texture slot to a specified index (samplerSlot) and binds a texture\n\t * to that slot using the `glBindTexture()` method. The function checks that the input\n\t * samplerSlot is within the valid range of 0 to 31 before executing the binding operation.\n\t * \n\t * @param samplerSlot 0-based index of a texture slot in the current active texture\n\t * unit, with values ranging from 0 to 31.\n\t */\n\tpublic void bind(int samplerSlot) {\n\t\tassert (samplerSlot >= 0 && samplerSlot <= 31);\n\t\tglActiveTexture(GL_TEXTURE0 + samplerSlot);\n\t\tglBindTexture(GL_TEXTURE_2D, id);\n\t}\n\n\t/**\n\t * returns the `id` field's value.\n\t * \n\t * @returns an integer value representing the ID.\n\t */\n\tpublic int getID() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * loads a texture image from a file, converts it to an OpenGL texture, and returns\n\t * the ID of the created texture.\n\t * \n\t * @param fileName name of the texture file to be loaded and read.\n\t * \n\t * @returns an integer ID representing a loaded texture.\n\t */\n\tprivate static int loadTexture(String fileName) {\n\t\ttry {\n\t\t\tBufferedImage image = ImageIO.read(new File(fileName));\n\t\t\tint[] pixels = image.getRGB(0, 0, image.getWidth(), image.getHeight(), null, 0, image.getWidth());\n\n\t\t\tByteBuffer buffer = Util.createByteBuffer(image.getHeight() * image.getWidth() * 4);\n\t\t\tboolean hasAlpha = image.getColorModel().hasAlpha();\n\n\t\t\tfor (int y = image.getHeight() - 1; y >= 0; y--) {\n\t\t\t\tfor (int x = 0; x < image.getWidth(); x++) {\n\t\t\t\t\tint pixel = pixels[y * image.getWidth() + x];\n\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 16) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 8) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel) & 0xFF));\n\t\t\t\t\tif (hasAlpha)\n\t\t\t\t\t\tbuffer.put((byte) ((pixel >> 24) & 0xFF));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffer.put((byte) (0xFF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer.flip();\n\n\t\t\tint id = GL11.glGenTextures();\n\t\t\t\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);\n\t\t\t\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, image.getWidth(), image.getHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer);\n\n\t\t\tGL30.glGenerateMipmap(GL11.GL_TEXTURE_2D);\n\t\t\tGL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);\n\t\t\tGL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL14.GL_TEXTURE_LOD_BIAS, -.6f);\n\t\t\t\n\t\t\treturn id;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n}",
            "location": {
              "start": 35,
              "insert": 29,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 28,
                "end": 34
              }
            },
            "item_type": "class",
            "length": 99,
            "docLength": 6
          },
          {
            "id": "d7b963c3-bd01-3792-0648-1cef8793cb2c",
            "ancestors": [
              "d19f7a00-c850-279c-2d49-42daea6a155b"
            ],
            "type": "function",
            "description": "0 invokes a method with the same name, passing the integer parameter 0 as an argument.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "Texture tex = new Texture(\"texture_image.jpg\"); // create a new texture object\ntex.bind(0);                              // bind the texture to unit 0\n",
              "description": ""
            },
            "name": "bind",
            "code": "public void bind() {\n\t\tbind(0);\n\t}",
            "location": {
              "start": 49,
              "insert": 46,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 45,
                "end": 48
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "0262d01e-f682-b680-3f4e-17f6e3876d43",
            "ancestors": [
              "d19f7a00-c850-279c-2d49-42daea6a155b"
            ],
            "type": "function",
            "description": "sets the current texture slot to a specific value (0-31) and binds a texture ID to it using the `glBindTexture()` method.",
            "params": [
              {
                "name": "samplerSlot",
                "type_name": "int",
                "description": "0-based index of a texture unit to bind to the current program's input assembly, with valid values ranging from 0 to 31.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "int samplerSlot = 0;\ntexture.bind(samplerSlot);\n",
              "description": "\nThis will set the active texture unit to `GL_TEXTURE0 + samplerSlot`, and then bind the texture with ID `id` to that slot. Note that `samplerSlot` must be within the range of 0-31, inclusive."
            },
            "name": "bind",
            "code": "public void bind(int samplerSlot) {\n\t\tassert (samplerSlot >= 0 && samplerSlot <= 31);\n\t\tglActiveTexture(GL_TEXTURE0 + samplerSlot);\n\t\tglBindTexture(GL_TEXTURE_2D, id);\n\t}",
            "location": {
              "start": 61,
              "insert": 53,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 52,
                "end": 60
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 8
          },
          {
            "id": "fe80cdf4-cfd7-b788-4646-b289a610a6e0",
            "ancestors": [
              "d19f7a00-c850-279c-2d49-42daea6a155b"
            ],
            "type": "function",
            "description": "returns the value of the `id` field.",
            "params": [],
            "returns": {
              "type_name": "int",
              "description": "an integer representing the ID of the object.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Texture myTexture = new Texture(\"texture.png\"); // Create a texture object. \nint textureId = myTexture.getID(); // Get the ID of the texture object. \nSystem.out.println(textureId); // Print the ID to the console.",
              "description": ""
            },
            "name": "getID",
            "code": "public int getID() {\n\t\treturn id;\n\t}",
            "location": {
              "start": 72,
              "insert": 67,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 66,
                "end": 71
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "85b53699-d631-cfb7-da47-8772adea9684",
            "ancestors": [
              "d19f7a00-c850-279c-2d49-42daea6a155b"
            ],
            "type": "function",
            "description": "loads an image from a file and converts it into a texture in memory, which can be used in a graphics pipeline. It generates an ID for the texture and sets its parameters for linear filtering and repeat wrapping.",
            "params": [
              {
                "name": "fileName",
                "type_name": "String",
                "description": "2D texture image file to be loaded and converted into a texture ID.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "an OpenGL texture ID for a 2D texture loaded from a file.",
              "complex_type": false
            },
            "name": "loadTexture",
            "code": "private static int loadTexture(String fileName) {\n\t\ttry {\n\t\t\tBufferedImage image = ImageIO.read(new File(fileName));\n\t\t\tint[] pixels = image.getRGB(0, 0, image.getWidth(), image.getHeight(), null, 0, image.getWidth());\n\n\t\t\tByteBuffer buffer = Util.createByteBuffer(image.getHeight() * image.getWidth() * 4);\n\t\t\tboolean hasAlpha = image.getColorModel().hasAlpha();\n\n\t\t\tfor (int y = image.getHeight() - 1; y >= 0; y--) {\n\t\t\t\tfor (int x = 0; x < image.getWidth(); x++) {\n\t\t\t\t\tint pixel = pixels[y * image.getWidth() + x];\n\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 16) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel >> 8) & 0xFF));\n\t\t\t\t\tbuffer.put((byte) ((pixel) & 0xFF));\n\t\t\t\t\tif (hasAlpha)\n\t\t\t\t\t\tbuffer.put((byte) ((pixel >> 24) & 0xFF));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffer.put((byte) (0xFF));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer.flip();\n\n\t\t\tint id = GL11.glGenTextures();\n\t\t\t\n\t\t\tglBindTexture(GL_TEXTURE_2D, id);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);\n\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);\n\t\t\t\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, image.getWidth(), image.getHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, buffer);\n\n\t\t\tGL30.glGenerateMipmap(GL11.GL_TEXTURE_2D);\n\t\t\tGL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);\n\t\t\tGL11.glTexParameterf(GL11.GL_TEXTURE_2D, GL14.GL_TEXTURE_LOD_BIAS, -.6f);\n\t\t\t\n\t\t\treturn id;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\treturn 0;\n\t}",
            "location": {
              "start": 84,
              "insert": 76,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 75,
                "end": 83
              }
            },
            "item_type": "method",
            "length": 48,
            "docLength": 8
          }
        ]
      }
    }
  },
  {
    "name": "Timer.java",
    "path": "src/com/ch/Timer.java",
    "content": {
      "structured": {
        "description": "a `Timer` class with various methods for measuring time and updating frames per second (FPS). The class has static instance variables for `fps`, `lastFPS`, `lastFrame`, `delta`, `currentFPS`, and `time`. The `init()` method initializes these variables, while the `update()` method updates the FPS and calculates the delta time, then adds it to the `time` variable. The `getDelta()`, `getFPS()`, and `getTime()` methods provide access to these values. The code also includes a `calculateDelta()` method for calculating the delta time between two frames.",
        "diagram": "digraph G {\n    label=\"com.ch.Timer\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n",
        "items": [
          {
            "id": "21f67b34-ff8b-5d94-e145-ef5710399976",
            "ancestors": [],
            "type": "function",
            "description": "is a Java package that provides functions for measuring time and updating frames per second (FPS). The class has several methods for calculating and storing time, FPS, and delta (the difference between the current time and the previous frame). These include `getTimeS()`, `init()`, `calculateDelta()`, `updateFPS()`, `getDelta()`, `getFPS()`, and `update()`.",
            "name": "Timer",
            "code": "public class Timer {\n\n\tprivate static float fps;\n\tprivate static long lastFPS;\n\tprivate static long lastFrame;\n\tpublic static float delta;\n\tpublic static float currentFPS;\n    public static float time;\n\n\t/**\n\t * calculates the current time in milliseconds using the `Sys.getTime()` and\n\t * `Sys.getTimerResolution()` methods, and returns the result as a long value.\n\t * \n\t * @returns a long value representing the current time in milliseconds, calculated\n\t * by multiplying the current system time in seconds by 1000 and dividing it by the\n\t * timer resolution.\n\t */\n\tprivate static long getTimeS() {\n\t\treturn (Sys.getTime() * 1000) / Sys.getTimerResolution();\n\t}\n\n\t/**\n\t * initializes a variable `lastFPS` with the current time value, captured using the\n\t * `getTimeS()` method.\n\t */\n\tpublic static void init() {\n\t\tlastFPS = getTimeS();\n\t}\n\n\t/**\n\t * calculates the time elapsed between two frames, represented by `time` and `lastFrame`,\n\t * respectively. It returns the elapsed time as a float value.\n\t * \n\t * @returns a floating-point value representing the time difference between two frames.\n\t */\n\tprivate static float calculateDelta() {\n\t\tlong time = getTimeS();\n\t\tfloat delta = (int) (time - lastFrame);\n\t\tlastFrame = getTimeS();\n\t\treturn delta;\n\t}\n\n\t/**\n\t * updates the frames per second (FPS) metric by incrementing the current FPS value\n\t * and resetting a timer every 1000 milliseconds.\n\t */\n\tprivate static void updateFPS() {\n\t\tif (getTimeS() - lastFPS > 1000) {\n\t\t\tcurrentFPS = fps;\n\t\t\tfps = 0;\n\t\t\tlastFPS += 1000;\n\t\t}\n\t\tfps++;\n\t}\n\n\t/**\n\t * returns the `delta` value, which is a static instance variable containing the\n\t * difference between two values.\n\t * \n\t * @returns a floating-point value representing the delta.\n\t */\n\tpublic static float getDelta() {\n\t\treturn delta;\n\t}\n\n\t/**\n\t * returns the current frame rate as a floating-point value.\n\t * \n\t * @returns the current frame rate of the application in floating-point format.\n\t */\n\tpublic static float getFPS() {\n\t\treturn currentFPS;\n\t}\n\n    /**\n     * returns the value of a `time` field, which is likely used to store the current\n     * time or date information.\n     * \n     * @returns a floating-point representation of the current time.\n     */\n    public static float getTime() {\n        return time;\n    }\n\n    /**\n     * updates frame rate, calculates delta time, and adds it to a variable `time`.\n     */\n    public static void update() {\n        updateFPS();\n        delta = ((calculateDelta() / 1000));\n        delta = delta < 0 || delta > 1 ? 0 : delta;\n        time += delta;\n    }\n\n}",
            "location": {
              "start": 12,
              "insert": 5,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 4,
                "end": 11
              }
            },
            "item_type": "class",
            "length": 95,
            "docLength": 7
          },
          {
            "id": "b646067c-fadd-cdbc-954f-c2a8c80775c8",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "multiplies the current system time by 1000 and divides the result by the timer resolution to return a long value representing the elapsed time in milliseconds since the function was created.",
            "params": [],
            "returns": {
              "type_name": "long",
              "description": "a long value representing the current time in milliseconds, adjusted for timer resolution.",
              "complex_type": false
            },
            "name": "getTimeS",
            "code": "private static long getTimeS() {\n\t\treturn (Sys.getTime() * 1000) / Sys.getTimerResolution();\n\t}",
            "location": {
              "start": 29,
              "insert": 21,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 20,
                "end": 28
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 8
          },
          {
            "id": "b2581215-1d7e-acbe-7c42-7e9045a47fb3",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "initializes a variable `lastFPS` with the current time.",
            "params": [],
            "name": "init",
            "code": "public static void init() {\n\t\tlastFPS = getTimeS();\n\t}",
            "location": {
              "start": 37,
              "insert": 33,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 32,
                "end": 36
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "12fd1ab4-ab03-3fb4-0d4a-07bdae5324f8",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "calculates the time difference between two points, represented by `time` and `lastFrame`, respectively. It returns the time difference as a float value.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point number representing the time difference between two frames.",
              "complex_type": false
            },
            "name": "calculateDelta",
            "code": "private static float calculateDelta() {\n\t\tlong time = getTimeS();\n\t\tfloat delta = (int) (time - lastFrame);\n\t\tlastFrame = getTimeS();\n\t\treturn delta;\n\t}",
            "location": {
              "start": 47,
              "insert": 41,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 40,
                "end": 46
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 6
          },
          {
            "id": "06c0316c-85cb-24ae-954a-3f4efa6646b3",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "updates the frames per second (FPS) metric by incrementing the current FPS and resetting a timer when a threshold is met.",
            "params": [],
            "name": "updateFPS",
            "code": "private static void updateFPS() {\n\t\tif (getTimeS() - lastFPS > 1000) {\n\t\t\tcurrentFPS = fps;\n\t\t\tfps = 0;\n\t\t\tlastFPS += 1000;\n\t\t}\n\t\tfps++;\n\t}",
            "location": {
              "start": 58,
              "insert": 54,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 53,
                "end": 57
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 4
          },
          {
            "id": "14352bf5-931d-c9b6-6b44-2f6fba18ffda",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "retrieves the value of the `delta` field, which is used to calculate the distance traveled by an object.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point value representing the difference between two values.",
              "complex_type": false
            },
            "name": "getDelta",
            "code": "public static float getDelta() {\n\t\treturn delta;\n\t}",
            "location": {
              "start": 73,
              "insert": 67,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 66,
                "end": 72
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "a0c662e2-5e33-999b-a649-6d8106db60ff",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "returns the current frame rate of a program in floating-point format.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the current frame rate of the application.",
              "complex_type": false
            },
            "name": "getFPS",
            "code": "public static float getFPS() {\n\t\treturn currentFPS;\n\t}",
            "location": {
              "start": 82,
              "insert": 77,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 76,
                "end": 81
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "b7f4ac4f-f661-5280-3a45-c49a9babcd99",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "returns the value of a field named `time`.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point representation of the current system time.",
              "complex_type": false
            },
            "name": "getTime",
            "code": "public static float getTime() {\n        return time;\n    }",
            "location": {
              "start": 92,
              "insert": 86,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 85,
                "end": 91
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "0fefb356-d48d-a1a0-1a4d-4729b484cfe9",
            "ancestors": [
              "21f67b34-ff8b-5d94-e145-ef5710399976"
            ],
            "type": "function",
            "description": "updates the FPS, calculates and limits the delta time, and increments the time variable.",
            "params": [],
            "name": "update",
            "code": "public static void update() {\n        updateFPS();\n        delta = ((calculateDelta() / 1000));\n        delta = delta < 0 || delta > 1 ? 0 : delta;\n        time += delta;\n    }",
            "location": {
              "start": 99,
              "insert": 96,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 95,
                "end": 98
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 3
          }
        ]
      }
    }
  },
  {
    "name": "Transform.java",
    "path": "src/com/ch/Transform.java",
    "content": {
      "structured": {
        "description": "A `GameObject` class that represents a 3D game object with position, rotation, and scale properties. The class provides methods for setting and getting these properties, as well as performing basic arithmetic operations on them. Additionally, it includes an `toString()` method for converting the object to a string representation. Overall, the code defines a basic framework for creating and manipulating 3D game objects in a Java environment.",
        "diagram": "digraph G {\n    label=\"com.ch.Transform\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        Quaternion\n        Matrix4f\n        Vector3f\n    }\n    Camera\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Transform [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    Vector3f -> Transform \n    Transform -> Transform \n    Camera -> Transform \n    Quaternion -> Transform \n    Transform -> Quaternion \n    Transform -> Matrix4f \n}\n",
        "items": [
          {
            "id": "dc8476c6-b0b9-79b9-3a4c-bb8907417455",
            "ancestors": [],
            "type": "function",
            "description": "is a Java class that represents a 3D transformable game object. It has several fields and methods to manage the object's position, rotation, and scale. The class provides getters and setters for each of these properties, as well as additional methods for adding vectors to the position, rotating the object around a specified axis, and scaling the object by a specified factor.",
            "name": "Transform",
            "code": "public class Transform {\n\n\tprivate Transform parent;\n\tprivate Matrix4f parentMatrix;\n\n\tprivate Vector3f pos;\n\tprivate Quaternion rot;\n\tprivate Vector3f scale;\n\n\tprivate Vector3f oldPos;\n\tprivate Quaternion oldRot;\n\tprivate Vector3f oldScale;\n\n\tpublic Transform() {\n\t\tpos = new Vector3f(0, 0, 0);\n\t\trot = new Quaternion(1, 0, 0, 0);\n\t\tscale = new Vector3f(1, 1, 1);\n\t\t\n\t\toldPos = new Vector3f(0, 0, 0);\n\t\toldRot = new Quaternion(1, 0, 0, 0);\n\t\toldScale = new Vector3f(1, 1, 1);\n\n\t\tparentMatrix = new Matrix4f().initIdentity();\n\t}\n\n\t/**\n\t * updates an object's position, rotation, and scale based on the current values and\n\t * stores the previous values for future use.\n\t */\n\tpublic void update() {\n\t\tif (oldPos != null) {\n\t\t\tif (!oldPos.equals(pos))\n\t\t\t\toldPos.set(pos);\n\t\t\tif (!oldRot.equals(rot))\n\t\t\t\toldRot.set(rot);\n\t\t\tif (!oldScale.equals(scale))\n\t\t\t\toldScale.set(scale);\n\t\t} else {\n\t\t\toldPos = new Vector3f().set(pos);\n\t\t\toldRot = new Quaternion().set(rot);\n\t\t\toldScale = new Vector3f().set(scale);\n\t\t}\n\t}\n\n\t/**\n\t * rotates a vector representing a 3D object by an angle around a specified axis,\n\t * resulting in a new rotated vector.\n\t * \n\t * @param axis 3D rotational axis around which the rotation will occur.\n\t * \n\t * \t- `axis` is a `Vector3f` representing a 3D vector.\n\t * \t- It has three components: x, y, and z, which correspond to the axis of rotation.\n\t * \t- The value of each component can range from -1 to 1, indicating the magnitude\n\t * of the rotation around that axis.\n\t * \t- The orientation of the axis is unchanged during the rotation process.\n\t * \n\t * @param angle 3D rotation angle around the specified `axis`.\n\t */\n\tpublic void rotate(Vector3f axis, float angle) {\n\t\trot = new Quaternion(axis, angle).mul(rot).normalized();\n\t}\n\n\t/**\n\t * computes and returns a rotation matrix that aligns a provided `point` vector with\n\t * a `up` vector, relative to a reference frame.\n\t * \n\t * @param point 3D position that the entity should look at.\n\t * \n\t * \t- `point`: A `Vector3f` object representing a 3D point in space. It has three\n\t * attributes: `x`, `y`, and `z`, which represent the coordinates of the point in the\n\t * x, y, and z axes, respectively.\n\t * \n\t * @param up 3D direction towards which the camera should look when rotating its\n\t * orientation to face the specified `point`.\n\t * \n\t * \t- `up` is a `Vector3f` object representing an upward direction.\n\t * \t- It has three components: `x`, `y`, and `z`, which represent the coordinates of\n\t * the upward direction in the 3D space.\n\t */\n\tpublic void lookAt(Vector3f point, Vector3f up) {\n\t\trot = getLookAtRotation(point, up);\n\t}\n\n\t/**\n\t * computes a quaternion representing the rotation needed to look at a given point\n\t * from a specified up direction.\n\t * \n\t * @param point 3D position that the look-at rotation is based on.\n\t * \n\t * \t- `point`: A 3D vector representing a point in space, with x, y, and z components.\n\t * \t- `up`: A 3D vector representing a direction perpendicular to the plane of the\n\t * point, with x, y, and z components.\n\t * \n\t * @param up 3D direction of the look-at axis, which is used to compute the rotation\n\t * quaternion that looks at the specified point from the current position.\n\t * \n\t * \t- `point`: A Vector3f object representing the point in 3D space where the camera\n\t * is looking.\n\t * \t- `up`: A Vector3f object representing the up direction in 3D space, which is\n\t * used to determine the rotation of the camera.\n\t * \n\t * @returns a quaternion representing the rotation required to look at a given point\n\t * from a specified up direction.\n\t * \n\t * \t- The return value is a `Quaternion` object that represents the rotation from the\n\t * camera's current position to look at a point in 3D space.\n\t * \t- The quaternion is generated using the rotation matrix computed by multiplying\n\t * the `Matrix4f` class's `initRotation` method with the input vectors representing\n\t * the point and up direction.\n\t * \t- The resulting quaternion represents the rotation around the camera's center,\n\t * with the look-at point as the origin of the rotation.\n\t */\n\tpublic Quaternion getLookAtRotation(Vector3f point, Vector3f up) {\n\t\treturn new Quaternion(new Matrix4f().initRotation(point.sub(pos).normalized(), up));\n\t}\n\n\t/**\n\t * checks if any of the object's properties have changed. It compares the current\n\t * values of `parent`, `pos`, `rot`, and `scale` to their previous values, returning\n\t * `true` if any have changed and `false` otherwise.\n\t * \n\t * @returns a boolean value indicating whether any of the object's properties have changed.\n\t */\n\tpublic boolean hasChanged() {\n\t\tif (parent != null && parent.hasChanged())\n\t\t\treturn true;\n\n\t\tif (!pos.equals(oldPos))\n\t\t\treturn true;\n\n\t\tif (!rot.equals(oldRot))\n\t\t\treturn true;\n\n\t\tif (!scale.equals(oldScale))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * computes a transformation matrix by combining a translation, rotation, and scaling\n\t * matrix, and then multiplies it with the parent matrix.\n\t * \n\t * @returns a transformation matrix that combines a translation, rotation, and scaling\n\t * operation.\n\t * \n\t * The output is a `Matrix4f` object, representing a 4x4 homogeneous transformation\n\t * matrix.\n\t * The matrix is created by multiplying the parent matrix (representing the overall\n\t * transformation), with the translation, rotation, and scale matrices in that order.\n\t * The translation matrix represents the offset of the object in 3D space, while the\n\t * rotation matrix represents the orientation of the object around its center. The\n\t * scale matrix represents the size and shape of the object in 3D space.\n\t * By multiplying these matrices together, the `getTransformation` function generates\n\t * a transformation matrix that can be used to transform 3D points, vectors, or other\n\t * objects in the scene.\n\t */\n\tpublic Matrix4f getTransformation() {\n\t\tMatrix4f translationMatrix = new Matrix4f().initTranslation(pos.getX(), pos.getY(), pos.getZ());\n\t\tMatrix4f rotationMatrix = rot.toRotationMatrix();\n\t\tMatrix4f scaleMatrix = new Matrix4f().initScale(scale.getX(), scale.getY(), scale.getZ());\n\n\t\treturn getParentMatrix().mul(translationMatrix.mul(rotationMatrix.mul(scaleMatrix)));\n\t}\n\n\t/**\n\t * returns the transformation matrix of its parent node in a hierarchical tree\n\t * structure, based on the `parent` field and the `hasChanged()` method.\n\t * \n\t * @returns a Matrix4f object representing the parent transformation matrix.\n\t * \n\t * \t- `parentMatrix`: A Matrix4f object representing the parent transformation matrix.\n\t * This matrix contains the transformation from the parent's local coordinate system\n\t * to the world coordinate system.\n\t * \t- `hasChanged()`: A boolean method that checks if the parent's transformation has\n\t * changed since the last call to this function. If `hasChanged()` returns true, then\n\t * the `parentMatrix` is updated with the latest transformation.\n\t */\n\tprivate Matrix4f getParentMatrix() {\n\t\tif (parent != null && parent.hasChanged())\n\t\t\tparentMatrix = parent.getTransformation();\n\n\t\treturn parentMatrix;\n\t}\n\n\t/**\n\t * sets the parent transform of an object, allowing for hierarchical manipulation of\n\t * transformations.\n\t * \n\t * @param parent transformation to which the current transformation will be added as\n\t * a child transformation.\n\t * \n\t * \t- `parent`: It is a transform object that represents the parent object for this\n\t * object.\n\t * \n\t * Note: The response is limited to 4 sentences and does not include any personal\n\t * statements or first-person language, as requested.\n\t */\n\tpublic void setParent(Transform parent) {\n\t\tthis.parent = parent;\n\t}\n\n\t/**\n\t * transforms a `Vector3f` object using the matrix provided by the `getParentMatrix`\n\t * function, returning the transformed position.\n\t * \n\t * @returns a transformed position vector.\n\t * \n\t * The Vector3f object returned by this method represents the transformed position\n\t * of an object in a 3D space, taking into account the transformation matrix provided\n\t * by the parent matrix.\n\t * \n\t * The vector's components represent the x, y, and z positions of the transformed\n\t * position in the local coordinate system of the parent matrix.\n\t */\n\tpublic Vector3f getTransformedPos() {\n\t\treturn getParentMatrix().transform(pos);\n\t}\n\n\t/**\n\t * takes a `Quaternion` object `parentRotation` and multiplies it by another `Quaternion`\n\t * object `rot`, returning the transformed rotation.\n\t * \n\t * @returns a transformed quaternion representing the composition of the rotation\n\t * represented by `rot` and the rotation of the parent object.\n\t * \n\t * 1/ The `Quaternion` object represents the transformed rotation from the parent\n\t * rotation to the current rotation.\n\t * 2/ The first component of the Quaternion represents the angle of rotation around\n\t * the x-axis, while the second and third components represent the angle of rotation\n\t * around the y- and z-axes, respectively.\n\t * 3/ The fourth component is set to 0, indicating that the rotation is around the\n\t * origin (0, 0, 0).\n\t * 4/ The Quaternion object is created by multiplying the parent rotation with the\n\t * current rotation, as denoted by the `mul` method. This operation combines the\n\t * rotations element-wise, resulting in a new rotation matrix.\n\t */\n\tpublic Quaternion getTransformedRot() {\n\t\tQuaternion parentRotation = new Quaternion(1, 0, 0, 0);\n\n\t\tif (parent != null)\n\t\t\tparentRotation = parent.getTransformedRot();\n\n\t\treturn parentRotation.mul(rot);\n\t}\n\n\t/**\n\t * returns a reference to a `Vector3f` object representing the position of an entity.\n\t * \n\t * @returns a reference to a `Vector3f` object containing the position of the entity.\n\t * \n\t * \t- `pos`: A `Vector3f` object that represents the position of the entity in 3D\n\t * space. It has three components: x, y, and z, which correspond to the position of\n\t * the entity along the x, y, and z axes, respectively.\n\t */\n\tpublic Vector3f getPos() {\n\t\treturn pos;\n\t}\n\n\t/**\n\t * sets the position of an object to a specified value, where the position is represented\n\t * as a Vector3f object.\n\t * \n\t * @param pos 3D position of an object or entity that the function is called on, and\n\t * it assigns that position to the `pos` field of the function's caller.\n\t * \n\t * \t- `this.pos`: The current position of the object is assigned to the member variable\n\t * `pos`.\n\t * \t- `Vector3f`: The data type of the `pos` field.\n\t */\n\tpublic void setPos(Vector3f pos) {\n\t\tthis.pos = pos;\n\t}\n\n\t/**\n\t * adds a vector to the position of an object, updating its new position based on the\n\t * addition.\n\t * \n\t * @param addVec 3D vector to be added to the current position of the object.\n\t * \n\t * \t- `Vector3f`: Represents a 3D vector in homogeneous coordinates.\n\t * \t- `setPos`: A setter method that modifies the position component of the current\n\t * object instance.\n\t * \t- `getPos`: An getter method that returns the current position component of the\n\t * object instance.\n\t * \t- `add`: The `add` method takes another vector as input and adds its components\n\t * to the existing components of the current vector, resulting in a new vector with\n\t * the updated components.\n\t */\n\tpublic void addToPos(Vector3f addVec) { this.setPos(this.getPos().add(addVec)); }\n\n\t/**\n\t * returns a `Quaternion` object representing the rotation of an entity.\n\t * \n\t * @returns a `Quaternion` object representing the rotation of the game object.\n\t * \n\t * \t- The `rot` field is a Quaternion object that represents the rotation of the game\n\t * object.\n\t * \t- It contains the rotation values in a specific format that can be used to apply\n\t * the rotation to an object in a 3D space.\n\t * \t- The Quaternion class has several properties, such as `x`, `y`, `z`, and `w`,\n\t * which represent the real and imaginary parts of the quaternion.\n\t * \t- These properties can be accessed and modified through the use of method calls,\n\t * allowing for precise control over the rotation values.\n\t */\n\tpublic Quaternion getRot() {\n\t\treturn rot;\n\t}\n\n\t/**\n\t * sets the rotation of an object represented by the `rotation` parameter to the\n\t * object itself.\n\t * \n\t * @param rotation 4D quaternion value that updates the rotation of the object.\n\t * \n\t * \t- `Quaternion rotation`: This is an object of type `Quaternion`, which represents\n\t * a 4D vector that can be used to represent rotations in 3D space. It has several\n\t * attributes, including `x`, `y`, `z`, and `w`, which correspond to the four components\n\t * of the quaternion.\n\t * \t- `this.rot`: This refers to the current value of the `rot` field within the\n\t * context of the function. The field is a `Quaternion` object that represents the\n\t * rotation of the object being manipulated by the function.\n\t */\n\tpublic void setRot(Quaternion rotation) {\n\t\tthis.rot = rotation;\n\t}\n\n\t/**\n\t * returns the current value of the `scale` field, which represents a vector of three\n\t * floating-point numbers that represent the object's size in the x, y, and z directions.\n\t * \n\t * @returns a `Vector3f` object containing the scale value.\n\t * \n\t * \t- `scale`: A `Vector3f` object representing the scale of the game object.\n\t * \t+ It has three components: x, y, and z, which represent the scale along the x,\n\t * y, and z axes, respectively.\n\t */\n\tpublic Vector3f getScale() {\n\t\treturn scale;\n\t}\n\n\t/**\n\t * sets the scaling factor for an object, updating its `scale` field with the provided\n\t * value.\n\t * \n\t * @param scale 3D scaling factor for the object, which is applied to its position,\n\t * size, and orientation.\n\t * \n\t * \t- `this.scale = scale;` sets the scale factor for this object.\n\t * \t- `scale` is a `Vector3f` instance that holds the scale values for each dimension\n\t * (x, y, and z).\n\t */\n\tpublic void setScale(Vector3f scale) {\n\t\tthis.scale = scale;\n\t}\n\t\n\t/**\n\t * returns an empty string.\n\t * \n\t * @returns an empty string.\n\t * \n\t * \t- The function returns a string value empty of any content.\n\t * \t- The return type is specified as String, indicating that the function will always\n\t * return a string value.\n\t * \t- The function name 'toString' suggests that it is designed to provide a concise\n\t * representation of its input, typically for debugging or serialization purposes.\n\t */\n\t@Override\n\tpublic String toString() { return \"\";\n\t}\n\n}",
            "location": {
              "start": 14,
              "insert": 7,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 6,
                "end": 13
              }
            },
            "item_type": "class",
            "length": 372,
            "docLength": 7
          },
          {
            "id": "e69feb59-fecc-1d82-a843-e17338fbbac3",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "updates the values of the `pos`, `rot`, and `scale` fields of an object based on the current values of those fields and any changes made to them since the last update.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "public void update() {\n    if (oldPos != null) {\n        if (!oldPos.equals(pos))\n            oldPos.set(pos);\n        if (!oldRot.equals(rot))\n            oldRot.set(rot);\n        if (!oldScale.equals(scale))\n            oldScale.set(scale);\n    } else {\n        oldPos = new Vector3f().set(pos);\n        oldRot = new Quaternion().set(rot);\n        oldScale = new Vector3f().set(scale);\n    }\n}\n",
              "description": "\nThis code would be used to update the position, rotation and scale of an object in a game. The update method will keep track of the last position, rotation and scale of the object so that it can be updated accordingly."
            },
            "name": "update",
            "code": "public void update() {\n\t\tif (oldPos != null) {\n\t\t\tif (!oldPos.equals(pos))\n\t\t\t\toldPos.set(pos);\n\t\t\tif (!oldRot.equals(rot))\n\t\t\t\toldRot.set(rot);\n\t\t\tif (!oldScale.equals(scale))\n\t\t\t\toldScale.set(scale);\n\t\t} else {\n\t\t\toldPos = new Vector3f().set(pos);\n\t\t\toldRot = new Quaternion().set(rot);\n\t\t\toldScale = new Vector3f().set(scale);\n\t\t}\n\t}",
            "location": {
              "start": 43,
              "insert": 39,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 38,
                "end": 42
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 4
          },
          {
            "id": "a0f4c66d-eaff-ada0-8e4d-72e6153e146a",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "rotates a vector by an angle around a specified axis, resulting in a normalized quaternion representation of the rotation.",
            "params": [
              {
                "name": "axis",
                "type_name": "Vector3f",
                "description": "3D vector that defines the rotation axis for the transformation.\n\n* `axis`: A `Vector3f` object representing the rotation axis. It has three components: x, y, and z, which represent the coordinates of the rotation axis in 3D space.\n* `angle`: An `float` value representing the angle of rotation around the `axis`.",
                "complex_type": true
              },
              {
                "name": "angle",
                "type_name": "float",
                "description": "3D rotation angle about the specified `axis` direction.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "Vector3f axis = new Vector3f(1, 0, 0);\nGameObject gameObject = new GameObject();\ngameObject.rotate(axis, 45f);\n",
              "description": "\nThis code creates a new object with default values for the position and rotation fields, sets its rotation to be a 90-degree rotation around the x-axis (given by the `Vector3f` axis), and then uses the rotate method on that object to apply this rotation. The result of this operation is that the object will have rotated by 45 degrees about the x-axis, leaving its position unchanged.\n\nIt's worth noting that in order for the rotate method to be useful for a game, it would need to take into account the previous rotation as well as the new axis and angle, in order to build upon the current state of the object."
            },
            "name": "rotate",
            "code": "public void rotate(Vector3f axis, float angle) {\n\t\trot = new Quaternion(axis, angle).mul(rot).normalized();\n\t}",
            "location": {
              "start": 72,
              "insert": 58,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 57,
                "end": 71
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "8231bdc2-bf4f-e2b1-d94b-1f06f418adb1",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "computes the rotation required to face a given point while maintaining a fixed orientation with respect to the up vector.",
            "params": [
              {
                "name": "point",
                "type_name": "Vector3f",
                "description": "3D position that the object should look at.\n\n* `point`: A 3D vector representing the point to look at.\n* `up`: A 3D vector representing the direction of the \"up\" axis in the local coordinate system.",
                "complex_type": true
              },
              {
                "name": "up",
                "type_name": "Vector3f",
                "description": "3D direction that the look-at rotation should be applied to, relative to the current orientation of the entity.\n\n* `up` is a vector with three elements representing the direction of the upward vector in 3D space.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "// Set the camera to look at the position (x, y, z) with up vector (u1, u2, u3).\ncamera.lookAt(new Vector3f(x, y, z), new Vector3f(u1, u2, u3));\n",
              "description": "\nThis will set the camera's rotation to face the position (x, y, z) with up vector (u1, u2, u3)."
            },
            "name": "lookAt",
            "code": "public void lookAt(Vector3f point, Vector3f up) {\n\t\trot = getLookAtRotation(point, up);\n\t}",
            "location": {
              "start": 93,
              "insert": 76,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 75,
                "end": 92
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 17
          },
          {
            "id": "41958f7b-1210-9880-db4b-962d832470ac",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "computes a quaternion representation of the rotation from the point of interest (`point`) to the camera's position (`pos`) and then rotates it by the upward vector (`up`).",
            "params": [
              {
                "name": "point",
                "type_name": "Vector3f",
                "description": "3D position from which to compute the look-at rotation.\n\n* `point`: A `Vector3f` object representing the position in 3D space.\n* `up`: A `Vector3f` object representing the up direction in 3D space.",
                "complex_type": true
              },
              {
                "name": "up",
                "type_name": "Vector3f",
                "description": "3D vector that defines the direction of the look-at rotation, which is used to calculate the rotation quaternion.\n\n* `up` is a `Vector3f` object representing an arbitrary vector in 3D space.\n* `up` has three components (x, y, z) that define its direction in 3D space.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a Quaternion representation of the rotation required to face the provided point while looking along the specified up direction.\n\n* The `Quaternion` object represents a rotation that is applied to a vector, which in this case is the input point minus the position vector.\n* The `Matrix4f` object used for initialization contains the rotation matrix that corresponds to the angle and axis of the look-at rotation.\n* The `up` parameter provides the direction of the up vector in the world frame, which is used as a reference for the look-at rotation.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Example input values for point and up variables\nVector3f point = new Vector3f(1, 2, 3);\nVector3f up = new Vector3f(0, 1, 0);\n\n// Creating a new Quaternion object using the getLookAtRotation method with the point and up inputs.\nQuaternion rotation = this.getLookAtRotation(point, up);\n",
              "description": "\nThe example input values for point and up are set to (1, 2, 3) and (0, 1, 0) respectively. These values would be used as the input parameters for the getLookAtRotation method, which creates a new Quaternion object using the initRotation method of the Matrix4f class and returns it.\n\nThe getLookAtRotation method is called on an entity that has already been initialized with position (x, y, z), this.getPos(). The method then calculates the rotation needed to look at a point in 3D space from its current position using the initRotation method of the Matrix4f class and returns it as a Quaternion object."
            },
            "name": "getLookAtRotation",
            "code": "public Quaternion getLookAtRotation(Vector3f point, Vector3f up) {\n\t\treturn new Quaternion(new Matrix4f().initRotation(point.sub(pos).normalized(), up));\n\t}",
            "location": {
              "start": 126,
              "insert": 97,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 96,
                "end": 125
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 29
          },
          {
            "id": "d2ea35bf-db3d-b1a8-6c4f-674ef0d19d47",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "evaluates whether an object's properties have changed by comparing them to their previous values. If any property has changed, the function returns `true`. Otherwise, it returns `false`.",
            "params": [],
            "returns": {
              "type_name": "boolean",
              "description": "a boolean value indicating whether any of the object's properties have changed.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public boolean hasChanged() {\n    if (parent != null && parent.hasChanged()) return true;\n\n    if (!pos.equals(oldPos)) return true;\n\n    if (!rot.equals(oldRot)) return true;\n\n    if (!scale.equals(oldScale)) return true;\n\n    return false;\n}\n",
              "description": "\nExplanation:\n\n1. The method first checks if the parent entity has changed (using recursion). If it has, the current entity is also considered to have changed and the function returns `true`.\n2. Next, the method checks if any of the position (`pos`), rotation (`rot`), or scale (`scale`) components are not equal to their previous values (`oldPos`, `oldRot`, and `oldScale`). If they are different, it means that the current entity has been changed and the function returns `true`.\n3. Finally, the method checks if there is no change in any of the position, rotation, or scale components. In this case, the function returns `false`, indicating that the entity has not been changed.\n\nNote: The old values of the position (`oldPos`), rotation (`oldRot`), and scale (`oldScale`) are set using the appropriate setter methods (e.g., `setPos()`, `setRot()`, and `setScale()`) before calling the `hasChanged()` method."
            },
            "name": "hasChanged",
            "code": "public boolean hasChanged() {\n\t\tif (parent != null && parent.hasChanged())\n\t\t\treturn true;\n\n\t\tif (!pos.equals(oldPos))\n\t\t\treturn true;\n\n\t\tif (!rot.equals(oldRot))\n\t\t\treturn true;\n\n\t\tif (!scale.equals(oldScale))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}",
            "location": {
              "start": 137,
              "insert": 130,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 129,
                "end": 136
              }
            },
            "item_type": "method",
            "length": 15,
            "docLength": 7
          },
          {
            "id": "db308fb0-465d-f3a6-cf4f-ee83a135f16f",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "computes a transformation matrix based on the position, rotation, and scale of an object, and returns it as a `Matrix4f` instance.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a transformed matrix representing a combination of translation, rotation, and scaling.\n\nThe return value is a `Matrix4f` object representing a transformation matrix.\nIt is obtained by multiplying the parent matrix (representing the overall transformation), with the translation, rotation, and scaling matrices in the correct order.\nThe translation matrix represents the offset of the object from its initial position, while the rotation matrix represents the angle and axis of rotation around which the object is rotated.\nThe scaling matrix represents the size and orientation of the object in the x, y, and z directions.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Entity entity = new Entity();\nentity.setPos(new Vector3f(1, 2, 3));\nentity.setRot(new Quaternion());\nentity.setScale(new Vector3f(4, 5, 6));\n\nMatrix4f transformationMatrix = entity.getTransformation();\n",
              "description": "\nIn this example, the method is called on an object of type Entity, which has fields for position, rotation, and scale. The method returns a 4x4 transformation matrix that can be used to apply the transformations to an object in a 3D space. In this case, the transformation matrix is applied to an empty object, resulting in no change in its position or orientation.\n\nIt is important to note that this example uses the default values for the position, rotation, and scale fields of the Entity class. If these fields are initialized with specific values, the transformation matrix will represent a different transformation. Additionally, this example does not take into account any parent transformations that may be applied to the entity's transformation matrix.\n\nIt is also worth noting that this example does not demonstrate the use of a parent matrix in the context of an Entity object. The parent matrix is a component of the transformation matrix that represents the combined transformation of all ancestor objects in the scene graph, which may include other entities, groups, and transformations. If an entity has a parent matrix applied to its transformation, it will be represented by the product of its parent matrix and its own transformation matrix."
            },
            "name": "getTransformation",
            "code": "public Matrix4f getTransformation() {\n\t\tMatrix4f translationMatrix = new Matrix4f().initTranslation(pos.getX(), pos.getY(), pos.getZ());\n\t\tMatrix4f rotationMatrix = rot.toRotationMatrix();\n\t\tMatrix4f scaleMatrix = new Matrix4f().initScale(scale.getX(), scale.getY(), scale.getZ());\n\n\t\treturn getParentMatrix().mul(translationMatrix.mul(rotationMatrix.mul(scaleMatrix)));\n\t}",
            "location": {
              "start": 171,
              "insert": 153,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 152,
                "end": 170
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 18
          },
          {
            "id": "f0f4257b-3c75-80b3-aa4f-31c15da1a1d8",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "retrieves the transformation matrix of its parent node if it has changed, otherwise returns the current matrix unchanged.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a matrix representation of the parent transformation.\n\n* `parentMatrix`: A `Matrix4f` object representing the transformation matrix of the parent node in the tree. If `parent` is null, the matrix will be `null`.\n* `hasChanged()`: A boolean method that indicates whether the matrix has changed since it was last used. This information can be used to optimize the calculation of the matrix.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "private Matrix4f getParentMatrix() {\n\t\tif (parent != null && parent.hasChanged())\n\t\t\tparentMatrix = parent.getTransformation();\n\n\t\treturn parentMatrix;\n\t}\n",
              "description": "\nIn the example above, we first check if parent is not null and has changed, then assign it to the parentMatrix variable. This is done because in the getTransformation method, we only want to update the transformation matrix if the parent entity has changed its own transformation.\nThis method can be used in the following way:\n"
            },
            "name": "getParentMatrix",
            "code": "private Matrix4f getParentMatrix() {\n\t\tif (parent != null && parent.hasChanged())\n\t\t\tparentMatrix = parent.getTransformation();\n\n\t\treturn parentMatrix;\n\t}",
            "location": {
              "start": 192,
              "insert": 179,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 178,
                "end": 191
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 13
          },
          {
            "id": "865b6f6e-88fd-1db2-b640-9a6ef15c822d",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "sets the parent transformation object for the current instance, storing the reference in the `parent` field.",
            "params": [
              {
                "name": "parent",
                "type_name": "Transform",
                "description": "Transform to which the current object's position and rotation will be set.\n\n* `parent`: A reference to a transformed object, which serves as the parent for this transformed object.\n* Type: `Transform`",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "Transform t = new Transform();\nTransform parent = new Transform();\nt.setParent(parent);\n",
              "description": "\nThis is because the method takes a Transform object as its argument, and it assigns that parent to the object's current parent.\n\nPlease let me know if this makes sense!"
            },
            "name": "setParent",
            "code": "public void setParent(Transform parent) {\n\t\tthis.parent = parent;\n\t}",
            "location": {
              "start": 212,
              "insert": 199,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 198,
                "end": 211
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "505b7444-4e6f-1a91-8342-de140b692cfa",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "transforms a `Vector3f` object `pos` using the transformation matrix of its parent component, and returns the transformed position.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a transformed position vector in the parent matrix's coordinate system.\n\nThe `Vector3f` object that is returned represents the transformed position of the game object. This transformation is applied by multiplying the original position vector with the matrix represented by the `getParentMatrix` method. Therefore, the transformed position reflects the changes made to the object's position due to its parenting relationship and any additional transformations applied through the matrix.\nThe returned vector has three components: x, y, and z, which represent the transformed position in each dimension. Each component can take on any real number value within the range of the floating-point representation used by Java.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Example {\n    public static void main(String[] args) {\n        Entity entity = new Entity();\n\n        // ...\n\n        Vector3f transformedPosition = entity.getTransformedPos();\n\n        System.out.println(\"The transformed position of the entity is: \" + transformedPosition);\n    }\n}\n",
              "description": ""
            },
            "name": "getTransformedPos",
            "code": "public Vector3f getTransformedPos() {\n\t\treturn getParentMatrix().transform(pos);\n\t}",
            "location": {
              "start": 229,
              "insert": 216,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 215,
                "end": 228
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "355e8ec8-b6db-5f88-9243-814d8e09cdf0",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "computes the transformed rotation of a parent object based on its own rotation and the given `rot` parameter, using the quaternion multiplication operator.",
            "params": [],
            "returns": {
              "type_name": "Quaternion",
              "description": "a transformed rotation quaternion.\n\n* `Quaternion parentRotation`: This is the rotational transformation applied to the parent object, represented as a Quaternion.\n* `rot`: The rotational transformation applied to the parent object, also represented as a Quaternion.\n* `mul`: The multiplication operation performed on the `parentRotation` and `rot` Quaternions, resulting in the transformed rotation.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class GameObject {\n    private Vector3f pos;\n    private Quaternion rot;\n    private Vector3f scale;\n    private GameObject parent;\n\n    public Quaternion getTransformedRot() {\n        Quaternion parentRotation = new Quaternion(1, 0, 0, 0);\n\n        if (parent != null)\n            parentRotation = parent.getTransformedRot();\n\n        return parentRotation.mul(rot);\n    }\n\n    public Vector3f getPos() {\n        return pos;\n    }\n\n    public void setPos(Vector3f pos) {\n        this.pos = pos;\n    }\n\n    public void addToPos(Vector3f addVec) {\n        this.setPos(this.getPos().add(addVec));\n    }\n}\n",
              "description": "\nIn the example above, we define a class called GameObject that has three attributes: pos, rot, and scale. The parent attribute represents the parent object of the current instance.\n\nThe method getTransformedRot returns a quaternion value which represents the rotation of the object, taking into account the parent's rotation if it has one. It does this by first creating an initial quaternion value that represents the identity rotation (1, 0, 0, 0). If the object has a parent, its rotation is added to this value using the multiplication operator mul of the quaternion class.\n\nThe other methods are used to access and set the position, rotation, and scale values of the object. The addToPos method adds a vector to the current position value, updating its new position based on the addition."
            },
            "name": "getTransformedRot",
            "code": "public Quaternion getTransformedRot() {\n\t\tQuaternion parentRotation = new Quaternion(1, 0, 0, 0);\n\n\t\tif (parent != null)\n\t\t\tparentRotation = parent.getTransformedRot();\n\n\t\treturn parentRotation.mul(rot);\n\t}",
            "location": {
              "start": 251,
              "insert": 233,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 232,
                "end": 250
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 18
          },
          {
            "id": "42593f5f-5db8-c18a-d84b-5edce3c26c56",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "returns the position of an object in a three-dimensional space as a `Vector3f` object.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a `Vector3f` object representing the position of the game object.\n\n* `pos`: A Vector3f object that contains the position of the entity in 3D space.\n\t+ It has three components: x, y, and z, which represent the entity's position in the x, y, and z axes, respectively.\n\t+ The values of these components are stored as floating-point numbers.\n* The Vector3f object is immutable, meaning that its properties cannot be changed once it is created.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Entity {\n\tprivate Vector3f pos;\n\t\n\tpublic Vector3f getPos() {\n\t\treturn pos;\n\t}\n}\n\n// usage example of the getPos() function:\nEntity e = new Entity(); // create an object of class Entity\ne.pos = new Vector3f(1, 2, 3); // set the position component of the entity to a vector\nVector3f pos = e.getPos(); // retrieve the position component of the entity as a Vector3f object\nSystem.out.println(\"position: \" + pos); // print the retrieved position value\n",
              "description": "\nIn this example, the `Entity` class has a member variable called `pos` of type `Vector3f`. This is a field that represents the position of an entity in 3D space. The `getPos()` method returns a reference to this field. The `Vector3f` class contains three components: x, y, and z, which represent the position along the x, y, and z axes respectively.\nThe usage example shows how the `getPos()` function is used to retrieve the position of an entity in 3D space and print it out as a string using the `System.out.println()` function."
            },
            "name": "getPos",
            "code": "public Vector3f getPos() {\n\t\treturn pos;\n\t}",
            "location": {
              "start": 269,
              "insert": 260,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 259,
                "end": 268
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "77d2fd30-6c1c-dc92-c842-d0c9e23ed02d",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "sets the position of an object to a specified value.",
            "params": [
              {
                "name": "pos",
                "type_name": "Vector3f",
                "description": "3D position of an object or entity, which is assigned to the `pos` field of the current instance.\n\n* `this.pos`: This is a field in the current object instance that stores the position value. It has a type of `Vector3f`, which represents a 3D coordinate system.\n* `Vector3f`: This class represents a 3D vector and contains three properties: `x`, `y`, and `z`, each representing the component of the vector in the corresponding dimension.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "Entity e = new Entity();\ne.setPos(new Vector3f(1, 2, 3)); // sets the position of the entity to (1, 2, 3)\n",
              "description": "\nIn this example, the vector (1, 2, 3) is used as the input for setPos, which updates the position of the entity to the new value. The values of x, y, and z are updated respectively.\n\nFor more information on the Vector3f class and its methods, please refer to the Java documentation: https://docs.oracle.com/javase/7/docs/api/java/awt/geom/Vector3f.html\n\nNote that in this example, the function setPos is not being used as a constructor of an object, but rather as a method on an existing entity instance."
            },
            "name": "setPos",
            "code": "public void setPos(Vector3f pos) {\n\t\tthis.pos = pos;\n\t}",
            "location": {
              "start": 284,
              "insert": 273,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 272,
                "end": 283
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 11
          },
          {
            "id": "f91c63e9-02d8-1183-bb47-184e0bccf037",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "updates the position of an object by adding a vector to its current position.",
            "params": [
              {
                "name": "addVec",
                "type_name": "Vector3f",
                "description": "3D vector to be added to the current position of the object.\n\n* `Vector3f`: This is the class representing a 3D vector in Java. It has three components - x, y, and z - which represent the position of the vector in the 3D space.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Entity entity = new Entity();\n        Vector3f addVec = new Vector3f(1, 2, 3);\n        entity.addToPos(addVec);\n    }\n}\n",
              "description": "\nIn this example, a new `Entity` object is created and an instance of the `Vector3f` class with values 1, 2, and 3 for its x, y, and z components is passed to the `addToPos()` method. The `addToPos()` method modifies the position vector of the `entity` object by adding the specified values to its current position values. Therefore, after this line is executed, the `entity`'s position will be updated to `(4, 6, 9)`."
            },
            "name": "addToPos",
            "code": "public void addToPos(Vector3f addVec) { this.setPos(this.getPos().add(addVec)); }",
            "location": {
              "start": 303,
              "insert": 288,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 287,
                "end": 302
              }
            },
            "item_type": "method",
            "length": 1,
            "docLength": 15
          },
          {
            "id": "66ee6641-2aef-d6b8-c640-8104b0b9acae",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "returns a `Quaternion` object representing the rotation of an entity.",
            "params": [],
            "returns": {
              "type_name": "Quaternion",
              "description": "a Quaternion object containing the rotation matrix.\n\nThe function returns a Quaternion object representing the rotation of the object. The Quaternion class in Java is used to represent 3D rotations as a combination of real and imaginary parts. The return value has four components: x, y, z, and w, which correspond to the real and imaginary parts of the quaternion.\n\nThe Quaternion object has several methods for manipulating and transforming 3D rotations, such as multiply, conjugate, and normalize. These methods are useful for creating complex rotations by combining multiple simple rotations.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Example usage of the `getRot` method\nQuaternion objectRotation = myObject.getRot();\n",
              "description": "\nThis code declares and initializes a variable named `objectRotation`, which refers to the quaternion representing the rotation of the game object `myObject`. The variable is then used to store the rotation value returned by the method `getRot` called on `myObject`."
            },
            "name": "getRot",
            "code": "public Quaternion getRot() {\n\t\treturn rot;\n\t}",
            "location": {
              "start": 319,
              "insert": 305,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 304,
                "end": 318
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "7bc07498-7d61-f283-ad45-a66e37dbf2bf",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "sets the Rotation value of the class instance variable \"rot\" to the provided Quaternion argument.",
            "params": [
              {
                "name": "rotation",
                "type_name": "Quaternion",
                "description": "4D quaternion that represents the rotation of an object in 3D space, which is assigned to the `rot` field of the `java.lang.Object` class.\n\n* `Quaternion`: The type of the rotation parameter, which represents a quaternion value representing a 3D rotation.\n* `this.rot`: The field being assigned to, which stores the rotation value for this object.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Example {\n    public static void main(String[] args) {\n        Quaternion rotation = new Quaternion();\n        MyObject myObj = new MyObject();\n        \n        // Setting the object's rotation to a quaternion\n        myObj.setRot(rotation);\n    }\n}\n",
              "description": "\nIn this example, the main method creates a new instance of the class Quaternion called 'rotation', which represents the orientation of an object in 3D space using a Quaternion data structure. The main method then creates a new instance of MyObject called 'myObj' and uses the setRot method to assign the quaternion 'rotation' as the rotation value of the object.\n\nIt is important to note that the method setRot requires the input parameter 'rotation' to be of type Quaternion, which means the user must provide a valid instance of the class Quaternion in order for the function to work correctly. The example shows how the method can be used correctly by creating an instance of Quaternion and passing it as a parameter to the setRot method."
            },
            "name": "setRot",
            "code": "public void setRot(Quaternion rotation) {\n\t\tthis.rot = rotation;\n\t}",
            "location": {
              "start": 337,
              "insert": 323,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 322,
                "end": 336
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "83350279-6100-4faa-c247-def3526b0b60",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "returns the current scale value of the `Vector3f` object.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a `Vector3f` object representing the scaling factor of the game object.\n\nThe `scale` variable returns a `Vector3f` object representing the scale factor for this GameObject. This vector includes three elements that represent the scaling values for the X, Y, and Z axes, respectively. The elements of the vector are floating-point numbers that range from 0 to 1, indicating the degree to which each axis should be scaled relative to its original value.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\t\tVector3f scale = new Vector3f();\n\t\tscale.setX(1);\n\t\tscale.setY(2);\n\t\tscale.setZ(3);\n\n\t\tEntity entity = new Entity();\n\t\tentity.setScale(scale);\n\n\t\tSystem.out.println(\"Scale X: \" + entity.getScale().getX());\n\t\tSystem.out.println(\"Scale Y: \" + entity.getScale().getY());\n\t\tSystem.out.println(\"Scale Z: \" + entity.getScale().getZ());\n\t}\n",
              "description": ""
            },
            "name": "getScale",
            "code": "public Vector3f getScale() {\n\t\treturn scale;\n\t}",
            "location": {
              "start": 351,
              "insert": 341,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 340,
                "end": 350
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 10
          },
          {
            "id": "b37c9eb7-c684-629c-8349-c888e4026a53",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "sets the `scale` field of its class instance, which represents a transformation matrix used in rendering 3D graphics. The provided vector `scale` is used to update the corresponding element of the transformation matrix.",
            "params": [
              {
                "name": "scale",
                "type_name": "Vector3f",
                "description": "3D vector that defines the scaling factor for the object, which is then assigned to the `scale` field of the function's caller.\n\n* The `scale` field is a `Vector3f` object, which represents a 3D vector in the game engine.\n* It contains the x, y, and z components of the vector, which can be accessed through the get methods `x`, `y`, and `z()`.\n* The `Vector3f` class provides various methods for manipulating the components of the vector, such as `add()`, `sub()`, `mul()`, and `div()`.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "GameObject obj = new GameObject();\nobj.setScale(new Vector3f(1, 2, 3));\n",
              "description": "\nIn this case, the object's scale factor will be updated to represent a scaling of 1 in the x, 2 in the y, and 3 in the z directions."
            },
            "name": "setScale",
            "code": "public void setScale(Vector3f scale) {\n\t\tthis.scale = scale;\n\t}",
            "location": {
              "start": 366,
              "insert": 355,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 354,
                "end": 365
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 11
          },
          {
            "id": "4b91a7c8-47d1-9da7-4f4e-486370063a88",
            "ancestors": [
              "dc8476c6-b0b9-79b9-3a4c-bb8907417455"
            ],
            "type": "function",
            "description": "returns an empty string, indicating that the object it is called on has no meaningful representation as a string.",
            "params": [],
            "returns": {
              "type_name": "empty",
              "description": "an empty string.\n\n1. The output is an empty string, indicating that the method does not return any meaningful information about the object it is called on.\n2. The use of the empty string as the output suggests that the method may be intended for internal implementation purposes only, rather than providing a useful representation of the object.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    Entity entity = new Entity();\n    System.out.println(entity);\n}\n\n@Override\npublic String toString() { return \"Entity\"; }\n",
              "description": "\nThis example will print out the string `Entity` to the console because we are overriding the method toString in our Entity class and returning a String containing the word `Entity`.  Because it is an empty string, this will not provide any additional information about what Entity represents."
            },
            "name": "toString",
            "code": "@Override\n\tpublic String toString() { return \"\";\n\t}",
            "location": {
              "start": 381,
              "insert": 370,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 369,
                "end": 380
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 11
          }
        ]
      }
    }
  },
  {
    "name": "Util.java",
    "path": "src/com/ch/Util.java",
    "content": {
      "structured": {
        "description": "three methods for performing various data transformations:\n\n1. `removeEmptyStrings()` removes empty strings from a 2D array of strings, returning a new 1D array with non-empty strings.\n2. `toIntArray()` converts an `Integer[]` array to an `int[]` array, retaining the original values.\n3. `toFloatArray()` and `toIntArray()` convert lists of integers or floating-point numbers, respectively, into equivalent arrays of the same size, copying each value from the input list to the output array.",
        "diagram": "digraph G {\n    label=\"com.ch.Util\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n",
        "items": [
          {
            "id": "0ce56027-afaa-8eaa-2747-4d2262d256a7",
            "ancestors": [],
            "type": "function",
            "description": "is a utility class that provides various methods for manipulating arrays and matrices in a 2D graphics library. The class offers methods to create and manipulate arrays of different data types, such as `FloatBuffer`, `Integer`, and `Matrix4f`. Additionally, it provides methods to remove empty strings from an array and convert between integer, float, and string arrays.",
            "name": "Util",
            "code": "public class Util {\n\t\n /**\n  * generates a `FloatBuffer` object of specified size, using the `BufferUtils` class.\n  * \n  * @param size capacity of the `FloatBuffer` to be created, which determines the\n  * number of elements that can be stored in the buffer.\n  * \n  * @returns a `FloatBuffer` object of the specified size, which can be used to store\n  * and manipulate floating-point data.\n  * \n  * \t- The returned buffer is of type `FloatBuffer`.\n  * \t- The size of the buffer is specified by the `size` parameter passed to the function.\n  * \t- The buffer contains a contiguous block of floating-point values with a specific\n  * size.\n  */\n\tpublic static FloatBuffer createFloatBuffer(int size) {\n\t\treturn BufferUtils.createFloatBuffer(size);\n\t}\n\n /**\n  * creates an integer buffer with the specified size using `BufferUtils`. The returned\n  * buffer can be used for storing and manipulating integer values.\n  * \n  * @param size integer capacity of the IntBuffer created by the `createIntBuffer()`\n  * method.\n  * \n  * @returns an `IntBuffer` object of the specified size.\n  * \n  * \t- The IntBuffer object is created using the `BufferUtils` class.\n  * \t- The size parameter passed to the function determines the capacity of the buffer.\n  * \t- The returned IntBuffer has a fixed capacity and cannot be resized or modified\n  * once it is created.\n  * \t- The buffer can be accessed and manipulated using the standard methods provided\n  * by the `IntBuffer` interface.\n  */\n\tpublic static IntBuffer createIntBuffer(int size) {\n\t\treturn BufferUtils.createIntBuffer(size);\n\t}\n\n /**\n  * creates a new instance of `java.nio.Buffer` with the specified size.\n  * \n  * @param size buffer size, which is used to create a new ByteBuffer object with the\n  * specified capacity.\n  * \n  * @returns a non-null `ByteBuffer` instance with the specified size.\n  * \n  * \t- The function returns a `ByteBuffer` instance that represents a contiguous block\n  * of memory capable of holding binary data.\n  * \t- The size parameter specifies the capacity of the buffer, which determines how\n  * much data can be stored in it.\n  * \t- The buffer is created using `BufferUtils`, a utility class provided by the Java\n  * platform for working with buffers and other memory-related primitives.\n  */\n\tpublic static ByteBuffer createByteBuffer(int size) {\n\t\treturn BufferUtils.createByteBuffer(size);\n\t}\n\n /**\n  * creates an `IntBuffer` from a list of integers, stores them in the buffer, and\n  * flips the buffer to create a new buffer with the values in the original order.\n  * \n  * @returns an IntBuffer containing the flipped values.\n  * \n  * \t- The function creates an `IntBuffer` object named `buffer`.\n  * \t- The `buffer` object is filled with the input array `values`.\n  * \t- The `buffer` object is flipped using the `flip()` method.\n  * \n  * The resulting `IntBuffer` object has the following properties:\n  * \n  * \t- It contains the same sequence of integers as the input array `values`.\n  * \t- It is in a flipped state, meaning that the order of the integers in the buffer\n  * is reversed compared to the original input array.\n  */\n\tpublic static IntBuffer createFlippedBuffer(int... values) {\n\t\tIntBuffer buffer = createIntBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\t\n /**\n  * creates a new FloatBuffer by copying the given array of floats into it, and then\n  * flipping the buffer for efficient access.\n  * \n  * @returns a flipped FloatBuffer containing the provided values.\n  * \n  * The function creates a new `FloatBuffer` object by calling the `createFloatBuffer`\n  * method and passing in the length of the input array as an argument.\n  * \n  * The `buffer.put(values)` statement copies the elements of the input array into the\n  * buffer, starting at the beginning of the buffer.\n  * \n  * The `buffer.flip()` statement flips the buffer, making its position pointer point\n  * to the end of the buffer instead of the beginning. This allows for efficient reading\n  * of the buffer's contents in a particular order.\n  * \n  * Overall, the `createFlippedBuffer` function creates a new `FloatBuffer` object\n  * that is initialized with the input array values and is flipped for efficient access.\n  */\n\tpublic static FloatBuffer createFlippedBuffer(float... values) {\n\t\tFloatBuffer buffer = createFloatBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\n\t/*\n\tpublic static FloatBuffer createFlippedBuffer(Vertex[] vertices) {\n\t\tFloatBuffer buffer = createFloatBuffer(vertices.length * Vertex.SIZE);\n\n\t\tfor (int i = 0; i < vertices.length; i++) {\n\t\t\tbuffer.put(vertices[i].getPos().getX());\n\t\t\tbuffer.put(vertices[i].getPos().getY());\n\t\t\tbuffer.put(vertices[i].getPos().getZ());\n\t\t\tbuffer.put(vertices[i].getTexCoord().getX());\n\t\t\tbuffer.put(vertices[i].getTexCoord().getY());\n\t\t\tbuffer.put(vertices[i].getNormal().getX());\n\t\t\tbuffer.put(vertices[i].getNormal().getY());\n\t\t\tbuffer.put(vertices[i].getNormal().getZ());\n\t\t\tbuffer.put(vertices[i].getTangent().getX());\n\t\t\tbuffer.put(vertices[i].getTangent().getY());\n\t\t\tbuffer.put(vertices[i].getTangent().getZ());\n\t\t}\n\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\t*/\n\n\t/*\n\tpublic static FloatBuffer createFlippedBuffer(Matrix4f value) {\n\t\tFloatBuffer buffer = createFloatBuffer(4 * 4);\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tbuffer.put(value.get(i, j));\n\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}\n\t\n\tpublic static Matrix4f loatMat4(FloatBuffer vals) {\n\t\t\n//\t\tvals.flip();\n\t\t\n\t\tMatrix4f m = new Matrix4f();\n\t\t\n\t\tint index;\n\t\tfor (index = 0; index < 16; index++)\n\t\t\tm.set(index % 4, index / 4, vals.get());\n\t\t\n\t\treturn m;\n\t}\n*/\n /**\n  * filters a string array by removing any empty strings, resulting in a new array\n  * with non-empty strings.\n  * \n  * @param data 2D array of strings that needs to be processed and transformed into a\n  * new 1D array without empty strings.\n  * \n  * The method takes an array of `String`s as input, denoted by `data`.\n  * \n  * The type of `data` is not explicitly specified; however, considering the context\n  * of the code snippet, it can be inferred to be of type `String[]`.\n  * \n  * Within the function, `data` undergoes processing and its elements are filtered\n  * based on a predetermined condition - if the element is not an empty string.\n  * \n  * The filtered elements are then collected in an instance of `ArrayList`, denoted\n  * by `result`. The `ArrayList` is created with no arguments, indicating that it\n  * should be initialized with a default capacity.\n  * \n  * Subsequently, the elements of `result` are copied into an array of `String`s,\n  * denoted by `res`, using the `toArray()` method.\n  * \n  * The `res` array is returned as output from the function.\n  * \n  * @returns an array of non-empty strings.\n  */\n\tpublic static String[] removeEmptyStrings(String[] data) {\n\t\tArrayList<String> result = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tif (!data[i].equals(\"\"))\n\t\t\t\tresult.add(data[i]);\n\n\t\tString[] res = new String[result.size()];\n\t\tresult.toArray(res);\n\n\t\treturn res;\n\t}\n\n /**\n  * converts an `Integer[]` array to an `int[]` array, retaining the original values.\n  * \n  * @param data array of integers that is converted into an integer array by the function.\n  * \n  * \t- `Integer[] data`: This is an array of integers that represents the original\n  * data to be converted into an integer array.\n  * \t- `int[] result`: The resulting integer array that stores the converted values\n  * from `data`.\n  * \n  * @returns an integer array with the same length as the input `data` array, containing\n  * the original values of the elements.\n  */\n\tpublic static int[] toIntArray(Integer[] data) {\n\t\tint[] result = new int[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}\n\t\n /**\n  * converts a list of integers to an integer array, creating a new array with the\n  * same size as the list and containing the corresponding integers from the list.\n  * \n  * @param data List of integers that are converted into an integer array by the\n  * `toIntArray()` method.\n  * \n  * 1/ `data` is a `List<Integer>` containing a collection of integers.\n  * 2/ The size of the list, denoted by `data.size()`, can be used to determine the\n  * number of elements in the list.\n  * 3/ Each element in the list can be accessed and retrieved using its index or\n  * position in the list, as denoted by `data.get(i)`.\n  * \n  * @returns an integer array of size equal to the number of elements in the input list.\n  */\n\tpublic static int[] toIntArray(List<Integer> data) {\n\t\tint[] result = new int[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}\n\t\n /**\n  * converts a `Float[]` array to an equivalent `float[]` array with the same length,\n  * copying each value from the input array to the output array.\n  * \n  * @param data Float array that is to be converted into a float array.\n  * \n  * \t- The type of `data` is `Float[]`, indicating that it is an array of floating-point\n  * numbers.\n  * \t- The length of `data` is specified by its `length` attribute, which is a valid\n  * integer value.\n  * \t- Each element in the array is represented by a separate `Float` object, which\n  * can be accessed and manipulated individually through the array's indices (zero-based).\n  * \n  * @returns an array of floating-point values equivalent to the input `data`.\n  */\n\tpublic static float[] toFloatArray(Float[] data) {\n\t\tfloat[] result = new float[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}\n\t\n /**\n  * converts a list of floating-point numbers to an array of the same size, copying\n  * each number from the input list to the output array.\n  * \n  * @param data list of Float values that will be converted into an array of Floats\n  * by the function.\n  * \n  * \t- The input `data` is of type `List<Float>`, indicating that it is an array-like\n  * data structure containing floating-point numbers.\n  * \t- The size of `data` can be retrieved using its `size()` method, which returns\n  * the number of elements in the list.\n  * \t- Each element of `data` is accessed using its index, represented by the variable\n  * `i`, which ranges from 0 to `data.size() - 1`.\n  * \n  * @returns an array of `float` values containing the elements of the input `List<Float>`.\n  */\n\tpublic static float[] toFloatArray(List<Float> data) {\n\t\tfloat[] result = new float[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}\n}",
            "location": {
              "start": 18,
              "insert": 11,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 10,
                "end": 17
              }
            },
            "item_type": "class",
            "length": 294,
            "docLength": 7
          },
          {
            "id": "1db2f530-8dfd-56a6-9047-e6b706766b40",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "creates a new float buffer instance using the `BufferUtils` class. The size parameter is used to determine the capacity of the buffer. The returned buffer can be used for storing and manipulating floating-point numbers.",
            "params": [
              {
                "name": "size",
                "type_name": "int",
                "description": "number of floating-point values to be stored in the resulting `FloatBuffer`.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "FloatBuffer",
              "description": "a FloatBuffer object representing a contiguous block of memory capable of storing floating-point data.\n\n* The `createFloatBuffer` function returns an object of type `FloatBuffer`. This means that it is a buffer that stores floating-point numbers.\n* The `size` parameter passed to the function determines the capacity of the buffer.\n* The buffer is created using the `BufferUtils` class, which provides utility methods for creating and manipulating buffers.",
              "complex_type": true
            },
            "name": "createFloatBuffer",
            "code": "public static FloatBuffer createFloatBuffer(int size) {\n\t\treturn BufferUtils.createFloatBuffer(size);\n\t}",
            "location": {
              "start": 34,
              "insert": 20,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 19,
                "end": 33
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "f1a9b1a8-6f54-4896-9644-b120613e4e0a",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "creates an `IntBuffer` instance of a specified size, leveraging `BufferUtils` utility class.",
            "params": [
              {
                "name": "size",
                "type_name": "int",
                "description": "amount of memory required to store an IntBuffer.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "IntBuffer",
              "description": "an `IntBuffer` object that can be used to store and manipulate integer values.\n\nThe `IntBuffer` object created is an instance of BufferUtils' `createIntBuffer` method, which takes in the size of the buffer as its parameter.\n\nThe buffer is a direct view of the underlying memory, meaning it provides a fast and efficient way to access the data stored within it.\n\nThe buffer is also backed by a valid region of memory, ensuring that the data it contains is properly allocated and accessible.",
              "complex_type": true
            },
            "name": "createIntBuffer",
            "code": "public static IntBuffer createIntBuffer(int size) {\n\t\treturn BufferUtils.createIntBuffer(size);\n\t}",
            "location": {
              "start": 54,
              "insert": 38,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 37,
                "end": 53
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 16
          },
          {
            "id": "321aaa63-439f-2898-5441-1d5293178941",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "creates a new byte buffer instance with the specified size.",
            "params": [
              {
                "name": "size",
                "type_name": "int",
                "description": "desired capacity of the ByteBuffer to be created, which determines the amount of memory allocated for storing data.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "ByteBuffer",
              "description": "a non-null `ByteBuffer` object with the specified size.\n\n* The `ByteBuffer` object represents a contiguous block of memory that can be accessed and manipulated as a sequence of bytes.\n* The size of the buffer is determined by the parameter `size`, which must be a positive integer.\n* The buffer is created using the `BufferUtils.createByteBuffer()` method, which allocates memory for the buffer and returns a pointer to the first byte in the buffer.",
              "complex_type": true
            },
            "name": "createByteBuffer",
            "code": "public static ByteBuffer createByteBuffer(int size) {\n\t\treturn BufferUtils.createByteBuffer(size);\n\t}",
            "location": {
              "start": 73,
              "insert": 58,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 57,
                "end": 72
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 15
          },
          {
            "id": "c27d4119-be02-b399-c74d-e1871969c8dd",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "creates an `IntBuffer` object from a collection of integers and flips it to create a view of the buffer that can be used for efficient random access operations.",
            "params": [],
            "returns": {
              "type_name": "IntBuffer",
              "description": "an `IntBuffer` object that contains the provided values flipped from a non-flip to a flip state.\n\n* The `IntBuffer` object is generated by putting the input `values` array into an IntBuffer using the `put()` method.\n* The `flip()` method is called on the buffer to flip it, making its data accessible for reading from the end of the buffer towards the beginning.\n* The returned buffer is a flipped IntBuffer, which means that the data can be read from the end of the buffer towards the beginning.",
              "complex_type": true
            },
            "name": "createFlippedBuffer",
            "code": "public static IntBuffer createFlippedBuffer(int... values) {\n\t\tIntBuffer buffer = createIntBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}",
            "location": {
              "start": 93,
              "insert": 77,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 76,
                "end": 92
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 16
          },
          {
            "id": "50e8acf1-f506-9ea3-d74a-4ca2f4413863",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "creates a new FloatBuffer by copying the provided array of floats, then flips the buffer to enable random access. It returns the newly created buffer.",
            "params": [],
            "returns": {
              "type_name": "FloatBuffer",
              "description": "a flipped `FloatBuffer` containing the input `float` values.\n\nThe `FloatBuffer` object returned by the function is flipped, meaning that its position points to the last element stored in the buffer.\n\nThe buffer's capacity is equal to the number of `float` values passed as arguments to the function.\n\nThe buffer's status is set to `flipped`, indicating that it contains a subset of the input data that has been rearranged for efficient access.",
              "complex_type": true
            },
            "name": "createFlippedBuffer",
            "code": "public static FloatBuffer createFlippedBuffer(float... values) {\n\t\tFloatBuffer buffer = createFloatBuffer(values.length);\n\t\tbuffer.put(values);\n\t\tbuffer.flip();\n\n\t\treturn buffer;\n\t}",
            "location": {
              "start": 120,
              "insert": 101,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 100,
                "end": 119
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 19
          },
          {
            "id": "82310e33-8bb1-009f-1944-431c307f3de9",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "removes empty strings from an array of strings and returns a new array with only non-empty strings.",
            "params": [
              {
                "name": "data",
                "type_name": "String[]",
                "description": "array of strings that is to be filtered for empty strings and returned as an array of non-empty strings.\n\n* Length: The method takes an array of strings as input, represented by the variable `data`.\n* Elements: Each element in the input array is a string object.\n* Empty strings: The function checks each element for emptiness using the `equals()` method and removes any empty strings from the array.\n* ArrayList: After removing empty strings, the function creates an ArrayList to store the non-empty elements.\n* Size: The size of the ArrayList is calculated after adding all non-empty elements.\n* Array creation: A new array is created to store the non-empty elements in the ArrayList.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "String",
              "description": "a new array of non-empty strings containing the elements from the original input array.",
              "complex_type": false
            },
            "name": "removeEmptyStrings",
            "code": "public static String[] removeEmptyStrings(String[] data) {\n\t\tArrayList<String> result = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tif (!data[i].equals(\"\"))\n\t\t\t\tresult.add(data[i]);\n\n\t\tString[] res = new String[result.size()];\n\t\tresult.toArray(res);\n\n\t\treturn res;\n\t}",
            "location": {
              "start": 204,
              "insert": 178,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 177,
                "end": 203
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 26
          },
          {
            "id": "5dc3600a-08eb-5baf-2646-72c784b467fc",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "transforms an array of integers into an integer array with the same length, by simply copying the elements from the original array to the new one.",
            "params": [
              {
                "name": "data",
                "type_name": "Integer[]",
                "description": "0-based integer array that is converted to an integer array of the same length by copying each element.\n\n* It is an array of integers, denoted by `[data.length]`.\n* It has a zero-based index, meaning that the first element in the array is at index 0.\n* Each element in the array is an integer value, represented as a primitive type `Integer`.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "an integer array with the same length as the input `data` array, containing the corresponding integer values.",
              "complex_type": false
            },
            "name": "toIntArray",
            "code": "public static int[] toIntArray(Integer[] data) {\n\t\tint[] result = new int[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}",
            "location": {
              "start": 230,
              "insert": 217,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 216,
                "end": 229
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 13
          },
          {
            "id": "7c125b70-347d-85ab-0945-3a211f4134dd",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "converts a list of integers to an integer array with the same size as the list. It uses a loop to copy each element from the list to the corresponding position in the array.",
            "params": [
              {
                "name": "data",
                "type_name": "List<Integer>",
                "description": "List of integers that will be converted to an integer array by the `toIntArray()` method.\n\n1. The `List<Integer>` type indicates that `data` is a collection of integers.\n2. The size of `data` can be retrieved using the `size()` method.\n3. The `get()` method is used to access individual elements of `data`.\n4. The `int[]` type of the returned value indicates that the function will return an array of integers.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "an integer array containing the elements of the input list.",
              "complex_type": false
            },
            "name": "toIntArray",
            "code": "public static int[] toIntArray(List<Integer> data) {\n\t\tint[] result = new int[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}",
            "location": {
              "start": 254,
              "insert": 239,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 238,
                "end": 253
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 15
          },
          {
            "id": "4f9e5892-1a39-0195-3a4a-74fcf651af0a",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "converts a `Float` array to an equivalent `float[]` array, copying each element from the input array to the output array.",
            "params": [
              {
                "name": "data",
                "type_name": "Float[]",
                "description": "Float array to be converted into a float array.\n\n* `data` is an array of `Float`.\n* Its length is defined by an integer variable `data.length`.\n* Each element in the array is accessed using the index number `i` from 0 to `data.length - 1`.\n\nThe function then returns a new array of `float` with the same elements as `data`.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a new float array with the same elements as the input `data` array.",
              "complex_type": false
            },
            "name": "toFloatArray",
            "code": "public static float[] toFloatArray(Float[] data) {\n\t\tfloat[] result = new float[data.length];\n\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t\tresult[i] = data[i];\n\n\t\treturn result;\n\t}",
            "location": {
              "start": 278,
              "insert": 263,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 262,
                "end": 277
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 15
          },
          {
            "id": "242b39a5-82f0-af90-0b44-1c2257540073",
            "ancestors": [
              "0ce56027-afaa-8eaa-2747-4d2262d256a7"
            ],
            "type": "function",
            "description": "takes a list of `Float` objects and returns an array of the same size containing the corresponding values.",
            "params": [
              {
                "name": "data",
                "type_name": "List<Float>",
                "description": "List of Float values that are to be converted into an array of float values.\n\n* `List<Float>` represents an array-like data structure that stores floating-point numbers.\n* `size()` returns the number of elements in the list.\n* `get(i)` retrieves the `i`-th element from the list and assigns it to the corresponding index in the output array.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a float array containing the values of the input list.",
              "complex_type": false
            },
            "name": "toFloatArray",
            "code": "public static float[] toFloatArray(List<Float> data) {\n\t\tfloat[] result = new float[data.size()];\n\n\t\tfor (int i = 0; i < data.size(); i++)\n\t\t\tresult[i] = data.get(i);\n\n\t\treturn result;\n\t}",
            "location": {
              "start": 303,
              "insert": 287,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 286,
                "end": 302
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 16
          }
        ]
      }
    }
  },
  {
    "name": "Matrix4f.java",
    "path": "src/com/ch/math/Matrix4f.java",
    "content": {
      "structured": {
        "description": "",
        "diagram": "digraph G {\n    label=\"com.ch.math.Matrix4f\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        Chunk\n    }\n    subgraph cluster_1 {\n        label=\"math\"\n        color=\"#33363A\"\n        Vector3f\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Matrix4f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Quaternion\n    }\n    Camera\n    Shader\n    Transform\n    Camera3D\n    CameraStruct\n    Chunk -> Matrix4f \n    Transform -> Matrix4f \n    Matrix4f -> Matrix4f [style=\"dashed\"]\n    Quaternion -> Matrix4f \n    Matrix4f -> Shader \n    Vector3f -> Matrix4f \n    Matrix4f -> Matrix4f \n    Camera3D -> Matrix4f \n    Vector3f -> Matrix4f [style=\"dashed\"]\n    CameraStruct -> Matrix4f [style=\"dashed\"]\n    Camera -> Matrix4f \n}\n",
        "items": [
          {
            "id": "bb0d8f02-0948-4ded-b03e-5420554c785c",
            "ancestors": [],
            "type": "function",
            "name": "initTranslation",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 52,
              "start": 77
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "x",
                "type": "float"
              },
              {
                "name": "y",
                "type": "float"
              },
              {
                "name": "z",
                "type": "float"
              }
            ],
            "code": "public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}",
            "skip": false,
            "docLength": 25,
            "length": 21,
            "comment": {
              "description": "Initializes a matrix with translation values for x, y, and z coordinates. It modifies the matrix elements to represent the translation vectors and returns the modified matrix reference.",
              "params": [
                {
                  "name": "x",
                  "type": "float",
                  "description": "3D translation amount in the x-axis direction."
                },
                {
                  "name": "y",
                  "type": "float",
                  "description": "2D translation component in the returned matrix, where it is assigned to the value of `data[1][1]`."
                },
                {
                  "name": "z",
                  "type": "float",
                  "description": "3rd coordinate of the translation vector and is used to set the z-component of the resulting matrix."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a modified Matrix4f object with translated coordinates."
              }
            }
          },
          {
            "id": "cbb03b61-cce4-4155-8256-e54d0aec5f70",
            "ancestors": [],
            "type": "function",
            "name": "initRotation",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 99,
              "start": 130
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "x",
                "type": "float"
              },
              {
                "name": "y",
                "type": "float"
              },
              {
                "name": "z",
                "type": "float"
              }
            ],
            "code": "public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}",
            "skip": false,
            "docLength": 31,
            "length": 64,
            "comment": {
              "description": "Generates a rotation matrix based on three Euler angles (x, y, and z) using the Rodrigues formula. It returns a Matrix4f object representing the rotation.",
              "params": [
                {
                  "name": "x",
                  "type": "float",
                  "description": "3D rotation around the x-axis."
                },
                {
                  "name": "y",
                  "type": "float",
                  "description": "2D rotation angle around the y-axis, which is used to compute the rotation matrix for the x and z axes."
                },
                {
                  "name": "z",
                  "type": "float",
                  "description": "3D rotation axis around which the matrix will be rotated, and its value is used to calculate the cosine and sine of the angle of rotation in radians, which are then applied to the creation of the rotation matrix."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a new Matrix4f object representing the rotation matrix."
              }
            }
          },
          {
            "id": "f54fbf9f-4673-430b-88d7-f3d1744b7ad7",
            "ancestors": [],
            "type": "function",
            "name": "initScale",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 194,
              "start": 219
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "x",
                "type": "float"
              },
              {
                "name": "y",
                "type": "float"
              },
              {
                "name": "z",
                "type": "float"
              }
            ],
            "code": "public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}",
            "skip": false,
            "docLength": 25,
            "length": 20,
            "comment": {
              "description": "Sets the scale factor for a matrix, assigning values to the respective elements in the data array.",
              "params": [
                {
                  "name": "x",
                  "type": "float",
                  "description": "3D scale factor for the X-axis of the matrix."
                },
                {
                  "name": "y",
                  "type": "float",
                  "description": "2nd element of the scaling factor for the matrix, which is applied to the rows of the matrix."
                },
                {
                  "name": "z",
                  "type": "float",
                  "description": "3rd element of the scaling matrix and sets its value to the input parameter, which is used to scale the 3D coordinates of the object being transformed."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a modified instance of the `Matrix4f` class."
              }
            }
          },
          {
            "id": "0ea127f7-147e-4cd8-acc5-a68e98e975e7",
            "ancestors": [],
            "type": "function",
            "name": "initPerspective",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 239,
              "start": 274
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "fov",
                "type": "float"
              },
              {
                "name": "aspectRatio",
                "type": "float"
              },
              {
                "name": "zNear",
                "type": "float"
              },
              {
                "name": "zFar",
                "type": "float"
              }
            ],
            "code": "public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}",
            "skip": false,
            "docLength": 35,
            "length": 23,
            "comment": {
              "description": "Initializes a matrix for a perspective projection, where the view frustum is defined by the field of view (fov), aspect ratio, and near and far distances.",
              "params": [
                {
                  "name": "fov",
                  "type": "float",
                  "description": "field of view (FOV) of the perspective projection, which determines the angular range of vision visible in the generated matrix."
                },
                {
                  "name": "aspectRatio",
                  "type": "float",
                  "description": "2D aspect ratio of the view frustum, which determines the shape of the perspective projection and affects the field of view."
                },
                {
                  "name": "zNear",
                  "type": "float",
                  "description": "near plane distance in the perspective projection matrix, which determines how far the image appears to be from the viewer."
                },
                {
                  "name": "zFar",
                  "type": "float",
                  "description": "4th coordinate of the perspective matrix and sets the distance from the eye point to the farthest point in the image, which is used in calculation of the Z-range."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a `Matrix4f` object with pre-multiplied values for perspective projection."
              }
            }
          },
          {
            "id": "01c7c0ea-6644-4933-8a1e-a66758640b61",
            "ancestors": [],
            "type": "function",
            "name": "initOrthographic",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 298,
              "start": 335
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "left",
                "type": "float"
              },
              {
                "name": "right",
                "type": "float"
              },
              {
                "name": "bottom",
                "type": "float"
              },
              {
                "name": "top",
                "type": "float"
              },
              {
                "name": "near",
                "type": "float"
              },
              {
                "name": "far",
                "type": "float"
              }
            ],
            "code": "public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}",
            "skip": false,
            "docLength": 37,
            "length": 24,
            "comment": {
              "description": "Sets up a 4x4 matrix representing an orthographic projection, with the specified parameters determining the size and orientation of the projection.",
              "params": [
                {
                  "name": "left",
                  "type": "float",
                  "description": "left edge of the orthographic projection."
                },
                {
                  "name": "right",
                  "type": "float",
                  "description": "right edge of the orthographic projection, which is used to calculate the values for the matrix's data elements."
                },
                {
                  "name": "bottom",
                  "type": "float",
                  "description": "2D coordinate of the bottom-left corner of the orthographic projection, which is used to calculate the height of the projection."
                },
                {
                  "name": "top",
                  "type": "float",
                  "description": "2D coordinate of the top edge of the orthographic projection, which is used to calculate the corresponding 3D coordinate in the matrix."
                },
                {
                  "name": "near",
                  "type": "float",
                  "description": "near plane of the orthographic projection, and it determines the distance from the viewer to the near side of the projection."
                },
                {
                  "name": "far",
                  "type": "float",
                  "description": "3D distance from the viewer to the near end of the orthographic projection, and it is used to calculate the depth aspect of the projected matrix."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a `Matrix4f` object with the necessary transformation values for orthographic projection."
              }
            }
          },
          {
            "id": "618345fa-681f-469e-90e4-6179a418d617",
            "ancestors": [],
            "type": "function",
            "name": "initRotation",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 360,
              "start": 402
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "forward",
                "type": "Vector3f"
              },
              {
                "name": "up",
                "type": "Vector3f"
              }
            ],
            "code": "public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}",
            "skip": false,
            "docLength": 42,
            "length": 10,
            "comment": {
              "description": "Generates a rotation matrix from three vectors: `forward`, `up`, and `r`. The resulting matrix rotates an object around its `forward` axis while maintaining its orientation relative to the `up` axis.",
              "params": [
                {
                  "name": "forward",
                  "type": "Vector3f",
                  "description": "3D direction that the rotation will be applied to."
                },
                {
                  "name": "up",
                  "type": "Vector3f",
                  "description": "2D plane that defines the rotation axis, which is used to create a rotation matrix that aligns with the given 3D vector."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a Matrix4f object representing a rotation matrix based on the given vector inputs."
              }
            }
          },
          {
            "id": "876798a0-2dbe-4bd1-bee2-e8bb8f096160",
            "ancestors": [],
            "type": "function",
            "name": "initRotation",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 413,
              "start": 459
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "forward",
                "type": "Vector3f"
              },
              {
                "name": "up",
                "type": "Vector3f"
              },
              {
                "name": "right",
                "type": "Vector3f"
              }
            ],
            "code": "public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}",
            "skip": false,
            "docLength": 46,
            "length": 24,
            "comment": {
              "description": "Sets up a rotation matrix based on three input vectors representing the x, y, and z components of the rightward, upward, and forward directions. The resulting matrix is returned.",
              "params": [
                {
                  "name": "forward",
                  "type": "Vector3f",
                  "description": "3D vector that points in the direction of rotation, which is used to initialize the X component of the rotation matrix."
                },
                {
                  "name": "up",
                  "type": "Vector3f",
                  "description": "3D unit vector pointing upwards, which is used to initialize the rotation matrix's third column."
                },
                {
                  "name": "right",
                  "type": "Vector3f",
                  "description": "3D right vector of the rotation, which is used to construct the rotation matrix."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a `Matrix4f` object representing a rotation matrix based on the provided vectors."
              }
            }
          },
          {
            "id": "5c31b9e2-cec4-4f75-98d4-c41fd7c0bb0d",
            "ancestors": [],
            "type": "function",
            "name": "transform",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 484,
              "start": 516
            },
            "returns": "Vector3f",
            "params": [
              {
                "name": "r",
                "type": "Vector3f"
              }
            ],
            "code": "public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}",
            "skip": false,
            "docLength": 32,
            "length": 4,
            "comment": {
              "description": "Takes a `Vector3f` argument `r` and returns a new `Vector3f` object with transformed coordinates based on a set of coefficients `data`.",
              "params": [
                {
                  "name": "r",
                  "type": "Vector3f",
                  "description": "3D vector that transforms the output of the `transform()` function."
                }
              ],
              "returns": {
                "type": "Vector3f",
                "description": "a new vector with the result of multiplying each element of the input vector `r` by the corresponding elements of a given matrix `data`, and adding the resulting values."
              }
            }
          },
          {
            "id": "d60603d9-b55b-4e9c-8595-7ae178602758",
            "ancestors": [],
            "type": "function",
            "name": "mul",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 522,
              "start": 542
            },
            "returns": "Matrix4f",
            "params": [
              {
                "name": "r",
                "type": "Matrix4f"
              }
            ],
            "code": "public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}",
            "skip": false,
            "docLength": 20,
            "length": 11,
            "comment": {
              "description": "Takes a second matrix `r` as input and multiplies it element-wise with the current matrix, storing the result in the current matrix.",
              "params": [
                {
                  "name": "r",
                  "type": "Matrix4f",
                  "description": "4x4 matrix to be multiplied with the current matrix, resulting in the updated matrix."
                }
              ],
              "returns": {
                "type": "Matrix4f",
                "description": "a matrix with the product of the input matrices element-wise."
              }
            }
          },
          {
            "id": "1a946a0d-f594-47e8-bf7f-6da0c0e51095",
            "ancestors": [],
            "type": "function",
            "name": "get",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 597,
              "start": 608
            },
            "returns": "float",
            "params": [
              {
                "name": "x",
                "type": "int"
              },
              {
                "name": "y",
                "type": "int"
              }
            ],
            "code": "public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}",
            "skip": false,
            "docLength": 11,
            "length": 3,
            "comment": {
              "description": "Returns the value stored at a specific position in an array, given the coordinates `x` and `y`.",
              "params": [
                {
                  "name": "x",
                  "type": "int",
                  "description": "1D position of a pixel in the image data within the range of [0, dimensions-1]."
                },
                {
                  "name": "y",
                  "type": "int",
                  "description": "2nd dimension of the data array that is being accessed by the function."
                }
              ],
              "returns": {
                "type": "float",
                "description": "a floating-point value representing the value at the specified position in the 2D array `data`."
              }
            }
          },
          {
            "id": "0be49c8c-e487-45b2-9df5-ccd0b163d002",
            "ancestors": [],
            "type": "function",
            "name": "SetM",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 611,
              "start": 624
            },
            "returns": false,
            "params": [
              {
                "name": "data",
                "type": "float[][]"
              }
            ],
            "code": "public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}",
            "skip": false,
            "docLength": 13,
            "length": 3,
            "comment": {
              "description": "Sets the value of the object's `data` field to the input parameter `data`.",
              "params": [
                {
                  "name": "data",
                  "type": "float[][]",
                  "description": "2D array of float values that will be stored in the class instance variable `data`."
                }
              ],
              "returns": null
            }
          },
          {
            "id": "a5bb54a7-f6bc-400c-8047-0c8f31f47e5e",
            "ancestors": [],
            "type": "function",
            "name": "set",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 627,
              "start": 638
            },
            "returns": false,
            "params": [
              {
                "name": "x",
                "type": "int"
              },
              {
                "name": "y",
                "type": "int"
              },
              {
                "name": "value",
                "type": "float"
              }
            ],
            "code": "public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}",
            "skip": false,
            "docLength": 11,
            "length": 3,
            "comment": {
              "description": "Sets a value at a specific coordinate within an array of integers.",
              "params": [
                {
                  "name": "x",
                  "type": "int",
                  "description": "0-based index of a pixel in the grid, which is used to determine the specific location within the grid where the `value` parameter is assigned."
                },
                {
                  "name": "y",
                  "type": "int",
                  "description": "2nd dimension of the data array being manipulated, and it corresponds to the vertical position of the cell being updated with the provided value."
                },
                {
                  "name": "value",
                  "type": "float",
                  "description": "3D point value that is assigned to the corresponding position in the `data` array."
                }
              ],
              "returns": null
            }
          }
        ]
      }
    }
  },
  {
    "name": "Quaternion.java",
    "path": "src/com/ch/math/Quaternion.java",
    "content": {
      "structured": {
        "description": "A `Quaternion` class that represents 4D quaternions in a graphical user interface (GUI) application. The class has several methods for manipulating the x, y, z, and w components of a quaternion, as well as methods for comparing quaternions and retrieving their component values. The code also defines a `set` method that allows a quaternion to be set to the values of another quaternion, and an `equals` method that compares two quaternions for equality based on their component values.",
        "diagram": "digraph G {\n    label=\"com.ch.math.Quaternion\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        Matrix4f\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Quaternion [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Vector3f\n    }\n    Transform\n    Quaternion -> Vector3f \n    Quaternion -> Quaternion \n    Quaternion -> Quaternion [style=\"dashed\"]\n    Quaternion -> Transform \n    Quaternion -> Matrix4f \n    Quaternion -> Vector3f [style=\"dashed\"]\n    Vector3f -> Quaternion [style=\"dashed\"]\n    Transform -> Quaternion \n    Vector3f -> Quaternion \n}\n",
        "items": [
          {
            "id": "19e8e215-53aa-4a8f-084d-0452ec3fe116",
            "ancestors": [],
            "type": "function",
            "description": "is a Java class that represents a quaternion as a mathematical object. It has several methods for calculating and manipulating quaternions, including setting the values of its components, retrieving the values of its components, and comparing two quaternions for equality. The class also provides a few instance variables for storing the values of its components.",
            "name": "Quaternion",
            "code": "public class Quaternion {\n\n\tprivate float x;\n\tprivate float y;\n\tprivate float z;\n\tprivate float w;\n\n\tpublic Quaternion() {\n\t\tthis(0, 0, 0, 0);\n\t}\n\n\t\n\tpublic Quaternion(float w, float x, float y, float z) {\n\t\tthis.w = w;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\tpublic Quaternion(Vector3f axis, float angle) {\n\t\tfloat sinHalfAngle = (float) Math.sin(angle / 2);\n\t\tfloat cosHalfAngle = (float) Math.cos(angle / 2);\n\n\t\tthis.x = axis.getX() * sinHalfAngle;\n\t\tthis.y = axis.getY() * sinHalfAngle;\n\t\tthis.z = axis.getZ() * sinHalfAngle;\n\t\tthis.w = cosHalfAngle;\n\t}\n\n\t/**\n\t * calculates the magnitude of a 3D vector by taking the square root of the sum of\n\t * its x, y, and z components.\n\t * \n\t * @returns the square root of the sum of the squares of the coordinates of a 3D point.\n\t */\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}\n\n\t/**\n\t * normalizes a given quaternion by dividing each component by its length, resulting\n\t * in a new quaternion with a length of 1.\n\t * \n\t * @returns a normalized quaternion representation of the original input quaternion.\n\t * \n\t * The function returns a new Quaternion instance with the given input's length\n\t * normalized. The length is calculated using the `length()` method and is used to\n\t * scale the quaternion components. As a result, the quaternion is now in a unit form,\n\t * making it more useful for various mathematical operations.\n\t */\n\tpublic Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}\n\n\t/**\n\t * generates a new quaternion object by providing the original quaternion's scalar\n\t * component and the negative of each vector component.\n\t * \n\t * @returns a new quaternion object with the conjugate of the input quaternion's coordinates.\n\t * \n\t * \t- The output is a Quaternion object, representing the conjugate of the input Quaternion.\n\t * \t- The conjugate of a Quaternion is defined as the vector that is obtained by\n\t * multiplying the original Quaternion by its own conjugate.\n\t * \t- The conjugate of a Quaternion has the same magnitude as the original Quaternion,\n\t * but its direction is reversed. In other words, if the original Quaternion points\n\t * in the direction of a certain axis, then the conjugate Quaternion points in the\n\t * opposite direction of that axis.\n\t */\n\tpublic Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}\n\n\t/**\n\t * multiplies a quaternion by a scalar value and returns a new quaternion with the product.\n\t * \n\t * @param r scalar value that is multiplied with the quaternion's components to produce\n\t * the resulting quaternion.\n\t * \n\t * @returns a quaternion object representing the product of the original quaternion\n\t * and the scalar value `r`.\n\t */\n\tpublic Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}\n\n\t/**\n\t * multiplies a quaternion by another quaternion, calculating the product of the two\n\t * rotations and storing it in a new quaternion object.\n\t * \n\t * @param r quaternion to be multiplied with the current quaternion, and its values\n\t * are used to calculate the output quaternion's components.\n\t * \n\t * \t- `w`: The real part of the quaternion representation.\n\t * \t- `x`, `y`, `z`: The imaginary parts of the quaternion representation.\n\t * \n\t * @returns a new quaternion instance representing the product of the input quaternions.\n\t * \n\t * \t- `w_`: The magnitude (or length) of the resultant quaternion, which is equal to\n\t * the product of the magnitudes of the input quaternions.\n\t * \t- `x_`, `y_`, and `z_`: The three components of the resultant quaternion, which\n\t * are obtained by multiplying the corresponding components of the input quaternions.\n\t * These components represent the rotational part of the resultant quaternion.\n\t */\n\tpublic Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\t/**\n\t * multiplies a quaternion by a vector, computing the resulting quaternion's coordinates\n\t * in a straightforward manner.\n\t * \n\t * @param r 3D vector that is multiplied with the quaternion.\n\t * \n\t * \t- `r` is a `Vector3f` instance representing a 3D vector with real values for `x`,\n\t * `y`, and `z`.\n\t * \n\t * @returns a quaternion representing the result of multiplying the input vector `r`\n\t * by the quaternion represented by the function parameters.\n\t * \n\t * The `Quaternion` object returned has four components: w_, x_, y_, and z_. These\n\t * components represent the product of the input quaternion and the vector passed as\n\t * an argument.\n\t * \n\t * The value of w_ is equal to the dot product of the input quaternion's w component\n\t * and the argument vector's x, y, and z components, minus the product of the input\n\t * quaternion's x, y, and z components and the argument vector's x, y, and z components.\n\t * \n\t * The value of x_ is equal to the dot product of the input quaternion's x component\n\t * and the argument vector's x, y, and z components, plus the product of the input\n\t * quaternion's w component and the argument vector's y component, minus the product\n\t * of the input quaternion's y component and the argument vector's x component.\n\t * \n\t * The value of y_ is equal to the dot product of the input quaternion's y component\n\t * and the argument vector's x, y, and z components, plus the product of the input\n\t * quaternion's w component and the argument vector's z component, minus the product\n\t * of the input quaternion's z component and the argument vector's y component.\n\t * \n\t * The value of z_ is equal to the dot product of the input quaternion's z component\n\t * and the argument vector's x, y, and z components, plus the product of the input\n\t * quaternion's w component and the argument vector's x component, minus the product\n\t * of the input quaternion's x component and the argument vector's y component.\n\t */\n\tpublic Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\t/**\n\t * takes a `Quaternion` object `r` as input and returns a new `Quaternion` object\n\t * representing the difference between the two quaternions.\n\t * \n\t * @param r quaternion to be subtracted from the current quaternion, resulting in a\n\t * new quaternion that represents the difference between the two.\n\t * \n\t * \t- `w`: The real part of the quaternion.\n\t * \t- `x`, `y`, and `z`: The imaginary parts of the quaternion, representing the angle\n\t * and direction of rotation around the x, y, and z axes, respectively.\n\t * \n\t * @returns a new quaternion representing the difference between the input quaternion\n\t * and the reference quaternion.\n\t * \n\t * \t- The `Quaternion` object represents the difference between two quaternions, which\n\t * means that it holds the residual value after subtracting the right-hand side\n\t * quaternion from the left-hand side quaternion.\n\t * \t- The values of the four components (w, x, y, and z) represent the residual values\n\t * in each dimension.\n\t * \t- The order of the quaternions is preserved in the returned object, meaning that\n\t * the resulting quaternion has the same orientation as the original quaternion.\n\t */\n\tpublic Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}\n\n\t/**\n\t * takes a `Quaternion` object `r` as input and returns a new `Quaternion` object\n\t * representing the sum of the two quaternions. The returned quaternion has the same\n\t * components (w, x, y, and z) as the original quaternion plus the corresponding\n\t * components of the input quaternion.\n\t * \n\t * @param r quaternion to be added to the current quaternion.\n\t * \n\t * The `Quaternion` class represents a quaternion in 3D space, which is a mathematical\n\t * object that can be used to rotate points or vectors in 3D space. The instance\n\t * variable `w` represents the real part of the quaternion, while `x`, `y`, and `z`\n\t * represent the imaginary parts.\n\t * \n\t * @returns a new quaternion with the sum of the inputs' coefficients.\n\t * \n\t * \t- The output is a `Quaternion` instance representing the sum of the input arguments.\n\t * \t- The `W`, `X`, `Y`, and `Z` components of the output are calculated by adding\n\t * the corresponding components of the input arguments.\n\t * \t- The output has the same orientation as the input, but with the sum of their values.\n\t */\n\tpublic Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}\n\n\t/**\n\t * takes a quaternion representation of a rotation and returns a corresponding 4x4\n\t * homogeneous matrix.\n\t * \n\t * @returns a 4x4 rotation matrix.\n\t * \n\t * \t- The return type is `Matrix4f`, which represents a 4x4 homogeneous transformation\n\t * matrix.\n\t * \t- The method `initRotation` is called to create a rotation matrix from the forward,\n\t * up, and right vectors.\n\t * \t- The forward vector has a magnitude of 2.0f and directional components that are\n\t * twice the corresponding elements of the input matrix.\n\t * \t- The up vector has a magnitude of 1.0f and directional components that are equal\n\t * to the corresponding elements of the input matrix minus twice the corresponding\n\t * elements of the forward vector.\n\t * \t- The right vector has a magnitude of 1.0f and directional components that are\n\t * equal to the corresponding elements of the input matrix minus the corresponding\n\t * elements of the up vector.\n\t * \n\t * Overall, the `toRotationMatrix` function returns a rotation matrix that can be\n\t * used to perform rotations in 3D space based on the input vectors.\n\t */\n\tpublic Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}\n\n\t/**\n\t * computes the dot product of two quaternions, returning a scalar value.\n\t * \n\t * @param r 4D quaternion value to which the `x`, `y`, `z`, and `w` components of the\n\t * current quaternion are dot-producted, resulting in a scalar value.\n\t * \n\t * \t- `x`, `y`, `z`, and `w` are the components of the Quaternion structure.\n\t * \t- `getX()`, `getY()`, `getZ()`, and `getW()` are methods that return the corresponding\n\t * component values of `r`.\n\t * \n\t * @returns a floating-point number representing the dot product of the input quaternion\n\t * and another quaternion argument.\n\t */\n\tpublic float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}\n\n\t/**\n\t * computes a linear interpolation between two quaternions based on the given factor,\n\t * and returns the result normalized to have length equal to the maximum value of the\n\t * input quaternions.\n\t * \n\t * @param dest 4-dimensional vector that the function will be lerped to, with its\n\t * components being updated based on the provided `lerpFactor` and `shortest` parameters.\n\t * \n\t * \t- `dest`: A Quaternion object representing the destination point in 3D space. It\n\t * has four components: `w`, `x`, `y`, and `z`.\n\t * \t- `lerpFactor`: A floating-point value representing the interpolation factor\n\t * between the current position and the destination position.\n\t * \t- `shortest`: An optional boolean value indicating whether to shorten the\n\t * interpolated quaternion to avoid overshooting. If set to `true`, the function will\n\t * adjust the destination quaternion if it would result in a negative dot product\n\t * with the original quaternion.\n\t * \n\t * @param lerpFactor 0-1 interpolating factor used to blend between the starting and\n\t * ending quaternions.\n\t * \n\t * @param shortest direction of rotation to be performed, and when set to `true`, it\n\t * forces the function to return the shortest quaternion possible to achieve the\n\t * desired rotation, even if it results in a non-normalized quaternion.\n\t * \n\t * @returns a quaternion that represents the intermediate result of interpolating\n\t * between two given quaternions using the linear interpolation formula.\n\t * \n\t * \t- The output is a Quaternion object, representing a linear interpolation between\n\t * the input `dest` and the inverse of the input multiplied by the given `lerpFactor`.\n\t * \t- If the input `shortest` is set to true, then the output will be corrected to\n\t * ensure that the resulting quaternion has a dot product with the input `dest` closer\n\t * to zero. This is done by multiplying the input by its conjugate and subtracting\n\t * it from the input.\n\t * \t- The returned Quaternion object has four components representing the x, y, z,\n\t * and w axes of the quaternion rotation.\n\t */\n\tpublic Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}\n\n\t/**\n\t * computes a quaternion interpolation between two given quaternions, weighted by a\n\t * factor and shortest path if necessary. It first computes the dot product of the\n\t * two quaternions and uses it to determine the interpolation direction and angle.\n\t * Then it applies the interpolation using the quaternion multiplication and adds the\n\t * destination quaternion to obtain the final result.\n\t * \n\t * @param dest 4D quaternion value that is the result of the interpolation, and it\n\t * is modified based on the `shortest` parameter to ensure the interpolated quaternion\n\t * is properly oriented.\n\t * \n\t * \t- `dest.getW()`: represents the scalar component of the quaternion along the z-axis.\n\t * \t- `dest.getX()` and `dest.getY()`: represent the scalar components of the quaternion\n\t * along the x and y axes, respectively.\n\t * \t- `dest.getZ()`: represents the scalar component of the quaternion along the z-axis.\n\t * \t- `correctedDest`: is a new quaternion instance created by adjusting the input\n\t * `dest` if the shortest route criterion is met. Its properties are unchanged from\n\t * `dest`.\n\t * \n\t * @param lerpFactor 0-to-1 value that determines how much the quaternion should be\n\t * interpolated between the source and destination values.\n\t * \n\t * @param shortest shortest path between the two quaternions and when it is set to\n\t * `true`, the function calculates the shortest path by reversing the quaternion if\n\t * the cosine of the dot product is negative.\n\t * \n\t * @returns a new Quaternion instance representing the linear interpolation of the\n\t * original Quaternion based on the given lerp factor and shortest path calculation.\n\t * \n\t * \t- The `Quaternion` object is constructed by multiplying the source quaternion by\n\t * a factor and adding the destination quaternion.\n\t * \t- The `srcFactor` and `destFactor` variables represent the interpolation factors\n\t * between the source and destination quaternions, respectively. These factors are\n\t * computed using the sine of the angle between the source and destination quaternions,\n\t * scaled by the magnitude of the source quaternion.\n\t * \t- The returned quaternion represents a linear combination of the source and\n\t * destination quaternions, with the weights determined by the `lerpFactor` parameter.\n\t */\n\tpublic Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}\n\n\t// From Ken Shoemake's \"Quaternion Calculus and Fast Animation\" article\n\tpublic Quaternion(Matrix4f rot) {\n\t\tfloat trace = rot.get(0, 0) + rot.get(1, 1) + rot.get(2, 2);\n\n\t\tif (trace > 0) {\n\t\t\tfloat s = 0.5f / (float) Math.sqrt(trace + 1.0f);\n\t\t\tw = 0.25f / s;\n\t\t\tx = (rot.get(1, 2) - rot.get(2, 1)) * s;\n\t\t\ty = (rot.get(2, 0) - rot.get(0, 2)) * s;\n\t\t\tz = (rot.get(0, 1) - rot.get(1, 0)) * s;\n\t\t} else {\n\t\t\tif (rot.get(0, 0) > rot.get(1, 1) && rot.get(0, 0) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(0, 0) - rot.get(1, 1) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(1, 2) - rot.get(2, 1)) / s;\n\t\t\t\tx = 0.25f * s;\n\t\t\t\ty = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\tz = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t} else if (rot.get(1, 1) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(1, 1) - rot.get(0, 0) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(2, 0) - rot.get(0, 2)) / s;\n\t\t\t\tx = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\ty = 0.25f * s;\n\t\t\t\tz = (rot.get(2, 1) + rot.get(1, 2)) / s;\n\t\t\t} else {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(2, 2) - rot.get(0, 0) - rot.get(1, 1));\n\t\t\t\tw = (rot.get(0, 1) - rot.get(1, 0)) / s;\n\t\t\t\tx = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t\ty = (rot.get(1, 2) + rot.get(2, 1)) / s;\n\t\t\t\tz = 0.25f * s;\n\t\t\t}\n\t\t}\n\n\t\tfloat length = (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t\tx /= length;\n\t\ty /= length;\n\t\tz /= length;\n\t\tw /= length;\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees around the x-axis to create a forward vector,\n\t * returning a new Vector3f object.\n\t * \n\t * @returns a vector pointing in the forward direction of the object's rotation.\n\t * \n\t * The output is a `Vector3f` object representing the direction from the origin to\n\t * the current position of the rotated object. The vector's coordinates represent the\n\t * x, y, and z components of the forward direction, respectively.\n\t */\n\tpublic Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}\n\n\t/**\n\t * rotates a `Vector3f` instance by 90 degrees around the z-axis, resulting in a\n\t * vector that points backwards from the original position.\n\t * \n\t * @returns a rotated vector with a magnitude of -1.\n\t * \n\t * The `Vector3f` object returned by the function is a transformed version of the\n\t * original vector, where it has been rotated by 90 degrees around the x-axis. This\n\t * means that the x-coordinate of the vector remains unchanged, while the y-coordinate\n\t * is shifted to the negative z-axis, and the z-coordinate is shifted to the positive\n\t * y-axis.\n\t */\n\tpublic Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees around the z-axis, resulting in a vector pointing\n\t * upward from the original position.\n\t * \n\t * @returns a rotated version of the original vector, pointing upwards.\n\t * \n\t * The `Vector3f` object returned represents the upward direction from the current\n\t * position of the entity. The rotation is performed using the `rotate` method, which\n\t * takes the current position of the entity as its argument and returns a new `Vector3f`\n\t * object in the rotated position.\n\t */\n\tpublic Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}\n\n\t/**\n\t * rotates a 3D vector by 90 degrees around the z-axis, resulting in a new vector\n\t * pointing downwards from the original position.\n\t * \n\t * @returns a rotated vector representing the downward direction.\n\t * \n\t * The output is a `Vector3f` object representing the downward direction from the\n\t * current position of the rotation axis.\n\t * \n\t * It has a magnitude of 0 in all dimensions, indicating that it points directly\n\t * downward from the origin.\n\t * \n\t * Its orientation is identical to the orientation of the rotation axis at the time\n\t * the function was called, as determined by the `rotate` method's rotation angle.\n\t */\n\tpublic Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees clockwise to produce a new vector pointing rightward\n\t * in the same coordinate system as the original vector.\n\t * \n\t * @returns a rotated vector representing the right component of the object's position.\n\t * \n\t * The output is a `Vector3f` object, which represents a 3D vector with three elements\n\t * representing x, y, and z components. The value of each element is determined by\n\t * multiplying the corresponding component of the original vector by a scalar value\n\t * of 1.\n\t */\n\tpublic Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees clockwise around the x-axis, resulting in a new\n\t * vector that points left from the original position.\n\t * \n\t * @returns a rotated vector with a magnitude of -1 and a direction that is perpendicular\n\t * to the original vector.\n\t * \n\t * The Vector3f object returned is a rotated version of the original vector, with its\n\t * x-axis component shifted to the left by a factor of -1.\n\t * \n\t * The y-axis and z-axis components remain unchanged.\n\t * \n\t * As a result, the new vector has a negative x-axis component, while the other two\n\t * components remain positive.\n\t */\n\tpublic Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}\n\n\t/**\n\t * sets the `x`, `y`, `z`, and `w` fields of a `Quaternion` object to the specified\n\t * values, returning the modified object.\n\t * \n\t * @param x 3D coordinate of the quaternion's axis of rotation.\n\t * \n\t * @param y 2D component of the quaternion, which is multiplied with the original\n\t * quaternion's `x` component to produce the new quaternion value.\n\t * \n\t * @param z 3rd component of the quaternion, which is updated to match the value\n\t * provided by the user.\n\t * \n\t * @param w 4th component of the quaternion, which is used to rotate the object along\n\t * the `z` axis.\n\t * \n\t * @returns a new instance of the `Quaternion` class with the updated values of `x`,\n\t * `y`, `z`, and `w`.\n\t * \n\t * The `Quaternion` object is updated with the new values for `x`, `y`, `z`, and `w`.\n\t * \n\t * After calling the `set` function, the resulting quaternion object retains its\n\t * original values for `x`, `y`, `z`, and `w`.\n\t * \n\t * The `set` function returns a reference to the same `Quaternion` object, allowing\n\t * for chaining of method calls.\n\t */\n\tpublic Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param eulerAngles - @see <a href=\"https://en.wikipedia.org/wiki/Euler_angles#Proper_Euler_angles\">Wikipedia's Article on Euler Angles</a> for a description\n\t *                    of their usage/definition.\n\t * @return The {@link Quaternion} associated with the Euler angles.\n\t */\n\tpublic static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}\n\n\t/**\n\t * sets the values of a quaternion object to those of another quaternion object.\n\t * \n\t * @param r 4-component quaternion that, when passed to the function, sets the\n\t * corresponding components of the output quaternion.\n\t * \n\t * \t- `getX()`, `getY()`, `getZ()`, and `getW()` - These are methods that retrieve\n\t * the real-valued components of a Quaternion object.\n\t * \n\t * @returns a reference to the same `Quaternion` object, with its fields updated with\n\t * the provided values.\n\t * \n\t * \t- The function sets the `x`, `y`, `z`, and `w` components of the `Quaternion`\n\t * object to those of the provided `r` argument.\n\t * \t- The function returns a reference to the modified `Quaternion` object, which is\n\t * the same as the original object passed as an argument.\n\t * \t- The function does not modify the original `Quaternion` object.\n\t */\n\tpublic Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}\n\n\t/**\n\t * retrieves the value of the `x` field, which is a `float` variable.\n\t * \n\t * @returns a floating-point value representing the variable `x`.\n\t */\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\t/**\n\t * sets the value of the `x` field of its object reference parameter to the passed\n\t * float value.\n\t * \n\t * @param x floating-point value that will be assigned to the `x` field of the class\n\t * instance being modified by the `setX()` method.\n\t */\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\t/**\n\t * returns the value of the `y` field.\n\t * \n\t * @returns the value of the `y` field.\n\t */\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\t/**\n\t * sets the value of the object's `y` field to the input `float` value.\n\t * \n\t * @param y 3D position of an object in the `setY()` method, specifying its new value\n\t * for storage within the class instance.\n\t */\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\t/**\n\t * retrieves the value of the `z` field.\n\t * \n\t * @returns a floating-point value representing the z component of an object's position.\n\t */\n\tpublic float getZ() {\n\t\treturn z;\n\t}\n\n\t/**\n\t * sets the value of the field `z` in a class to the argument passed as a float.\n\t * \n\t * @param z 2D coordinate of the current point in the graphical user interface (GUI)\n\t * and sets its corresponding field `this.z` to match the value provided.\n\t */\n\tpublic void setZ(float z) {\n\t\tthis.z = z;\n\t}\n\n\t/**\n\t * retrieves the value of the `w` field, which is a `float` variable representing a\n\t * width value.\n\t * \n\t * @returns the value of the `w` field.\n\t */\n\tpublic float getW() {\n\t\treturn w;\n\t}\n\n\t/**\n\t * sets the value of the field `w` to the argument passed as a float.\n\t * \n\t * @param w 2D width of an object being manipulated by the function.\n\t */\n\tpublic void setW(float w) {\n\t\tthis.w = w;\n\t}\n\n\t/**\n\t * compares two `Quaternion` objects and returns a boolean indicating whether they\n\t * are equal in terms of their x, y, z, and w components.\n\t * \n\t * @param r 4D quaternion to be compared with the current 4D quaternion.\n\t * \n\t * \t- `x`: A double variable representing the x-coordinate of the quaternion.\n\t * \t- `y`: A double variable representing the y-coordinate of the quaternion.\n\t * \t- `z`: A double variable representing the z-coordinate of the quaternion.\n\t * \t- `w`: A double variable representing the w-coordinate of the quaternion.\n\t * \n\t * @returns a boolean value indicating whether the Quaternion object is equal to\n\t * another Quaternion object.\n\t */\n\tpublic boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}\n\t\n}",
            "location": {
              "start": 13,
              "insert": 6,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 5,
                "end": 12
              }
            },
            "item_type": "class",
            "length": 681,
            "docLength": 7
          },
          {
            "id": "980155a9-b3df-42b4-d14c-da0e05cdf25d",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "calculates the magnitude or length of a 3D vector by squaring its components and taking the square root.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the square root of the sum of the squares of the component values of a vector.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(0.8f, 0.5f, 0.2f, 0.3f);\nSystem.out.println(\"Length of the quaternion is: \" + q1.length()); // Outputs: Length of the quaternion is: 1.0897644854881722\n",
              "description": ""
            },
            "name": "length",
            "code": "public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}",
            "location": {
              "start": 48,
              "insert": 42,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 41,
                "end": 47
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "9e13b682-c259-908b-b04c-a97dfe3a0666",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "normalizes a given quaternion by dividing each component by its length, resulting in a new quaternion with a length of 1.",
            "params": [],
            "returns": {
              "type_name": "instance",
              "description": "a normalized quaternion representation of the original quaternion.\n\nThe output is a Quaternion object, which represents a rotational transformation in 3D space.\nThe first component of the Quaternion (w / length) represents the direction of the rotation.\nThe second and third components (x / length and y / length) represent the magnitude of the rotation.\nThe fourth component (z / length) represents the axis of rotation.\nAll the components are normalized, meaning they have a length of 1 in the range of -1 to 1.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion(1, 2, 3, 4);\nSystem.out.println(\"Normalized quaternion: \" + q.normalized());\n",
              "description": "\nExpected output:\n"
            },
            "name": "normalized",
            "code": "public Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}",
            "location": {
              "start": 63,
              "insert": 52,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 51,
                "end": 62
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 11
          },
          {
            "id": "ec17c474-e3b3-fb93-4849-6e26689b5ba9",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "calculates the conjugate of a quaternion, which is a quaternion with its coordinates reversed.",
            "params": [],
            "returns": {
              "type_name": "Quaternion",
              "description": "a new quaternion object with the conjugate of its input values.\n\n* The returned object is of type `Quaternion`, indicating that it represents a quaternion value.\n* The `w` field of the returned object contains the magnitude (or length) of the quaternion.\n* The `-x`, `-y`, and `-z` fields contain the coordinates of the quaternion, which are negated in the returned object relative to their original values in the input quaternion.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Conjugation of a quaternion object\nQuaternion q1 = new Quaternion(x, y, z, w); // initializing a quaternion object with arbitrary values\nQuaternion q2 = q1.conjugate(); // calling the conjugate() method on the quaternion object and storing the result in q2\n\n// printing out the components of the conjugated quaternion object to check if they are correct\nSystem.out.println(\"Conjugated Quaternion:\");\nSystem.out.println(\"x = \" + q2.getX());\nSystem.out.println(\"y = \" + q2.getY());\nSystem.out.println(\"z = \" + q2.getZ());\nSystem.out.println(\"w = \" + q2.getW());\n",
              "description": ""
            },
            "name": "conjugate",
            "code": "public Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}",
            "location": {
              "start": 83,
              "insert": 69,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 68,
                "end": 82
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "9417aeea-c7ff-31b8-3b42-11097263ff4f",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "multiplies a quaternion by a scalar value and returns the result as another quaternion.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "scalar value that is multiplied with the quaternion's components to produce the result quaternion.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a new quaternion instance with the product of the input `r` multiplied by each component of the original quaternion.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(1, 0, 0, 0);\nfloat r = 2;\nq1.mul(r).print(); // Prints (4, 0, 0, 0)\n",
              "description": "\nThe input value 'r' is a float representing the scalar multiplication of the quaternion by itself. In this case, since the quaternion has components (1, 0, 0, 0), the output would be (2, 0, 0, 0)."
            },
            "name": "mul",
            "code": "public Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}",
            "location": {
              "start": 96,
              "insert": 87,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 86,
                "end": 95
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "60e76816-f896-cfa7-6841-19faf55efc5e",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "multiplies two quaternions element-wise, computing the product of their real and imaginary parts.",
            "params": [
              {
                "name": "r",
                "type_name": "Quaternion",
                "description": "4D quaternion to be multiplied with the current quaternion, resulting in a new quaternion output.\n\n* `w`: The magnitude (or length) of the quaternion.\n* `x`, `y`, and `z`: The coordinates of the quaternion.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a new quaternion instance with the product of two given quaternions.\n\n* The output is a new instance of the `Quaternion` class.\n* The `w_`, `x_,`, `y_`, and `z_` fields of the output represent the product of the `w`, `x`, `y`, and `z` fields of the input `r` Quaternion.\n* The order of the multiplication is (w, x, y, z) * (r.w, r.x, r.y, r.z).",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(0, 2, 3, 4);\nQuaternion q2 = new Quaternion(5, 6, 7, 8);\nQuaternion result = q1.mul(q2);\n",
              "description": "\nIn this example, the method mul would be used to multiply two quaternions together, resulting in a new quaternion object (result) that represents their product. The input arguments are two quaternion objects (q1 and q2) which are being multiplied together using the mul method."
            },
            "name": "mul",
            "code": "public Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}",
            "location": {
              "start": 118,
              "insert": 100,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 99,
                "end": 117
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 18
          },
          {
            "id": "7e7e1ca5-c1f3-ae97-e646-3ff859841c48",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "multiplies a quaternion by a vector and returns the result as a new quaternion.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to be multiplied with the quaternion.\n\n* `r` is an instance of `Vector3f`, which represents a 3D vector with three components (x, y, and z).\n* `getX()` and `getY()` are methods that retrieve the x and y coordinates of the vector, respectively.\n* `getZ()` is a method that retrieves the z coordinate of the vector.\n\nThe function then computes the product of the quaternion with `r` using the formula: `w_ = -x * r.getX() - y * r.getY() - z * r.getZ();`. The other three components (x_, y_, and z_) are computed as follows: `x_ = w * r.getX() + y * r.getZ() - z * r.getY();`, `y_ = w * r.getY() + x * r.getX() - z * r.getZ();`, and `z_ = w * r.getZ() + x * r.getY() - y * r.getX()`.\n\nFinally, the function returns a new instance of `Quaternion` with the computed values of w_, x_, y_, and z_.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a Quaternion object representing the result of multiplying the input vector `r` by the quaternion.\n\nThe output is a `Quaternion` instance, which represents a rotation matrix in 4D space.\nThe `w_` attribute of the output contains the magnitude (or length) of the quaternion.\nThe `x_, y_, and z_` attributes represent the three axes of the rotation, which can be used to compute the rotation matrix using the following equations:\n\n* x_ represents the axis of rotation around the x-axis\n* y_ represents the axis of rotation around the y-axis\n* z_ represents the axis of rotation around the z-axis\n\nThese axes can be used to create a 3D rotation matrix by multiplying them with their corresponding dot products.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion(1, 2, 3, 4);\nVector3f v = new Vector3f(1, 2, 3);\n\n// Returns a new quaternion with the product of the two inputs.\nQuaternion p = q.mul(v);\n",
              "description": "\nThe `x` and `y` components of the quaternion are negated, and the `w` component is positive or negative depending on whether the vector points in the same direction as the rotation axis of the quaternion or not."
            },
            "name": "mul",
            "code": "public Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}",
            "location": {
              "start": 162,
              "insert": 127,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 126,
                "end": 161
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 35
          },
          {
            "id": "2060f0f5-3df0-1385-f645-10dce55460af",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "takes a `Quaternion` argument `r` and returns a new `Quaternion` instance with the difference between the original quaternion's values and the given `r`.",
            "params": [
              {
                "name": "r",
                "type_name": "Quaternion",
                "description": "4D vector to be subtracted from the current 4D vector, resulting in a new 4D vector that represents the difference between the two vectors.\n\n* `w`: The real part of the quaternion.\n* `x`, `y`, and `z`: The imaginary parts of the quaternion.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a new Quaternion object representing the difference between the current Quaternion and the provided Quaternion.\n\n* The output is a new `Quaternion` object with the difference between the input `w`, `x`, `y`, and `z` components.\n* The resulting quaternion represents the difference between the original and input quaternions.\n* The output has the same dimension as the input, meaning it is also a 4-dimensional vector.\n* The order of the output is the opposite of the input, meaning that if the input quaternion is represented as (w, x, y, z), then the output of the `sub` function will be represented as (-w, -x, -y, -z).",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion(0, 1, 0, 0);\nQuaternion q3 = q1.sub(q2);\nSystem.out.println(\"q1 - q2 = \" + q3);\n",
              "description": "\nIn this example, the sub method is being called on an instance of a Quaternion object q1 with the input argument q2. The resulting output of the sub method will be stored in the variable q3.\nThe output for the code will be: q1 - q2 = 0 0 1 -1\nThis is because subtracting the two quaternions results in a new Quaternion object with values of w = 1, x = 0, y = 1, and z = -1."
            },
            "name": "sub",
            "code": "public Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}",
            "location": {
              "start": 193,
              "insert": 171,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 170,
                "end": 192
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 22
          },
          {
            "id": "287b4a2f-2247-abbb-1140-9d9929bd0f27",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "takes a `Quaternion` object `r` as input and returns a new `Quaternion` object with the sum of its components.",
            "params": [
              {
                "name": "r",
                "type_name": "Quaternion",
                "description": "quaternion to be added to the current quaternion, and its value is used to compute the resultant quaternion.\n\n* `r`: A Quaternion object representing the second quaternion to be added. It has four attributes - `W`, `X`, `Y`, and `Z` - which correspond to the real and imaginary parts of the quaternion, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a new Quaternion object representing the sum of the input quaternions.\n\n* The new quaternion is constructed by adding the scalar values of the input quaternions (w, x, y, and z) element-wise.\n* The resulting quaternion represents the sum of the two input quaternions.\n* The quaternion components (w, x, y, and z) are non-negative and sum to 1, ensuring that the quaternion is properly normalized.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    // create a quaternion object and set its values\n    Quaternion q1 = new Quaternion();\n    q1.setX(0);\n    q1.setY(0);\n    q1.setZ(0);\n    q1.setW(1);\n    \n    // create a quaternion object and set its values\n    Quaternion q2 = new Quaternion();\n    q2.setX(1);\n    q2.setY(0);\n    q2.setZ(0);\n    q2.setW(1);\n    \n    // add the quaternions together and set the result to a variable\n    Quaternion sum = q1.add(q2);\n    System.out.println(\"Quaternion Sum: \" + sum);\n}\n",
              "description": "\nThe output of this example would be `Quaternion Sum: (1, 0, 0, 2)`. This is because the add method takes two quaternion objects as parameters, and then returns a new quaternion object that represents the result of adding those two quaternions together. In this case, the resulting quaternion would have x, y, z, and w values of 1, 0, 0, and 2 respectively.\n\nIt's worth noting that this is a simple example, and in reality, you might need to perform more complex operations on two quaternions before returning the result as a new object. For instance, you may need to normalize one or both of the quaternions before performing the addition. Additionally, you may also need to handle boundary conditions where the input quaternion objects have values that are not within the valid range for a Quaternion."
            },
            "name": "add",
            "code": "public Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}",
            "location": {
              "start": 217,
              "insert": 197,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 196,
                "end": 216
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 20
          },
          {
            "id": "c38449e2-fe12-9ea9-d949-47c3df572c24",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "generates a rotation matrix based on three vector inputs representing the x, y, and z axes of a 3D space. The resulting matrix is used to represent a rotation in a 3D space.",
            "params": [],
            "returns": {
              "type_name": "Matrix4f",
              "description": "a 4x4 rotation matrix.\n\n* The `Matrix4f` object is initialized with the forward, up, and right vectors as input.\n* These vectors represent the rotation axis and direction in 3D space.\n* The rotation matrix is returned in a 4x4 format, which represents the orientation of the rotation in homogeneous coordinates.\n* Each element of the matrix represents the dot product of the corresponding vector in the input with the rotation axis.\n* The resulting matrix can be used to perform rotations in 3D space, such as rotating an object around a specific axis or aligning multiple objects relative to each other.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Declare a variable for the quaternion.\nQuaternion q = new Quaternion(1f, 2f, 3f, 4f);\n\n// Convert the quaternion to a rotation matrix and store it in a variable.\nMatrix4f rotationMatrix = q.toRotationMatrix();\n",
              "description": "\nThis code will take the given quaternion and convert it into a rotation matrix that can be used for rotation purposes. The resulting Matrix4f object stores the resulting rotation matrix, which is used to rotate objects using the Quaternion class's rotation methods."
            },
            "name": "toRotationMatrix",
            "code": "public Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}",
            "location": {
              "start": 243,
              "insert": 221,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 220,
                "end": 242
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 22
          },
          {
            "id": "abc1a1a3-a5cb-d78e-eb48-8c6308d47912",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "computes the dot product of two Quaternions, returning a floating-point value between -1 and 1.",
            "params": [
              {
                "name": "r",
                "type_name": "Quaternion",
                "description": "4D quaternion to be multiplied with the `x`, `y`, `z`, and `w` components of the current quaternion, resulting in the dot product of the two quaternions.\n\n* `x`, `y`, `z`, and `w` are float values representing the components of the quaternion.\n* `getX()`, `getY()`, `getZ()`, and `getW()` are methods that return these component values for further processing in the function body.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a float value representing the dot product of two quaternions.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(1, 2, 3, 4);\nQuaternion r = new Quaternion(5, 6, 7, 8);\n\nfloat result = q1.dot(r);\nSystem.out.println(\"The dot product between quaternions q1 and r is \" + result); // prints \"The dot product between quaternions q1 and r is 70\"\n",
              "description": ""
            },
            "name": "dot",
            "code": "public float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}",
            "location": {
              "start": 264,
              "insert": 251,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 250,
                "end": 263
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "7a864b7e-8289-7eaf-504e-263f5f7791c3",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "computes a quaternion interpolation between two given quaternions using the linear interpolation formula. The function takes into account the shortest path and returns the interpolated quaternion normalized to have a length of 1.",
            "params": [
              {
                "name": "dest",
                "type_name": "Quaternion",
                "description": "4-element quaternion value that will be lerped towards the provided target value.\n\n* `Quaternion dest`: The destination quaternion to which the interpolation will be applied.\n* `lerpFactor`: A float value representing the interpolation factor between the start and end quaternions.\n* `shortest`: An boolean value indicating whether the shortest path should be taken (true) or not (false). If true, the function will correct the destination quaternion if its dot product with the input quaternion is negative.",
                "complex_type": true
              },
              {
                "name": "lerpFactor",
                "type_name": "float",
                "description": "0-1 value that determines how much the destination quaternion is linearly interpolated from the source quaternion during the nearest-neighbor search.",
                "complex_type": false
              },
              {
                "name": "shortest",
                "type_name": "boolean",
                "description": "4-vector of the shortest quaternion that will be returned if it is set to `true`, otherwise, the normalized quaternion will be returned regardless of its length.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a normalized quaternion that represents the linear interpolation of the given quaternion based on the provided factor.\n\n* The output is a Quaternion object, representing a linear interpolation between the input `dest` and the current value of the `this` parameter.\n* If the `shortest` parameter is set to `true`, and the dot product of the `this` parameter and the `dest` parameter is less than zero, the output is inverted to ensure that the interpolation points towards the origin.\n* The output is normalized to have a length of one.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion quat1 = new Quaternion(1, 0, 0, 0); // quaternion with w component 1 and x, y, z components all 0.\nQuaternion quat2 = new Quaternion(2, 3, 4, 5); // quaternion with w component 2, x component 3, y component 4, and z component 5.\n\nfloat lerpFactor = 0.7f; // interpolate between the two quaternions by this factor.\nboolean shortest = true; // make sure to take the shortest path from this.\n\nQuaternion result = quat1.NLerp(quat2, lerpFactor, shortest);\n",
              "description": "\nThe above code would set 'result' to be a quaternion with w component 1.485714 and x, y, z components all 0.793655. This is because the dot product between 'quat1' and 'quat2' is negative, so we need to invert the second quaternion before interpolating. The lerp factor is set at 0.7, which means that 70% of the way from 'quat1' to 'quat2', and 30% of the way back to 'quat1'. When we add this result to 'quat1', we get a quaternion that is 80% of the distance between 'quat1' and 'quat2', and 20% of the distance from 'quat2' to '-quat2'.\nBy setting 'shortest = true', the method takes into account that the shortest path is taken. This means that instead of interpolating through '-quat2', it takes the shorter path which goes through quat1. As a result, the resulting quaternion has w component 1.76534 and x, y, z components all -0.893695. This is because the dot product between 'quat1' and '-quat2' is negative, but the dot product between 'quat1' and '-quat2' is positive, so we need to invert '-quat2' before interpolating. The lerp factor is set at 0.7 again, which means that 70% of the way from 'quat1' to '-quat2', and 30% of the way back to 'quat1'. When we add this result to 'quat1', we get a quaternion that is 84% of the distance between 'quat1' and '-quat2', and 16% of the distance from '-quat2' to '-quat2'."
            },
            "name": "NLerp",
            "code": "public Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}",
            "location": {
              "start": 304,
              "insert": 268,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 267,
                "end": 303
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 36
          },
          {
            "id": "0c58f678-a964-7184-0c4b-2bbca20d9931",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "computes a linear interpolation between two Quaternion values based on the input lerp factor and a boolean flag for shortest path.",
            "params": [
              {
                "name": "dest",
                "type_name": "Quaternion",
                "description": "4-component quaternion that the returned quaternion will be blended with, based on the specified `lerpFactor`.\n\n* `dest.getW()` represents the scalar component of the quaternion.\n* `dest.getX()`, `dest.getY()`, and `dest.getZ()` represent the vector components of the quaternion.\n\nThe `correctedDest` variable is created to handle the case where the dot product between the current quaternion and the destination quaternion is negative, which indicates that the quaternion needs to be inverted before interpolating.",
                "complex_type": true
              },
              {
                "name": "lerpFactor",
                "type_name": "float",
                "description": "0-1 value that determines how much the quaternion should be linearly interpolated towards the destination quaternion, with values closer to 0 resulting in slower interpolation and values closer to 1 resulting in faster interpolation.",
                "complex_type": false
              },
              {
                "name": "shortest",
                "type_name": "boolean",
                "description": "shortest quaternion path between the source and destination, which is computed by negating the destination quaternion when the cosine of the dot product between the two quaternions is less than or equal to 1, and then using the `NLerp()` function to interpolate the quaternion.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a Quaternion representation of the linear interpolation between two given Quaternions, based on the specified lerp factor and shortest path setting.\n\n* The output is a Quaternion object, representing a rotational transformation.\n* The quaternion is constructed by multiplying the input source and destination quaternions with scaling factors, and then adding the resulting vectors.\n* The scaling factors are calculated using the sine of the angle between the source and destination quaternions, and the length of the source quaternion.\n* If `shortest` is set to true, the quaternion is corrected to ensure that the result is always a rotation towards the destination quaternion, regardless of the orientation of the source quaternion. This is done by negating the source quaternion if the dot product of the source and destination quaternions is negative.\n* The output quaternion represents a linear interpolation between the source and destination quaternions, based on the `lerpFactor` parameter.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion(1, 1, 1, 1);\nfloat lerpFactor = 0.5f;\nboolean shortest = false;\nQuaternion result = q1.SLerp(q2, lerpFactor, shortest);\n",
              "description": "\nIn this example, q1 and q2 are two Quaternion objects that represent the rotation of an object in 3D space. The SLerp method is used to interpolate between these two rotations with a factor of 0.5 (halfway) and without considering the shortest path (shortest argument is false). The result is stored in the variable result, which is also a Quaternion object that represents the rotation that results from interpolating between q1 and q2 at a factor of 0.5."
            },
            "name": "SLerp",
            "code": "public Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}",
            "location": {
              "start": 351,
              "insert": 313,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 312,
                "end": 350
              }
            },
            "item_type": "method",
            "length": 23,
            "docLength": 38
          },
          {
            "id": "90b531be-225c-f2bb-e845-ebc4e268a382",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "rotates a vector by 90 degrees around the x-axis to produce a forward-facing vector.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a vector representing the forward direction of the rotated object.\n\nThe return value is a `Vector3f` object, indicating that it has three components - x, y, and z. The values of these components are determined by multiplying the corresponding components of the original vector by a scalar value of 0, 0, and 1, respectively. This results in a vector that points in the direction of the original vector but with its magnitude reduced to 1.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion(0, 1, 0, 0);\nVector3f forward = q.getForward();\n",
              "description": "\nThis method is a simple wrapper to the rotate method of the Vector3f class, which rotates a vector by a quaternion. It creates a new vector with (0, 0, 1) coordinates and returns the result of the rotation.\nThe reason for this method is that it provides an easy way to get the forward direction of an object defined by its rotation. The quaternion can be used as an input to the rotate method of other objects to create a new vector that is in the same direction as the original vector, but rotated according to the rotation defined by the Quaternion.\nFor example, if we wanted to get the forward direction of an object defined by its rotation, we could use this method as follows:\n"
            },
            "name": "getForward",
            "code": "public Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}",
            "location": {
              "start": 424,
              "insert": 414,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 413,
                "end": 423
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 10
          },
          {
            "id": "9932b588-bd62-0fa3-b44c-6d4b07aa5153",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "rotates a `Vector3f` instance by 90 degrees around the x-axis, resulting in a vector pointing towards the negative z-axis.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a rotated vector with a magnitude of -1 in the opposite direction of the original vector.\n\n* The output is a vector with three elements, representing the position of an object in 3D space.\n* The first element represents the x-coordinate of the position, the second element represents the y-coordinate, and the third element represents the z-coordinate.\n* The vector is created by rotating the original vector (0, 0, -1) around the center of the object using the `rotate` method. This results in a vector that points in the opposite direction of the object's facing.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion(0, 1, 0, 0);\nVector3f v = q.getBack();\nSystem.out.println(v.toString()); // (0, 0, -1)\n",
              "description": "\nThis example creates a Quaternion with the following components: x = 0, y = 1, z = 0, w = 0. It then uses the method getBack() on this quaternion to calculate its back vector, which is represented as a Vector3f object with (0, 0, -1). The output is printed using the toString method of the vector and shows that the x, y, and z components are all equal to zero, while the w component is negative one."
            },
            "name": "getBack",
            "code": "public Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}",
            "location": {
              "start": 440,
              "insert": 428,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 427,
                "end": 439
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 12
          },
          {
            "id": "03e7b44e-a1e4-ffaf-7945-2fc521873eca",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "rotates a vector by 90 degrees around the z-axis, resulting in a new vector pointing upwards from the original position.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a rotated vector with a magnitude of 1 and an orientation of upwards.\n\n* The output is a `Vector3f` object representing the up direction in 3D space.\n* The vector has an x-component of 0, a y-component of 1, and a z-component of 0, indicating that it points directly upwards in the 3D space.\n* The rotation is applied to the input vector using the `rotate` method, which creates a new vector by rotating the original vector around the specified axis. In this case, the axis is the same as the direction of the output vector.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f up = new Vector3f(0, 1, 0);\nQuaternion q = new Quaternion();\n\nup = up.rotate(q); // rotates the vector by the quaternion q\n",
              "description": "\nThis code creates a `Quaternion` object named `q`, and uses it to rotate a `Vector3f` object by 180 degrees around the y-axis (using the `rotate()` method). The resulting rotated vector is then stored in the `up` variable."
            },
            "name": "getUp",
            "code": "public Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}",
            "location": {
              "start": 455,
              "insert": 444,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 443,
                "end": 454
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 11
          },
          {
            "id": "bdf81a6d-e783-d18c-6346-c547533db74d",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "rotates a `Vector3f` instance by 90 degrees around the z-axis, resulting in a vector pointing downwards from the original position.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a rotated vector with a magnitude of 0 and a direction that points downward from the original vector's position.\n\nThe output is a `Vector3f` object representing the downward direction from the current position.\nIt is created by applying a rotation to the original position using the `rotate` method.\nThe rotation is performed based on the position of the current object, which means that the resulting vector points in the opposite direction of the current object's movement.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    Quaternion q = new Quaternion();\n    Vector3f downVector = q.getDown();\n    System.out.println(\"downVector: \" + downVector);\n}\n",
              "description": "\nThe code will print out a vector with x, y and z values as 0 and w value -1. This is because the method rotate(this) rotates the quaternion by its own rotation in order to get the down vector.\n\nIn general, it would be best to test this with different quaternions to ensure that you are getting the correct result, but this example should be sufficient for understanding how the code works."
            },
            "name": "getDown",
            "code": "public Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}",
            "location": {
              "start": 474,
              "insert": 459,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 458,
                "end": 473
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 15
          },
          {
            "id": "585bd5b8-a38d-5dad-4e4c-d1b7ddac9938",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "rotates a `Vector3f` instance by 90 degrees around the x-axis, resulting in a new vector that points towards the right direction.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a rotation of the original vector by 90 degrees around the x-axis.\n\n* The output is a new `Vector3f` object that represents the rightward orientation of the current vector.\n* The rotation is performed by taking the original vector and applying a rotate transformation using the `rotate` method, which takes no arguments.\n* The resulting vector has a magnitude of 1 and a direction that is 90 degrees counter-clockwise from the original vector's direction.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f up = new Vector3f(0, 1, 0).rotate(quaternion);\n",
              "description": "\nIn this example, a vector representing the y-axis (upward direction) is created and rotated by the given quaternion. This is equivalent to getting the right vector of a rotated coordinate system. The resulting vector will represent the new x-axis."
            },
            "name": "getRight",
            "code": "public Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}",
            "location": {
              "start": 489,
              "insert": 478,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 477,
                "end": 488
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 11
          },
          {
            "id": "d335e449-043a-e7b3-ac4d-82aa72519e59",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "rotates a vector by 90 degrees counterclockwise around the x-axis, resulting in a new vector that points left from the original one.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a rotated version of the original vector, with its x-component changed to -1.\n\n* The return type is `Vector3f`, indicating that it is a 3D vector with floating-point values.\n* The expression `-1, 0, 0` represents the coordinates of the leftmost point in the original vector.\n* The `rotate` method is applied to the original vector to produce the rotated vector.\n\nThe properties of the output depend on the type of rotation performed by the `rotate` method. In this case, it is a clockwise rotation around the origin, resulting in a vector that points in the negative z-direction.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion(1, 2, 3, 4);\nVector3f v = q.getLeft();\nSystem.out.println(\"q = \" + q + \", v = \" + v);\n",
              "description": "\nThis code would output the following:\n"
            },
            "name": "getLeft",
            "code": "public Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}",
            "location": {
              "start": 508,
              "insert": 493,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 492,
                "end": 507
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 15
          },
          {
            "id": "ac788af4-69ba-c791-8147-dc2c3d1051a5",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "sets the values of a Quaternion object's `x`, `y`, `z`, and `w` fields to the specified arguments.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "3D position of the quaternion along the x-axis.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "float",
                "description": "2D component of the quaternion.",
                "complex_type": false
              },
              {
                "name": "z",
                "type_name": "float",
                "description": "3rd component of the quaternion, which is updated to match the provided value.",
                "complex_type": false
              },
              {
                "name": "w",
                "type_name": "float",
                "description": "4th component of the quaternion, which is used to rotate the object along the `z` axis.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a new instance of the `Quaternion` class with the updated values of `x`, `y`, `z`, and `w`.\n\nThe `Quaternion` object is updated with the provided values for `x`, `y`, `z`, and `w`. These values are assigned to the corresponding fields of the object.\n\nAs a result, the returned `Quaternion` object has the updated values of its fields, which can be used to represent the rotation more accurately. The returned object is the same as the original one, indicating that the method is idempotent.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion(1, 2, 3, 4);\nq.set(5, 6, 7, 8).equals(new Quaternion(5, 6, 7, 8)); // true\n",
              "description": "\nThis is because set method takes 4 float arguments and sets them to the current instance of Quaternion object which will be equal to the new Quaternion object created with the same values.  \n\nThis is a very simple example that does not require an explanation because it uses basic arithmetic operations. In general, this type of code should be used in tests, not in production code. It is also generally considered as bad practice to write \"hallucinated\" input values for testing purposes.\n\nNote that the method set() returns a reference to the modified object which is the same as the original object passed as an argument. This allows chaining of operations and makes the code more readable."
            },
            "name": "set",
            "code": "public Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}",
            "location": {
              "start": 538,
              "insert": 512,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 511,
                "end": 537
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 26
          },
          {
            "id": "f36893bf-ed8e-aaa5-5241-0536dda2cc82",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "takes a `Vector3f` object representing Euler angles and returns a Quaternion object representing the corresponding rotation transformation.",
            "params": [
              {
                "name": "eulerAngles",
                "type_name": "Vector3f",
                "description": "3D Euler angles of a rotation, which are used to calculate the quaternion representation of the rotation.\n\n* `phi`: The Euler angle representing the rotation around the x-axis.\n* `theta`: The Euler angle representing the rotation around the y-axis.\n* `yota`: The Euler angle representing the rotation around the z-axis.\n\nThe function then stores the necessary cosines and sins of these angles locally to avoid recalculating them, before constructing the quaternion output.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a quaternion representation of the input Euler angles.\n\n* `q0`, `q1`, `q2`, and `q3` are the four components of the quaternion representation of the rotation angle. These values range from -1 to 1 and can be interpreted as the x, y, z, and w components of a quaternion, respectively.\n* The quaternion is represented in the form `q = q0 + q1*i + q2*j + q3*k`, where `i`, `j`, and `k` are the imaginary units that satisfy the quaternion algebra rules.\n* The quaternion is normalized to have a length of 1, ensuring that it represents a valid rotation angle in 3D space.\n* The function returns a new Quaternion object containing the resulting quaternion representation of the input Euler angles.",
              "complex_type": true
            },
            "name": "fromEuler",
            "code": "public static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}",
            "location": {
              "start": 551,
              "insert": 546,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 545,
                "end": 550
              }
            },
            "item_type": "method",
            "length": 23,
            "docLength": 5
          },
          {
            "id": "8d133f54-3800-04a2-e44e-dcbd23d4cffb",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "sets the quaternion components of the provided `Quaternion` object to the corresponding values of the given quaternion.",
            "params": [
              {
                "name": "r",
                "type_name": "Quaternion",
                "description": "4-element vector that contains the new values to be set for the quaternion's components.\n\nQuaternion `r`: This is the input quaternion that represents a rotation. It has four components: `x`, `y`, `z`, and `w`. Each component corresponds to a real number that represents a value between 0 and 1, inclusive.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Quaternion",
              "description": "a reference to the same `Quaternion` object, unchanged.\n\n* The `set` function takes four arguments, each representing a component of the input quaternion.\n* The function updates the corresponding components of this quaternion using the given values.\n* After updating the components, the function returns this quaternion as its output.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    Quaternion quat1 = new Quaternion();\n    Quaternion quat2 = new Quaternion();\n    \n    quat1.setX(0.4f);\n    quat1.setY(-3.5f);\n    quat1.setZ(2.6f);\n    quat1.setW(-1.7f);\n    \n    quat2.set(quat1); // Quaternion object with values (0.4, -3.5, 2.6, -1.7) copied to another quaternion object.\n}\n",
              "description": ""
            },
            "name": "set",
            "code": "public Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}",
            "location": {
              "start": 593,
              "insert": 575,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 574,
                "end": 592
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 18
          },
          {
            "id": "2ed697dc-52be-01b2-c44f-bdf9cc63217f",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "retrieves the value of the `x` field, which is a `float` variable.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point value representing the variable `x`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Quaternion {\n    public float x;\n    public float y;\n    public float z;\n    public float w;\n    \n    /**\n     * Constructor for objects of class Quaternion\n     */\n    public Quaternion() {}\n    \n    /**\n     * Constructor for objects of class Quaternion\n     * \n     * @param x X component of the quaternion.\n     * @param y Y component of the quaternion.\n     * @param z Z component of the quaternion.\n     * @param w W component of the quaternion.\n     */\n    public Quaternion(float x, float y, float z, float w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    \n    /**\n     * Returns the X component of the quaternion.\n     * \n     * @return The X component of the quaternion.\n     */\n    public float getX() {\n        return x;\n    }\n}\n",
              "description": "\nExample usage:\n"
            },
            "name": "getX",
            "code": "public float getX() {\n\t\treturn x;\n\t}",
            "location": {
              "start": 603,
              "insert": 598,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 597,
                "end": 602
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "c52cc070-59a5-c595-c345-61983c0363e2",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "sets the value of the `x` field of the object on which it is called, to the argument passed as a float.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "float value that will be assigned to the `x` field of the class object.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Quaternion {\n\tprivate float x, y, z, w;\n\n\t// getters and setters...\n}\n\nQuaternion myQuat = new Quaternion(1.0f, 2.0f, 3.0f, 4.0f);\nmyQuat.setX(-1.5f); // sets the x component of the quaternion to -1.5\n",
              "description": "\nIn this example, `setX` is a method that takes one float parameter and returns no value, meaning it will modify the `x` field of its object reference parameter to match the value provided as an argument. In this case, the x component of the quaternion is set to -1.5 by calling `myQuat.setX(-1.5f)`."
            },
            "name": "setX",
            "code": "public void setX(float x) {\n\t\tthis.x = x;\n\t}",
            "location": {
              "start": 614,
              "insert": 607,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 606,
                "end": 613
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "c8f0f166-fffd-ee8d-3140-9e5dd28ba3c0",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "returns the value of the variable `y`.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the value of the `y` field.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Quaternion quat = new Quaternion(0, 1, 0, 0); // create a quaternion object with default values\nfloat y = quat.getY();                       // retrieve the value of the y field of quaternion object\nSystem.out.println(y);                      // print the value of the retrieved y field\n",
              "description": "\nIn this example, we created a `Quaternion` object with default values and then retrieved its y component using the `getY()` method. We then printed the value retrieved from the y component to the console. The output should be 1.0f."
            },
            "name": "getY",
            "code": "public float getY() {\n\t\treturn y;\n\t}",
            "location": {
              "start": 623,
              "insert": 618,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 617,
                "end": 622
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "4cc9a2b8-922c-6b87-e14c-9cda1536cf22",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "sets the value of the `y` field in the object to which it belongs.",
            "params": [
              {
                "name": "y",
                "type_name": "float",
                "description": "2D coordinate's Y value that is being assigned to the `y` field of the object instance upon invocation of the `setY()` method.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Test {\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion();\n        \n        // Set the y-component of the quaternion to 1.0f\n        q.setY(1.0f);\n        \n        // Print out the y-component of the quaternion\n        System.out.println(\"The y-component of the quaternion is: \" + q.getY());\n    }\n}\n",
              "description": ""
            },
            "name": "setY",
            "code": "public void setY(float y) {\n\t\tthis.y = y;\n\t}",
            "location": {
              "start": 633,
              "insert": 627,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 626,
                "end": 632
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "c1bc1686-8622-0789-3c42-9be00aa0796d",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "returns the value of the `z` field.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point value representing the z component of an object's position.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Test {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion();\n        System.out.println(\"Quaternion Z: \" + quat.getZ());\n    }\n}\n",
              "description": ""
            },
            "name": "getZ",
            "code": "public float getZ() {\n\t\treturn z;\n\t}",
            "location": {
              "start": 642,
              "insert": 637,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 636,
                "end": 641
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "cfca1474-0981-a294-3544-072e61552669",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "sets the value of the member variable `z` to the input float parameter.",
            "params": [
              {
                "name": "z",
                "type_name": "float",
                "description": "3D position of an object or entity, and by assigning a new value to it within the function, the object's position is updated.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "float z = 10.5; // Some arbitrary float value\nmyQuaternion.setZ(z);\n",
              "description": "\nIn this example, we have a `myQuaternion` object of type Quaternion and are assigning the value `10.5` to its Z component. The method setZ takes in an argument of type `float` which is then assigned to the Quaternion's z component."
            },
            "name": "setZ",
            "code": "public void setZ(float z) {\n\t\tthis.z = z;\n\t}",
            "location": {
              "start": 652,
              "insert": 646,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 645,
                "end": 651
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "8831ef22-696b-2798-ef4f-9aea0f790c9a",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "returns the `w` field's value.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a float value representing the variable `w`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class MyClass {\n    private Quaternion myQuat;\n\n    public void doSomething() {\n        float w = myQuat.getW();\n        // use w here\n    }\n}\n",
              "description": "\nIn this example, the method getW is being used to retrieve the w value of a quaternion object. It is then used as a local variable in the doSomething method to be used further on."
            },
            "name": "getW",
            "code": "public float getW() {\n\t\treturn w;\n\t}",
            "location": {
              "start": 662,
              "insert": 656,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 655,
                "end": 661
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "000ab821-98d9-86a7-0e41-16cb4d29f10d",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "sets the value of the field `w` of the current object to the argument passed as a float value.",
            "params": [
              {
                "name": "w",
                "type_name": "float",
                "description": "float value that sets the `w` field of the current object.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "Quaternion q = new Quaternion();\nq.setW(10);\n",
              "description": "\nIn the above example, we have created a `Quaternion` object and set its `w` component to 10."
            },
            "name": "setW",
            "code": "public void setW(float w) {\n\t\tthis.w = w;\n\t}",
            "location": {
              "start": 671,
              "insert": 666,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 665,
                "end": 670
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "1d3f2b15-a343-0088-bd43-9abd52146656",
            "ancestors": [
              "19e8e215-53aa-4a8f-084d-0452ec3fe116"
            ],
            "type": "function",
            "description": "compares two Quaternion objects by checking for exact matching of all component values.",
            "params": [
              {
                "name": "r",
                "type_name": "Quaternion",
                "description": "4D vector that is being compared to the current 4D vector for equality.\n\n`x`, `y`, `z`, and `w` represent the respective components of the quaternion.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Boolean",
              "description": "a boolean value indicating whether two quaternions are equal.\n\n1. The method returns a boolean value indicating whether the specified `Quaternion` instance is equal to the current instance.\n2. The comparison is based on the values of the x, y, z, and w components of both instances.\n3. If any of these components differ, the method returns false.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Quaternion q1 = new Quaternion(0, 0, 0, 0);\nQuaternion q2 = new Quaternion(0, 0, 0, 0);\n\nq1.setX(0);\nq1.setY(0);\nq1.setZ(0);\nq1.setW(0);\n\nq2.setX(0);\nq2.setY(0);\nq2.setZ(0);\nq2.setW(0);\n\nassertEquals(true, q1.equals(q2));\n",
              "description": "\nThis example initializes two quaternions, `q1` and `q2`, with the same values for their x, y, z, and w components. The method `setX()` is then used to set these values to 0, followed by calls to `setY()`, `setZ()`, and `setW()` with the value of 0. The method `equals()` is called on both quaternions, which returns `true` indicating that they are equal in terms of their x, y, z, and w components."
            },
            "name": "equals",
            "code": "public boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}",
            "location": {
              "start": 689,
              "insert": 675,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 674,
                "end": 688
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          }
        ]
      }
    }
  },
  {
    "name": "Vector2f.java",
    "path": "src/com/ch/math/Vector2f.java",
    "content": {
      "structured": {
        "description": "A `Vector2f` class that represents a 2D point in Cartesian coordinates. The class has getters and setters for x and y components, as well as methods for calculating absolute values, converting to a string, setting components, and comparing equality with other `Vector2f` objects. Additionally, the code provides methods for creating a new `Vector3f` object containing only the x, y, and z components, and a method for returning a reference to the same instance of the `Vector2f` class for chaining purposes.",
        "diagram": "digraph G {\n    label=\"com.ch.math.Vector2f\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    Vector3f\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Vector2f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    Vector2f -> Vector2f [style=\"dashed\"]\n    Vector3f -> Vector2f \n    Vector2f -> Vector2f \n}\n",
        "items": [
          {
            "id": "21f1b037-dff8-c299-a645-d46cdb9c3d24",
            "ancestors": [],
            "type": "function",
            "description": "in Android:\n\nThe Vector2f class in Android represents a 2D point in homogeneous coordinates with x and y components. It provides various methods for scaling, absolute value calculation, division, and comparison with other vectors. The class also offers chaining capabilities for modifying its components within the same instance. Additionally, it provides toString() method for generating a string representation of the vector's coordinates.",
            "name": "Vector2f",
            "code": "public class Vector2f {\n\t\n\tprivate float x;\n\tprivate float y;\n\n\tpublic Vector2f(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y);\n\t}\n\n\tpublic float max() {\n\t\treturn Math.max(x, y);\n\t}\n\n\t/**\n\t * computes the dot product of a `Vector2f` object and another vector, returning the\n\t * result as a single float value.\n\t * \n\t * @param r 2D vector to be dot-producted with the `x` and `y` components of the\n\t * output vector.\n\t * \n\t * @returns a floating-point number representing the dot product of the input vector\n\t * and another vector.\n\t */\n\tpublic float dot(Vector2f r) {\n\t\treturn x * r.getX() + y * r.getY();\n\t}\n\n\tpublic Vector2f normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Vector2f(x / length, y / length);\n\t}\n\n\t/**\n\t * calculates the vector cross product between two vectors represented as `Vector2f`\n\t * objects, returning the result as a single floating-point value.\n\t * \n\t * @param r 2D vector to be multiplied with the current vector, resulting in the cross\n\t * product.\n\t * \n\t * @returns a scalar value representing the cross product of two vectors.\n\t */\n\tpublic float cross(Vector2f r) {\n\t\treturn x * r.getY() - y * r.getX();\n\t}\n\n\t/**\n\t * calculates a vector that is a linear interpolation between two given vectors,\n\t * weighted by the specified factor.\n\t * \n\t * @param dest 2D destination point to which the current vector will be interpolated.\n\t * \n\t * @param lerpFactor 0.0 to 1.0 value that determines how much the destination vector\n\t * should be blended with the current vector during the linear interpolation process.\n\t * \n\t * @returns a vector that interpolates between two given vectors based on a specified\n\t * factor.\n\t */\n\tpublic Vector2f lerp(Vector2f dest, float lerpFactor) {\n\t\treturn dest.sub(this).mul(lerpFactor).add(this);\n\t}\n\n\t/**\n\t * rotates a 2D vector by an angle in radians, returning the rotated vector in a new\n\t * coordinate system.\n\t * \n\t * @param angle angle of rotation in radians.\n\t * \n\t * @returns a new vector with x and y components that have been rotated by the provided\n\t * angle.\n\t */\n\tpublic Vector2f rotate(float angle) {\n\t\tdouble rad = Math.toRadians(angle);\n\t\tdouble cos = Math.cos(rad);\n\t\tdouble sin = Math.sin(rad);\n\n\t\treturn new Vector2f((float) (x * cos - y * sin), (float) (x * sin + y * cos));\n\t}\n\n\t/**\n\t * takes a `r` parameter of type `Vector2f` and returns a new `Vector2f` instance\n\t * with the sum of the parameters' `x` and `y` coordinates.\n\t * \n\t * @param r 2D vector to be added to the current vector.\n\t * \n\t * @returns a new `Vector2f` object representing the sum of the input vector and the\n\t * provided vector.\n\t */\n\tpublic Vector2f add(Vector2f r) {\n\t\treturn new Vector2f(x + r.getX(), y + r.getY());\n\t}\n\n\t/**\n\t * takes a single float argument `r` and returns a new `Vector2f` object with the sum\n\t * of the current vector's x-coordinate plus the `r` value, and the same y-coordinate.\n\t * \n\t * @param r addition value to be added to the existing coordinates of the vector.\n\t * \n\t * @returns a new `Vector2f` instance with the sum of the input `r` added to its `x`\n\t * and `y` components.\n\t */\n\tpublic Vector2f add(float r) {\n\t\treturn new Vector2f(x + r, y + r);\n\t}\n\n\n    /**\n     * takes two floating-point arguments `x` and `y`, returns a new `Vector2f` object\n     * representing the sum of the current object's `x` and `y` values with the given `x`\n     * and `y` values.\n     * \n     * @param x 2D coordinate to add to the current position of the vector.\n     * \n     * @param y 2nd component of the resulting vector.\n     * \n     * @returns a new `Vector2f` instance representing the sum of the input `x` and `y`\n     * values.\n     */\n    public Vector2f add(float x, float y) {\n        return new Vector2f(this.x + x, this.y + y);\n    }\n\n /**\n  * takes a `Vector2f` object `r` as input and returns a new `Vector2f` object\n  * representing the difference between the current vector and `r`.\n  * \n  * @param r 2D vector to be subtracted from the original vector.\n  * \n  * \t- `x`: The first component of the vector, which represents the x-coordinate of\n  * the point.\n  * \t- `y`: The second component of the vector, which represents the y-coordinate of\n  * the point.\n  * \n  * @returns a new `Vector2f` object representing the difference between the input\n  * vector and the reference vector.\n  * \n  * The output is a new Vector2f instance with x and y components computed as the\n  * difference between the input vector's x and y components and the input vector itself.\n  */\n\tpublic Vector2f sub(Vector2f r) {\n\t\treturn new Vector2f(x - r.getX(), y - r.getY());\n\t}\n\n /**\n  * takes a single float argument `r` and returns a new `Vector2f` instance with the\n  * component-wise difference between the current vector and the given value.\n  * \n  * @param r 2D vector to subtract from the current vector.\n  * \n  * @returns a new `Vector2f` object representing the difference between the original\n  * vector and the given value.\n  * \n  * \t- The `Vector2f` object represents a 2D point in homogeneous coordinates.\n  * \t- The `x` and `y` fields represent the x- and y-coordinates of the point, respectively.\n  * \t- The `r` parameter represents the distance from the original point to be subtracted.\n  * \n  * The returned output is a new `Vector2f` object that represents the difference\n  * between the original point and the distance specified by the `r` parameter.\n  */\n\tpublic Vector2f sub(float r) {\n\t\treturn new Vector2f(x - r, y - r);\n\t}\n\n /**\n  * takes a `Vector2f` argument `r` and returns a new `Vector2f` object with the product\n  * of the current object's `x` and `y` components multiplied by the corresponding\n  * components of the `r` argument.\n  * \n  * @param r 2D vector that multiplies with the current vector.\n  * \n  * \t- `x` and `y` are double values representing the coordinates of the vector.\n  * \n  * @returns a new vector with the product of the input vector's x and y components\n  * multiplied by the corresponding values of the argument vector.\n  * \n  * \t- The output is of type `Vector2f`, indicating that it represents a 2D vector\n  * with x and y components.\n  * \t- The x and y components of the output are calculated by multiplying the x and y\n  * components of the input vector `r` by the corresponding components of the input\n  * vector `this`.\n  * \t- The resulting output is a new vector object, which is returned as the function\n  * value.\n  */\n\tpublic Vector2f mul(Vector2f r) {\n\t\treturn new Vector2f(x * r.getX(), y * r.getY());\n\t}\n\n /**\n  * multiplies the vector's components by a given scalar value, resulting in a new\n  * vector with the same magnitude and direction as the original, but with the x and\n  * y coordinates scaled by the specified factor.\n  * \n  * @param r scalar value used to multiply the vector's x and y components.\n  * \n  * @returns a new `Vector2f` instance with the product of the input `r` multiplied\n  * by the corresponding component of the original vector.\n  * \n  * \t- The output is a `Vector2f` object that represents the result of multiplying the\n  * `x` and `y` components of the input parameter `r` by the same value.\n  * \t- The resulting vector has the same dimensions as the input vector, with the\n  * magnitude of each component being the product of the corresponding component of\n  * the input vector and the input parameter `r`.\n  * \t- The direction of the output vector is the same as that of the input vector,\n  * since the multiplication is commutative for vectors.\n  */\n\tpublic Vector2f mul(float r) {\n\t\treturn new Vector2f(x * r, y * r);\n\t}\n\n /**\n  * takes a `Vector2f` argument `r` and returns a new `Vector2f` instance with x-axis\n  * divided by r.x and y-axis divided by r.y.\n  * \n  * @param r 2D vector to which the current vector is divided.\n  * \n  * \t- `x`: The real part of the input vector.\n  * \t- `y`: The imaginary part of the input vector.\n  * \n  * @returns a new vector with the same x-coordinates as the original vector, scaled\n  * by the ratio of the input vector's x-coordinate to its own x-coordinate.\n  * \n  * The output is a new Vector2f object with x and y components computed as the dividend\n  * divided by the divisor. Specifically, the x component is equal to the dividend x\n  * / divisor, while the y component is equal to the dividend y / divisor.\n  */\n\tpublic Vector2f div(Vector2f r) {\n\t\treturn new Vector2f(x / r.getX(), y / r.getY());\n\t}\n\n /**\n  * takes a single float argument and returns a new `Vector2f` instance with scaled x\n  * and y components proportional to the input value.\n  * \n  * @param r scale factor used to divide the vector's components by.\n  * \n  * @returns a vector with a magnitude equal to the inverse of the input `r`, and a\n  * direction that is the same as the original vector.\n  * \n  * \t- The `Vector2f` class represents a 2D point in homogeneous coordinates, with x\n  * and y components.\n  * \t- The function returns a new instance of `Vector2f`, where both the x and y\n  * components are divided by the input parameter `r`.\n  * \t- The output has the same dimensions as the original input, i.e., it is a 2D point\n  * in homogeneous coordinates.\n  */\n\tpublic Vector2f div(float r) {\n\t\treturn new Vector2f(x / r, y / r);\n\t}\n\n /**\n  * calculates the absolute value of a `Vector2f` object's x and y components, returning\n  * a new `Vector2f` object with those values.\n  * \n  * @returns a new `Vector2f` instance containing the absolute values of its input parameters.\n  * \n  * \t- The `x` and `y` values represent the absolute value of the input vector's components.\n  * \t- The output is a new Vector2f object that contains the absolute values of the\n  * input vector's components.\n  * \t- The returned object has the same type as the input object, which in this case\n  * is Vector2f.\n  * \t- The function does not modify the original input vector.\n  */\n\tpublic Vector2f abs() {\n\t\treturn new Vector2f(Math.abs(x), Math.abs(y));\n\t}\n\n /**\n  * returns a string representation of a point (x,y) by combining the values of x and\n  * y into a single string.\n  * \n  * @returns a string representation of a point in coordinates, consisting of the\n  * values of `x` and `y` separated by a space.\n  */\n\tpublic String toString() {\n\t\treturn \"(\" + x + \" \" + y + \")\";\n\t}\n\n /**\n  * sets the `x` and `y` components of a `Vector2f` object to the input values, returning\n  * the modified object for chaining.\n  * \n  * @param x 2D position of the vector in the x-axis.\n  * \n  * @param y 2nd component of the `Vector2f` object being modified, and its value is\n  * assigned to the `y` field of the object in the function.\n  * \n  * @returns a reference to the same instance of the `Vector2f` class with updated `x`\n  * and `y` values.\n  * \n  * The returned output is a reference to the same `Vector2f` instance. This means\n  * that the original object remains unchanged and the modified values of `x` and `y`\n  * are reflected in the returned output.\n  * \n  * The returned output has the same values for `x` and `y` as the input parameters,\n  * which are assignable to the member variables `x` and `y` respectively.\n  */\n\tpublic Vector2f set(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n /**\n  * sets the x and y components of the vector to the corresponding values of the given\n  * vector argument, and returns a reference to the modified vector object.\n  * \n  * @param r 2D vector to be set as the value of the `Vector2f` object returned by the\n  * function.\n  * \n  * \t- `getX()` and `getY()` represent the x-axis and y-axis coordinates of the vector,\n  * respectively.\n  * \n  * @returns a reference to the original vector instance with its components updated\n  * to match the values of the provided vector.\n  * \n  * \t- The output is a reference to the same Vector2f instance as the original input\n  * parameter.\n  * \t- The x and y coordinates of the output are set to the values passed in the r parameter.\n  */\n\tpublic Vector2f set(Vector2f r) {\n\t\tset(r.getX(), r.getY());\n\t\treturn this;\n\t}\n\n    /**\n     * returns a new `Vector3f` object containing the values of the current vector's `x`,\n     * `y`, and `z` components, where all components are set to zero except for the\n     * specified `x`, `y` components.\n     * \n     * @returns a vector with coordinates (x, y, 0).\n     * \n     * The returned object is a `Vector3f` instance, representing a 3D vector with three\n     * components: x, y, and z.\n     * Each component represents a floating-point value, indicating the magnitude and\n     * direction of the vector in the corresponding dimension.\n     * The vector is initialized to have an x-component of 0, y-component of 0, and\n     * z-component of 0, which means it points in the default \"up\" direction in 3D space.\n     */\n    public Vector3f as3DVector() {\n        return new Vector3f(x, y, 0);\n    }\n\n /**\n  * returns the value of the `x` field.\n  * \n  * @returns the value of `x`.\n  */\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n /**\n  * sets the value of the `x` field within the object to which it belongs.\n  * \n  * @param x float value that sets the field 'x' of the class to which the function belongs.\n  */\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n /**\n  * retuns the value of the `y` field.\n  * \n  * @returns the value of the `y` field.\n  */\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n /**\n  * sets the value of the member field `y` to the argument passed as a `float`.\n  * \n  * @param y 2D point's `y` coordinate that will be assigned to the `y` field of the\n  * 2D point object upon execution of the function.\n  */\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n /**\n  * compares two `Vector2f` objects based on their `x` and `y` components, returning\n  * `true` if they are equal, and `false` otherwise.\n  * \n  * @param r 2D vector to be compared with the current vector.\n  * \n  * \t- `x`: The `x` property of `r` represents the real-valued coordinate along the x-axis.\n  * \t- `y`: The `y` property of `r` represents the real-valued coordinate along the y-axis.\n  * \n  * @returns a boolean value indicating whether the object is equal to the provided vector.\n  */\n\tpublic boolean equals(Vector2f r) {\n\t\treturn x == r.getX() && y == r.getY();\n\t}\n\t\n}",
            "location": {
              "start": 3,
              "insert": 3,
              "offset": " ",
              "indent": 0,
              "comment": null
            },
            "item_type": "class",
            "length": 400,
            "docLength": null
          },
          {
            "id": "80df2caf-4c0f-6eab-1c44-1c4268fb3643",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "calculates the Euclidean distance between a point and the origin, using the square root of the sum of the point's x and y coordinates squared.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the square root of the sum of the squares of its input coordinates, expressed as a float value.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector2f v1 = new Vector2f(3, 4);\n        float length = v1.length();\n        System.out.println(\"Length of v1 is \" + length);\n    }\n}\n",
              "description": "\nThis will output the value `5`, which is the distance between (3, 4) and the origin point (0, 0).\n\n[/DONE]\n[ACCORDION-END]\n\n[ACCORDION-BEGIN [Step 7: ](Create a method in Vector2f to calculate the angle with another vector)]\nIn this step you will create the `angle` method which calculates the angle between the current vector and another vector.\n\nOpen the file **`Vector2f.java`** located under **`<SAP Cloud Platform Developer Edition for SAP HANA, express edition instance>/tutorial/java-level01/src/main/java/com/sap/hana/hibernate/`**.\n\nThe method will calculate the angle between two vectors and return it as a `float`.\n\nThe calculation is done using the formula: θ = arccos (dot product of the two vectors / (length of vector1 * length of vector2))\n\nProvide an example of how to use this java method:\n"
            },
            "name": "length",
            "code": "public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y);\n\t}",
            "location": {
              "start": 13,
              "insert": 13,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "c0da3ce6-253d-7292-8c42-e09e48254c62",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "computes the maximum value of two floating-point arguments and returns it as a float value.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the larger of the two input values, `x` and `y`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public float max() {\n\treturn Math.max(x, y);\n}\n\npublic static void main(String[] args) {\n\tVector2f v = new Vector2f(5, 3);\n\tSystem.out.println(\"Max value: \" + v.max()); // prints 5\n}\n",
              "description": "\nThis code creates a new vector with x and y values of 5 and 3 respectively, then calls the max method which returns the maximum value between the two components (in this case 5) and prints it out to the console."
            },
            "name": "max",
            "code": "public float max() {\n\t\treturn Math.max(x, y);\n\t}",
            "location": {
              "start": 17,
              "insert": 17,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "6b4bcec2-730a-8fbc-4148-be47e4212355",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "computes the dot product of a vector `r` and a vector `x` or `y`, returning the result as a float value.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector to be multiplied with the object's `x` and `y` components, resulting in the dot product of the two vectors.\n\n* `r`: A `Vector2f` object that represents a two-dimensional point in the mathematical plane. It has two attributes: `x` and `y`, which represent the x-coordinate and y-coordinate of the point, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a floating-point number representing the dot product of the input vector and a given vector `r`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "// Declare two vectors\nVector2f v1 = new Vector2f(3, 4);\nVector2f v2 = new Vector2f(-2, -1);\n\n// Calculate the dot product of these two vectors\nfloat result = v1.dot(v2); // result is -6\n",
              "description": "\nIn this example, we created two `Vector2f` objects with x-component 3 and y-component 4 and -2 and -1 respectively. We then called the dot method on `v1` with `v2` as an argument and assigned the result to a float variable `result`. The resulting dot product is stored in the variable `result`. Note that this code will produce a negative value since we multiplied two negative numbers."
            },
            "name": "dot",
            "code": "public float dot(Vector2f r) {\n\t\treturn x * r.getX() + y * r.getY();\n\t}",
            "location": {
              "start": 31,
              "insert": 21,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 20,
                "end": 30
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 10
          },
          {
            "id": "3a91fc5b-5bd0-678e-2049-0336f942b9a0",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "normalizes a `Vector2f` instance by dividing its components by their magnitude, resulting in a unitized vector.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a normalized vector with a length of 1.\n\nThe output is a new `Vector2f` object that represents the normalized form of the original vector.\n\nThe x-component of the output vector is calculated as the original x-component divided by the length of the original vector.\n\nThe y-component of the output vector is calculated as the original y-component divided by the length of the original vector.\n\nThe length of the output vector is always equal to 1, regardless of the length of the original vector.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f myVector = new Vector2f(3, 4);\nSystem.out.println(\"myVector: \" + myVector); // Output: (3, 4)\nVector2f normalizedMyVector = myVector.normalized();\nSystem.out.println(\"normalizedMyVector: \" + normalizedMyVector); // Output: (0.6, 0.8)\n",
              "description": "\nIn this example, the vector is first defined as `(3, 4)`. The `normalized()` method is then called on it and its output is stored in a variable named `normalizedMyVector`. This variable's value is then printed using `System.out.println()`.\nThe output of both vectors should be very similar since the difference between them is small and can be neglected. However, the `normalized()` method will return slightly different values than the original vector because it uses floating-point arithmetic which may result in a slight loss of precision due to rounding errors.\nAs for your second question, I'm afraid that you are mistaken in what the output should be. The correct way to check whether two vectors are equal is by using their `equals()` method. This compares the values of both vectors component-wise and returns a boolean value indicating whether they are equal or not.\nThe reason for this is that floating-point arithmetic can result in rounding errors which may cause your vector's components to be slightly different when compared with another vector using `==` operator. Therefore, it is advised to use the `equals()` method to check if two vectors are equal instead of comparing them directly with the `==` operator.\nAlso, I would like to point out that the code you provided does not compile as `Vector2f` is a class name and it needs to be initialized before being used."
            },
            "name": "normalized",
            "code": "public Vector2f normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Vector2f(x / length, y / length);\n\t}",
            "location": {
              "start": 35,
              "insert": 35,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "c54524ba-1a44-15aa-7744-fe8ed10c2e89",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "computes the vector product of two vectors, returning a floating-point value representing the dot product of the two vectors.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector that the function will perform the cross product operation with.\n\n* `r` is a `Vector2f` object representing a 2D point with x and y coordinates.\n* `x` and `y` are the x and y coordinates of the point, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a floating-point number representing the cross product of two vectors.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector2f v1 = new Vector2f(3, 4);\n        Vector2f v2 = new Vector2f(-5, 8);\n        System.out.println(v1.cross(v2)); // Output: -70\n    }\n}\n",
              "description": "\nIn this example, the `cross` method is used to calculate the cross product of two 2D vectors. The output is a real number representing the magnitude and direction of the resulting vector. In this case, the resulting vector is (-70)."
            },
            "name": "cross",
            "code": "public float cross(Vector2f r) {\n\t\treturn x * r.getY() - y * r.getX();\n\t}",
            "location": {
              "start": 50,
              "insert": 41,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 40,
                "end": 49
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "44dcc295-7cac-e09b-7e4c-0ae1d6c6ac96",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes two `Vector2f` arguments, `dest` and `lerpFactor`, and returns a new `Vector2f` object with a interpolated value between the two provided values.",
            "params": [
              {
                "name": "dest",
                "type_name": "Vector2f",
                "description": "2D position to which the interpolation will be applied.\n\n`dest`: A `Vector2f` object that represents the destination point in 2D space.\n`lerpFactor`: A floating-point value representing the factor by which the current position is to be interpolated between the start and end positions.",
                "complex_type": true
              },
              {
                "name": "lerpFactor",
                "type_name": "float",
                "description": "0 to 1 value that determines how much the source vector should be blended with the destination vector to produce the resulting vector.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` object representing the interpolated position between the original vector and the destination vector.\n\n* The output is a `Vector2f` object that represents the interpolated value between the original `Vector2f` parameter `this` and the destination `Vector2f` parameter `dest`.\n* The interpolation is performed by subtracting the `this` parameter from the `dest` parameter, multiplying the result by the `lerpFactor`, and then adding the resulting vector back to the `this` parameter.\n* The `lerpFactor` parameter represents the ratio of the distance between the `this` and `dest` parameters to be interpolated. A value of 1.0 results in a straight line interpolation, while a value less than 1.0 results in a slowing down of the interpolation, and a value greater than 1.0 speeds it up.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\tVector2f a = new Vector2f(0, 0);\n\tVector2f b = new Vector2f(1, 1);\n\tfloat factor = 0.5f;\n\t\n\t// Call the lerp method on the vector objects, passing in the other vector and the linear interpolation factor as arguments.\n\ta.lerp(b, factor);\n}\n",
              "description": "\nThis example will result in a new Vector2f object with components (0.5, 0.5)."
            },
            "name": "lerp",
            "code": "public Vector2f lerp(Vector2f dest, float lerpFactor) {\n\t\treturn dest.sub(this).mul(lerpFactor).add(this);\n\t}",
            "location": {
              "start": 66,
              "insert": 54,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 53,
                "end": 65
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 12
          },
          {
            "id": "e008143e-1123-fdbd-f349-bb8ded362eba",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes a single argument `angle` representing the angle of rotation in radians and returns a new `Vector2f` instance with the rotated coordinates.",
            "params": [
              {
                "name": "angle",
                "type_name": "float",
                "description": "2D angle of rotation in radians, which is multiplied by the vector's x and y components to produce the rotated vector.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new vector with x and y components rotated by the specified angle.\n\n* The vector is represented as a 2D point in homogeneous coordinates, where x and y represent the coordinates of the point in the original coordinate system, and w represents the magnitude or length of the point.\n* The rotation is performed around the origin, as indicated by the angle parameter passed to the function.\n* The rotation matrix is derived from the cosine and sine of the angle, which are calculated using the `Math.toRadians` method.\n* The resulting vector is a transformation of the original vector, with its coordinates rotated by the specified angle.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\tVector2f vector = new Vector2f(1, 0);\n\tfloat angle = (float) Math.PI / 4;\n\n\tVector2f rotatedVector = vector.rotate(angle);\n\n\tSystem.out.println(\"The original vector is: \" + vector);\n\tSystem.out.println(\"The rotated vector is: \" + rotatedVector);\n}\n",
              "description": "\nThis would print the following lines to the console:\n"
            },
            "name": "rotate",
            "code": "public Vector2f rotate(float angle) {\n\t\tdouble rad = Math.toRadians(angle);\n\t\tdouble cos = Math.cos(rad);\n\t\tdouble sin = Math.sin(rad);\n\n\t\treturn new Vector2f((float) (x * cos - y * sin), (float) (x * sin + y * cos));\n\t}",
            "location": {
              "start": 79,
              "insert": 70,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 69,
                "end": 78
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 9
          },
          {
            "id": "ebb4e74d-bb91-1784-be45-d45789da4833",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "adds two `Vector2f` objects together by adding their corresponding x and y coordinates and returns a new `Vector2f` object with the result.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector to be added to the current vector.\n\n* `x`: A double value representing the X-coordinate of the input vector.\n* `y`: A double value representing the Y-coordinate of the input vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` instance representing the sum of the input vectors.\n\nThe returned output is a new Vector2f object that represents the sum of the input vectors' x-coordinate and y-coordinate. The x-coordinate is calculated by adding the input vector's x-coordinate to the current vector's x-coordinate, and similarly for the y-coordinate.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Vector2fTest {\n    @Test\n    public void testAdd() {\n        Vector2f vector1 = new Vector2f(3, 4);\n        Vector2f vector2 = new Vector2f(5, 6);\n        Vector2f result = vector1.add(vector2);\n        \n        assertEquals(\"(8.0, 10.0)\", result.toString());\n    }\n}\n",
              "description": "\nThis code tests the `Vector2f` class's add method by creating two vectors (3, 4) and (5, 6) and then adding them together using the method. The resulting vector is then converted to a string using the `toString()` function and compared with the expected result \"8.0, 10.0\".\nThe test passes if these two values match and fails otherwise."
            },
            "name": "add",
            "code": "public Vector2f add(Vector2f r) {\n\t\treturn new Vector2f(x + r.getX(), y + r.getY());\n\t}",
            "location": {
              "start": 96,
              "insert": 87,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 86,
                "end": 95
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "6baf16f3-a496-609a-fc4c-f69dfc4a9069",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "adds a floating-point value to a `Vector2f` object, returning a new `Vector2f` with the sum.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "2D vector addition to be performed on the `Vector2f` instance being manipulated by the function.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` object representing the sum of the original vector and the provided float value.\n\nThe returned Vector2f object has an x-coordinate that is equal to the original x-coordinate plus the input r, and a y-coordinate that is equal to the original y-coordinate plus the input r. This means that the resulting vector's magnitude (length) is equal to the sum of the magnitudes of the original vector and the input r, and its direction is the same as the original vector's direction.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector2f v = new Vector2f();\n        float r = 5;\n        Vector2f v_plus = v.add(r);\n        \n        System.out.println(\"Vector addition result: \" + v_plus);\n    }\n}\n",
              "description": "\nThis code creates a `Vector2f` object and assigns it to the variable `v`, then it sets the value of `r` to 5 and uses the add method to create a new `Vector2f` object with the sum of its components being the input parameter, which is assigned to the variable `v_plus`. Finally, it prints out the result using the toString method. The output would be:\n"
            },
            "name": "add",
            "code": "public Vector2f add(float r) {\n\t\treturn new Vector2f(x + r, y + r);\n\t}",
            "location": {
              "start": 109,
              "insert": 100,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 99,
                "end": 108
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "24c33b38-8ebc-92b6-ff4a-e591a1c7a460",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes two floating-point arguments `x` and `y`, and returns a new `Vector2f` instance with the sum of the current instance's `x` and `y` components and the given `x` and `y` components.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "2D coordinate that is added to the current position of the vector.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "float",
                "description": "2nd component of the resulting vector.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` object representing the sum of the current vector's components and the input parameters.\n\nThe returned vector is a new instance of `Vector2f`.\nThe x component of the returned vector is equal to the sum of the x components of the input vectors.\nThe y component of the returned vector is equal to the sum of the y components of the input vectors.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Create a vector with x=2 and y=3\nVector2f v1 = new Vector2f(2, 3);\n\n// Create another vector with x=4 and y=5\nVector2f v2 = new Vector2f(4, 5);\n\n// Add v1 to v2\nVector2f result = v1.add(v2);\n\n// Print the resulting vector\nSystem.out.println(\"The resulting vector is: \" + result);\n",
              "description": "\nThis would create a vector with x=6 and y=8, since it adds 4 to 2 (the x component) and 5 to 3 (the y component)."
            },
            "name": "add",
            "code": "public Vector2f add(float x, float y) {\n        return new Vector2f(this.x + x, this.y + y);\n    }",
            "location": {
              "start": 126,
              "insert": 114,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 113,
                "end": 125
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 12
          },
          {
            "id": "dc4e9fee-fd72-e4aa-da4f-5fa45e19fcad",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes a `Vector2f` argument `r` and returns a new `Vector2f` object representing the difference between the input vector and the reference vector.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector to be subtracted from the original vector.\n\n* `x`: The first component of the vector (a double value).\n* `y`: The second component of the vector (also a double value).",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` object representing the difference between the input vector and the reference vector.\n\nThe returned Vector2f object has two components, x and y, which represent the difference between the original vector's coordinates and the given vector's coordinates. Specifically, the value of each component is equal to the corresponding coordinate of the original vector minus the coordinate of the given vector.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f v1 = new Vector2f(5, 3);\nVector2f v2 = new Vector2f(4, 2);\nVector2f result = v1.sub(v2);\nSystem.out.println(\"The result of the subtraction is: \" + result.toString());\n",
              "description": "\nHere's a breakdown of what happens when this code runs:\n\n1. `Vector2f v1` creates a new vector object with x=5 and y=3, which represents point (5, 3) in 2D space.\n2. `Vector2f v2` creates a new vector object with x=4 and y=2, which represents point (4, 2) in 2D space.\n3. `result = v1.sub(v2)` performs the subtraction operation on two vectors. The result of this operation is a new vector containing the difference between the two input vectors' x and y components, which is (1, 1).\n4. `System.out.println(\"The result of the subtraction is: \" + result.toString());` prints the result of the subtraction to the console as \"The result of the subtraction is: (1, 1)\".\n\nNote that this code only demonstrates one way of using the method. The method can also be used in other ways and with different inputs."
            },
            "name": "sub",
            "code": "public Vector2f sub(Vector2f r) {\n\t\treturn new Vector2f(x - r.getX(), y - r.getY());\n\t}",
            "location": {
              "start": 147,
              "insert": 130,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 129,
                "end": 146
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 17
          },
          {
            "id": "4aacf0ad-69b7-0c82-404b-06b5cb56fe14",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes a single floating-point argument `r` and returns a new `Vector2f` object representing the difference between the original vector's components and the given value.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "2D vector to subtract from the current vector.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` instance representing the difference between the original vector and the given value.\n\nThe `Vector2f` object returned by the function has two components, x and y, which represent the subtracted values of the original vector's x and y components, respectively. These components have the same data type as the original vector's components, i.e., they are both float values. Therefore, the returned vector has the same magnitude and direction as the original vector, but with the values of its components shifted by the given value 'r'.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f vector1 = new Vector2f(5, 3);\nfloat number = 2;\nVector2f result = vector1.sub(number);\nSystem.out.println(result); // Output: (3, 1)\n",
              "description": "\nThe above code creates a `Vector2f` instance with x and y coordinates of 5 and 3 respectively, and then uses the method sub to subtract the number 2 from it. The resulting Vector2f object is then printed using the `toString()` method, which results in the output \"(3, 1)\".\nNote that the value of 'r' passed as an argument to the method sub is a real-valued number, not another vector. Therefore, the result will be a Vector2f instance with coordinates (x - r, y - r)."
            },
            "name": "sub",
            "code": "public Vector2f sub(float r) {\n\t\treturn new Vector2f(x - r, y - r);\n\t}",
            "location": {
              "start": 167,
              "insert": 151,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 150,
                "end": 166
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 16
          },
          {
            "id": "b0922208-dc06-0786-d343-ac4389a54ff1",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "multiplies its input vector by a scalar value, resulting in a new vector with the product of the corresponding components.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector that the current vector will be multiplied by, resulting in a new 2D vector output.\n\n* `r.getX()` returns the x-coordinate of the input vector.\n* `r.getY()` returns the y-coordinate of the input vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new vector with the product of the input vectors' x and y components.\n\nThe returned value is a new Vector2f object with x and y components calculated by multiplying the current vector's x and y components with their corresponding counterparts in the passed-in argument vector r.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector2f vector1 = new Vector2f();\n        vector1.setX(3);\n        vector1.setY(4);\n        \n        Vector2f vector2 = new Vector2f();\n        vector2.setX(5);\n        vector2.setY(6);\n        \n        System.out.println(\"vector1 * vector2 = \" + vector1.mul(vector2));\n    }\n}\n",
              "description": "\nThis code will output the following:\n"
            },
            "name": "mul",
            "code": "public Vector2f mul(Vector2f r) {\n\t\treturn new Vector2f(x * r.getX(), y * r.getY());\n\t}",
            "location": {
              "start": 191,
              "insert": 171,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 170,
                "end": 190
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 20
          },
          {
            "id": "e45c73c8-f809-eb8c-9a4d-6375a78e8c71",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "multiplies its input vector by a scalar value, returning a new vector with the product.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "scalar value that is multiplied with the vector's X and Y components to produce the resultant vector.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a vector with the product of the input `r` and the corresponding component of the original vector.\n\n* The output is a `Vector2f` object, which represents a 2D point with x and y components.\n* The `x` and `y` components of the output are calculated by multiplying the original `x` and `y` components by the input parameter `r`.\n* The output has the same orientation as the original vector, meaning that it retains the original direction but is scaled by the factor `r`.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Vector2f {\n\tfloat x, y;\n\n\t// constructor that takes two arguments x and y\n\tpublic Vector2f(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t/**\n\t * Multiplies each component of a vector by the input value 'r' \n\t * (represented as a float), returning the modified vector.\n\t * \n\t * @param r scale factor that multiplies all components of the vector.\n\t * @return modified vector with x and y values multiplied by the input argument 'r'.\n\t */\n\tpublic Vector2f mul(float r) {\n\t\treturn new Vector2f(x * r, y * r);\n\t}\n\n\t// other methods...\n}\n",
              "description": "\nNow consider a program that uses this method:\n"
            },
            "name": "mul",
            "code": "public Vector2f mul(float r) {\n\t\treturn new Vector2f(x * r, y * r);\n\t}",
            "location": {
              "start": 213,
              "insert": 195,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 194,
                "end": 212
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 18
          },
          {
            "id": "4ea1151d-4adb-c196-cb45-d8bd46da91b2",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes a reference to another `Vector2f` object as input and returns a new `Vector2f` object with the component values scaled by the reciprocal of the input parameter.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector to which the current vector is being divided.\n\n* `x`: The real component of the input vector.\n* `y`: The imaginary component of the input vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new vector with the same x-coordinate as the original vector, scaled by the reciprocal of the input vector's x-coordinate.\n\nThe output is a new Vector2f object with the x-component set to the result of dividing the input parameter `x` by the r.getX() method, and the y-component set to the result of dividing the input parameter `y` by the r.getY() method.\n\nThe returned output has the same scale as the input parameter `r`.\n\nThe returned output has a consistent direction with the input parameter `r`.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f r = new Vector2f(1, 1);\nVector2f result = new Vector2f().div(r);\nassertEquals(new Vector2f(1, 1), result);\n",
              "description": "\nThis code is a unit test that verifies the behavior of the method div. It creates two instances of the class Vector2f: r and result. Then, it uses the instance method div of the result object to set its components to the results of dividing the components of the vector r by each component of itself. Finally, it compares the components of the resulting vector with the expected value (1, 1), which is the same as the original input vector, and asserts that the two vectors are equal.\nNote: The assertEquals method checks if the actual result of dividing a Vector2f instance by another one is equal to the expected result, which is also a Vector2f instance with components (1, 1). If the two vectors are not equal, the test fails and the code throws an AssertionError."
            },
            "name": "div",
            "code": "public Vector2f div(Vector2f r) {\n\t\treturn new Vector2f(x / r.getX(), y / r.getY());\n\t}",
            "location": {
              "start": 233,
              "insert": 217,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 216,
                "end": 232
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 16
          },
          {
            "id": "c84ed60a-3df2-2194-3f4f-107cea7349b7",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "takes a float argument `r` and returns a new `Vector2f` instance with x-component divided by `r` and y-component divided by `r`.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "scalar factor by which the `Vector2f` instance is to be divided.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a vector with x and y components scaled by the input parameter `r`.\n\nThe returned Vector2f object represents the division of the original Vector2f object by the input floating-point value r.\n\nThe x and y components of the returned Vector2f object have values that are equal to the original x and y components divided by the input r.\n\nThe returned Vector2f object has a length (or magnitude) that is equal to the original Vector2f object's length divided by the input r.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f vector = new Vector2f(5, 10);\nfloat divisor = 2;\nVector2f quotient = vector.div(divisor);\nSystem.out.println(\"The vector divided by the divisor is \" + quotient);\n",
              "description": "\nThis code would output the following:\n"
            },
            "name": "div",
            "code": "public Vector2f div(float r) {\n\t\treturn new Vector2f(x / r, y / r);\n\t}",
            "location": {
              "start": 253,
              "insert": 237,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 236,
                "end": 252
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 16
          },
          {
            "id": "e1fd9422-d237-36be-3347-96bc42ea9a31",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "returns a new `Vector2f` object containing the absolute values of its input components, `x` and `y`.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a new `Vector2f` object containing the absolute values of the input vector's `x` and `y` components.\n\n* The output is a new Vector2f instance, containing the absolute values of the original Vector2f's x and y components.\n* The returned Vector2f has the same scale as the original Vector2f.\n* The returned Vector2f preserves the original orientation of the Vector2f, meaning that its x-axis points in the same direction as the original Vector2f's x-axis.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f vec1 = new Vector2f(-3, 4);\nSystem.out.println(vec1); // (-3, 4)\nVector2f absVec1 = vec1.abs();\nSystem.out.println(absVec1); // (3, 4)\n",
              "description": "\nThe output should be:\n"
            },
            "name": "abs",
            "code": "public Vector2f abs() {\n\t\treturn new Vector2f(Math.abs(x), Math.abs(y));\n\t}",
            "location": {
              "start": 270,
              "insert": 257,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 256,
                "end": 269
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "c068dce1-5bbc-2485-0b4f-351fa84d58ac",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "returns a string representation of its arguments, concatenating them with parentheses and space separators.",
            "params": [],
            "returns": {
              "type_name": "String",
              "description": "a string representation of a point in the Cartesian coordinate system, consisting of an open parenthesis, two numbers, and a closing parenthesis.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Vector2f {\n\tprivate float x, y;\n\tpublic Vector2f(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t/**\n\t* returns a string representation of the vector (x,y).\n\t* @return The String representation of this object.\n\t*/\n\tpublic String toString() {\n\t\treturn \"(\" + x + \", \" + y + \")\";\n\t}\n\t\n\t/**\n\t* Sets the x and y components of a Vector2f object to the input values, returning the modified object for chaining.\n\t* @param x 2D position of the vector in the x-axis.\n\t* @param y 2nd component of the Vector2f object being modified, and its value is assigned to the y field of the object in the function.\n\t* @return A reference to the same instance of the Vector2f class with updated x and y values.\n\t*/\n\tpublic Vector2f set(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Sets the x and y components of the vector to the corresponding values of the given vector argument, and returns a reference to the modified vector object.\n\t* @param r 2D vector to be set as the value of the Vector2f object returned by the function.\n\t* @return A reference to the original vector instance with its components updated to match the values of the provided vector.\n\t*/\n\tpublic Vector2f set(Vector2f r) {\n\t\tset(r.getX(), r.getY());\n\t}\n}\n",
              "description": "\nYou can use this method in your code like this: \n"
            },
            "name": "toString",
            "code": "public String toString() {\n\t\treturn \"(\" + x + \" \" + y + \")\";\n\t}",
            "location": {
              "start": 281,
              "insert": 274,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 273,
                "end": 280
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "35b063b8-f5e3-e593-6741-0d8563f5d0a6",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "modifies the instance fields `x` and `y` of the class `Vector2f` and returns a reference to the same modified instance.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "2D coordinate of the point where the vector should be set to, and it is assigned the value passed in as an argument.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "float",
                "description": "2nd component of the `Vector2f` object being modified and is assigned the value provided by the caller.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a reference to the same `Vector2f` object, allowing it to be re-assigned with new values.\n\n* The `Vector2f` instance is updated with the new values of `x` and `y`.\n* The returned output is the same instance as the original input, with the updates applied.\n* The output has the same type and attributes as the original input.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n\tpublic static void main(String[] args) {\n\t\t// Creating a new instance of the Vector2f class\n\t\tVector2f vector = new Vector2f();\n\t\t// Setting the values of x and y components using the set method\n\t\tvector.set(3.5F, 10.6F);\n\t}\n}\n",
              "description": "\nIn this example, we created a `new` instance of the `Vector2f` class and called its `set` method with two parameters: `3.5F` for x and `10.6F` for y. The `set` method then assigned these values to the `x` and `y` member variables, respectively, of the newly created vector instance.\n\nNote that if we had not included the return statement in the set method, it would have simply modified the member variables of the vector, but it would not have returned anything. This is why when we call the set method on a vector object and then print out the values of its x and y components using the getX() and getY() methods, we see the updated values:\n"
            },
            "name": "set",
            "code": "public Vector2f set(float x, float y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}",
            "location": {
              "start": 304,
              "insert": 285,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 284,
                "end": 303
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 19
          },
          {
            "id": "89b4b9b8-bef8-94ad-2047-4bf19737cc94",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "sets the x and y components of the vector to the corresponding values of the argument vector.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D vector to be set as the new value of the `Vector2f` instance, and its `x` and `y` components are used to update the corresponding fields of the instance.\n\n* `getX()` and `getY()`: These methods are used to access the x- and y-coordinates of the vector, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector2f",
              "description": "a reference to the original vector with its components modified.\n\nThe output is a reference to the same vector instance as the input argument.\nThe x-component and y-component of the output vector are set to the corresponding components of the input argument.\nThe output vector has the same values as the input argument after the assignment.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f v = new Vector2f(); // creating a new object\nv.set(new Vector2f(10, 20)); // setting the x and y components of the vector to 10 and 20 respectively\n",
              "description": "\nThis will set the x component of the vector to 10, and the y component to 20. The returned output is a reference to the same Vector2f instance with updated x and y values. This means that the original object remains unchanged and the modified values of x and y are reflected in the returned output."
            },
            "name": "set",
            "code": "public Vector2f set(Vector2f r) {\n\t\tset(r.getX(), r.getY());\n\t\treturn this;\n\t}",
            "location": {
              "start": 327,
              "insert": 310,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 309,
                "end": 326
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 17
          },
          {
            "id": "303c6b59-0f80-21ba-9446-da87eb3fb5d3",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "converts a `Vector2f` object into a `Vector3f` object by adding an extra component representing the z-coordinate.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new `Vector3f` instance containing the values `x`, `y`, and `0`.\n\n* `x`: The value of x in the vector, representing the x-coordinate.\n* `y`: The value of y in the vector, representing the y-coordinate.\n* `z`: The value of 0 in the vector, representing the z-coordinate.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f v1 = new Vector2f(1, 0);\nVector3f v3 = v1.as3DVector();\nSystem.out.println(\"v3.x \" + v3.getX()); // output: v3.x 1\nSystem.out.println(\"v3.y \" + v3.getY()); // output: v3.y 0\nSystem.out.println(\"v3.z \" + v3.getZ()); // output: v3.z 0\n",
              "description": "\nIn this example, we create an instance of Vector2f with coordinates (1,0). Then we call as3DVector on the instance and assign the resulting vector to v3. We then print out each coordinate of v3 to show that all components are initialized to zero except for x which is initialized to 1 and y which is initialized to 0."
            },
            "name": "as3DVector",
            "code": "public Vector3f as3DVector() {\n        return new Vector3f(x, y, 0);\n    }",
            "location": {
              "start": 346,
              "insert": 332,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 331,
                "end": 345
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 14
          },
          {
            "id": "339c63de-c013-aaa2-bc4f-b82dbc8cfffe",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "returns the value of `x`, a `float` variable, as its output.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the value of `x`, which is a floating-point number representing the x-coordinate of an object.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Vector2f myVector = new Vector2f(3, 4);\nfloat xComponent = myVector.getX();\nSystem.out.println(xComponent); // prints 3\n",
              "description": "\nIn the example above, we create a `Vector2f` instance with the `new` keyword and initialize it with `3` for its `x` component and `4` for its `y` component. We then assign the result of calling `getX()` on our `myVector` to the variable `xComponent`. Finally, we print out `xComponent`, which should output `3`. This is because `getX()` simply returns the value of the `x` field within the object that it belongs to, and in this case, the value of `x` for the given vector is indeed `3`."
            },
            "name": "getX",
            "code": "public float getX() {\n\t\treturn x;\n\t}",
            "location": {
              "start": 355,
              "insert": 350,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 349,
                "end": 354
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "a8c1dc15-1831-d9aa-3142-aa77fc30c019",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "sets the value of a class instance variable `x` to the input `float` parameter.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "new value of the `x` field in the object being manipulated by the function.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector2f vector = new Vector2f();\n        vector.setX(10.5f);\n        \n        System.out.println(\"x: \" + vector.getX()); // prints 10.5f\n        System.out.println(\"y: \" + vector.getY()); // prints 0.0f\n    }\n}\n",
              "description": ""
            },
            "name": "setX",
            "code": "public void setX(float x) {\n\t\tthis.x = x;\n\t}",
            "location": {
              "start": 364,
              "insert": 359,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 358,
                "end": 363
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "54dec817-8bbc-bf98-a64b-198f71828145",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "retrieves the value of the `y` field, which is a `float` variable.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point value representing the `y` coordinate of an object.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "// Declare vector and print its initial values for x and y\nVector2f vector = new Vector2f(1, 2);\nSystem.out.println(\"Initial values of vector:\");\nSystem.out.println(\"\\tX: \" + vector.getX());\nSystem.out.println(\"\\tY: \" + vector.getY());\n\n// Set the x and y components to new values\nvector.setX(3);\nvector.setY(4);\n\n// Print updated values for x and y\nSystem.out.println(\"Updated values of vector:\");\nSystem.out.println(\"\\tX: \" + vector.getX());\nSystem.out.println(\"\\tY: \" + vector.getY());\n",
              "description": "\nThis would output the following:\n"
            },
            "name": "getY",
            "code": "public float getY() {\n\t\treturn y;\n\t}",
            "location": {
              "start": 373,
              "insert": 368,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 367,
                "end": 372
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "ffbf7ab3-ab91-3086-3642-f9a501247819",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "sets the value of the member variable `y`.",
            "params": [
              {
                "name": "y",
                "type_name": "float",
                "description": "value that will be assigned to the `y` field of the class instance being manipulated by the function.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "Vector2f vector = new Vector2f(0, 0);\nvector.setY(5);\n",
              "description": "\nIn this case, the method setY would set the y component of the vector to 5."
            },
            "name": "setY",
            "code": "public void setY(float y) {\n\t\tthis.y = y;\n\t}",
            "location": {
              "start": 383,
              "insert": 377,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 376,
                "end": 382
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "0fecb08a-ba27-5aac-7c47-e938733054e5",
            "ancestors": [
              "21f1b037-dff8-c299-a645-d46cdb9c3d24"
            ],
            "type": "function",
            "description": "compares the `x` and `y` components of the current instance with those of the provided `Vector2f` instance, returning `true` if they are equal.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector2f",
                "description": "2D point to be compared with the current vector for equality.\n\nThe `Vector2f` class represents a two-dimensional vector in homogeneous coordinates. The `x` and `y` fields represent the x- and y-coordinates of the vector, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "boolean",
              "description": "a boolean value indicating whether the object being compared to `r` has the same x and y coordinates as `r`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Vector2f p1 = new Vector2f(3, 4);\nVector2f p2 = new Vector2f(3, 4);\nSystem.out.println(p1.equals(p2)); // Outputs \"true\"\n",
              "description": "\nThis is because the `x` and `y` components of `p1` are both equal to 3, which means they are compared as the same value, and since the `y` component of `p1` is also equal to 4, this also evaluates to true. This would then print \"true\" to the console."
            },
            "name": "equals",
            "code": "public boolean equals(Vector2f r) {\n\t\treturn x == r.getX() && y == r.getY();\n\t}",
            "location": {
              "start": 398,
              "insert": 387,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 386,
                "end": 397
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 11
          }
        ]
      }
    }
  },
  {
    "name": "Vector3f.java",
    "path": "src/com/ch/math/Vector3f.java",
    "content": {
      "structured": {
        "description": "A `Vector3f` class that represents 3D vectors in the x, y, and z axes. The class provides methods for setting and retrieving the components of the vector, as well as comparing vectors for equality. Additionally, it includes methods for calculating the magnitude (length), dot product, and cross product of two vectors.",
        "diagram": "digraph G {\n    label=\"com.ch.math.Vector3f\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Vector3f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Vector2f\n        Matrix4f\n        Quaternion\n    }\n    Transform\n    Camera3D\n    Quaternion -> Vector3f \n    Quaternion -> Vector3f [style=\"dashed\"]\n    Vector3f -> Quaternion \n    Vector3f -> Quaternion [style=\"dashed\"]\n    Vector3f -> Matrix4f \n    Vector3f -> Vector3f \n    Vector3f -> Transform \n    Vector3f -> Camera3D \n    Vector3f -> Matrix4f [style=\"dashed\"]\n    Vector3f -> Vector2f \n    Vector3f -> Vector3f [style=\"dashed\"]\n}\n",
        "items": [
          {
            "id": "a1d007b2-e2f9-a783-fa41-666931ecc2df",
            "ancestors": [],
            "type": "function",
            "description": "is a data structure that represents a 3D point in the x, y, and z dimensions. It has fields for each component (x, y, and z) and provides methods for accessing and modifying those components. The class also includes methods for comparing equality with other vectors.",
            "name": "Vector3f",
            "code": "public class Vector3f {\n\n\tprivate float x;\n\tprivate float y;\n\tprivate float z;\n\n\tpublic Vector3f() {\n\t\tthis(0, 0, 0);\n\t}\n\t\n\tpublic Vector3f(float x, float y, float z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\t/**\n\t * calculates the Euclidean distance of a point from its origin using the Pythagorean\n\t * theorem.\n\t * \n\t * @returns the square root of the sum of the squares of the three Cartesian coordinates.\n\t */\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z);\n\t}\n\t\n\t/**\n\t * computes the length of a point in 3D space by squaring its coordinates and summing\n\t * them.\n\t * \n\t * @returns a value representing the length of the square of the input coordinates.\n\t */\n\tpublic float squareLength() {\n\t\treturn (float) x*x + y*y + z*z;\n\t}\n\n\t/**\n\t * computes and returns the maximum value of three input values `x`, `y`, and `z`.\n\t * \n\t * @returns the maximum value of `x`, `y`, or `z`.\n\t */\n\tpublic float max() {\n\t\treturn Math.max(x, Math.max(y, z));\n\t}\n\n\t/**\n\t * computes the dot product of a vector `r` and the input vector `x`, `y`, or `z`.\n\t * \n\t * @param r 3D vector that the dot product is being computed for.\n\t * \n\t * `r`: A `Vector3f` object representing a 3D vector with properties `x`, `y`, and `z`.\n\t * \n\t * @returns a floating-point number representing the dot product of the input vector\n\t * and the vector represented by the function parameters.\n\t */\n\tpublic float dot(Vector3f r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ();\n\t}\n\n\t/**\n\t * computes the vector that is perpendicular to two given vectors in a three-dimensional\n\t * space.\n\t * \n\t * @param r 3D vector that is being crossed with the current vector, resulting in a\n\t * new 3D vector output.\n\t * \n\t * \t- `r` is a `Vector3f` object representing a 3D vector in homogeneous coordinates.\n\t * \t- `x`, `y`, and `z` are the components of the vector in the x, y, and z directions,\n\t * respectively.\n\t * \n\t * @returns a new vector with the cross product of the input vectors.\n\t * \n\t * \t- The output is a `Vector3f` object representing the cross product of the input\n\t * vectors.\n\t * \t- The components of the output vector are given by the equations x_, y_, and z_,\n\t * which are calculated using the dot product of the input vectors.\n\t * \t- The output vector has a magnitude equal to the product of the magnitudes of the\n\t * input vectors, and its direction is perpendicular to both input vectors.\n\t */\n\tpublic Vector3f cross(Vector3f r) {\n\t\tfloat x_ = y * r.getZ() - z * r.getY();\n\t\tfloat y_ = z * r.getX() - x * r.getZ();\n\t\tfloat z_ = x * r.getY() - y * r.getX();\n\n\t\treturn new Vector3f(x_, y_, z_);\n\t}\n\n\t/**\n\t * normalizes a `Vector3f` instance by dividing its components by the magnitude of\n\t * the vector, resulting in a unitized representation of the original vector.\n\t * \n\t * @returns a vector with the magnitude of the original vector and the direction unchanged.\n\t * \n\t * The output is a `Vector3f` object that represents the normalized version of the\n\t * input vector. The normalization is done by dividing each component of the input\n\t * vector by its corresponding length.\n\t * \n\t * The resulting vector has a length of 1, which means that it is a unit vector in\n\t * the coordinate system. This property makes it useful for various mathematical\n\t * operations and applications in computer graphics, physics, and other fields.\n\t */\n\tpublic Vector3f normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Vector3f(x / length, y / length, z / length);\n\t}\n\n\t/**\n\t * rotates a 3D vector by an angle around a specified axis, based on the dot product\n\t * of the vector and the axis.\n\t * \n\t * @param axis 3D rotation axis around which the object will be rotated.\n\t * \n\t * \t- `axis`: A 3D vector representing the rotation axis. It has three components:\n\t * x, y, and z.\n\t * \n\t * @param angle 3D rotation angle of the vector around the specified axis.\n\t * \n\t * @returns a new vector that represents the rotation of the original vector along\n\t * the specified axis by the given angle.\n\t * \n\t * \t- The output is a vector representation of the rotated object.\n\t * \t- The vector components represent the position of the rotated object in 3D space\n\t * after applying the rotation.\n\t * \t- The axis of rotation is specified by the `axis` parameter, which determines the\n\t * direction of the rotation.\n\t * \t- The angle of rotation is specified by the `angle` parameter, which represents\n\t * the amount of rotation applied to the object.\n\t * \t- The function returns a new vector object that represents the rotated position,\n\t * based on the axis and angle parameters provided.\n\t */\n\tpublic Vector3f rotate(Vector3f axis, float angle) {\n\t\tfloat sinAngle = (float) Math.sin(-angle);\n\t\tfloat cosAngle = (float) Math.cos(-angle);\n\n\t\treturn this.cross(axis.mul(sinAngle)).add((this.mul(cosAngle)).add(axis.mul(this.dot(axis.mul(1 - cosAngle)))));\n\t}\n\n\t/**\n\t * rotates a `Vector3f` instance by the angle represented by the given `Quaternion`\n\t * rotation.\n\t * \n\t * @param rotation 3D rotation matrix that is applied to the `Vector3f` instance being\n\t * rotated.\n\t * \n\t * \t- Quaternion is an object that represents a 3D rotation, consisting of a scalar\n\t * component and a vector component.\n\t * \t- conjugate() returns the complex conjugate of the quaternion, which is used in\n\t * the multiplication operation.\n\t * \n\t * @returns a vector representing the rotated position of the original vector.\n\t * \n\t * \t- The output is a `Vector3f` object representing the rotated position of the\n\t * original input vector.\n\t * \t- The x, y, and z components of the output represent the rotated position in the\n\t * x, y, and z directions, respectively.\n\t * \t- The output is obtained by multiplying the rotation quaternion with the original\n\t * input vector using the `mul` method, then concatenating the result with the conjugate\n\t * of the rotation quaternion using the ` mul` method again.\n\t */\n\tpublic Vector3f rotate(Quaternion rotation) {\n\t\tQuaternion conjugate = rotation.conjugate();\n\n\t\tQuaternion w = rotation.mul(this).mul(conjugate);\n\n\t\treturn new Vector3f(w.getX(), w.getY(), w.getZ());\n\t}\n\n\t/**\n\t * calculates the linear interpolation between two vectors, resulting in a new vector\n\t * that is the weighted sum of the original vectors.\n\t * \n\t * @param dest 3D vector to which the current vector will be interpolated, and its\n\t * value is used as the starting point for the interpolation.\n\t * \n\t * \t- The `Vector3f` class is used to represent a 3D vector with floating-point values.\n\t * \t- The `sub` method calculates the difference between two vectors by subtracting\n\t * one vector from another.\n\t * \t- The `mul` method multiplies a vector by a scalar value, which in this case is\n\t * `lerpFactor`.\n\t * \t- The `add` method adds a vector to another vector or a scalar value.\n\t * \n\t * @param lerpFactor factor by which the current vector is to be interpolated towards\n\t * the destination vector.\n\t * \n\t * @returns a vector that interpolates between the input `dest` and the current\n\t * position of the object.\n\t * \n\t * The `Vector3f` object returned by the function is a result of interpolating between\n\t * the input `Vector3f` objects using the provided `lerpFactor`.\n\t * \n\t * The resulting vector has the same direction and magnitude as the input vectors,\n\t * but its coordinates are adjusted according to the interpolation factor. Specifically,\n\t * the x, y, and z components of the output vector are calculated as follows:\n\t * \n\t * x = (dest.x * lerpFactor) + (this.x * (1 - lerpFactor));\n\t * y = (dest.y * lerpFactor) + (this.y * (1 - lerpFactor));\n\t * z = (dest.z * lerpFactor) + (this.z * (1 - lerpFactor));\n\t * \n\t * Therefore, the output vector has a smoothed value between the input vectors, with\n\t * the interpolation factor determining the degree of smoothing.\n\t */\n\tpublic Vector3f lerp(Vector3f dest, float lerpFactor) {\n\t\treturn dest.sub(this).mul(lerpFactor).add(this);\n\t}\n\n\t/**\n\t * adds two `Vector3f` objects and returns a new vector with the sum of their components.\n\t * \n\t * @param r 3D vector to be added to the current vector.\n\t * \n\t * \t- `x`: The x-coordinate of the input vector.\n\t * \t- `y`: The y-coordinate of the input vector.\n\t * \t- `z`: The z-coordinate of the input vector.\n\t * \n\t * @returns a new `Vector3f` object representing the sum of the input vectors.\n\t * \n\t * The `Vector3f` object returned by the function represents a sum of two other\n\t * `Vector3f` objects. The x, y, and z components of the returned vector are calculated\n\t * by adding the corresponding components of the two input vectors.\n\t */\n\tpublic Vector3f add(Vector3f r) {\n\t\treturn new Vector3f(x + r.getX(), y + r.getY(), z + r.getZ());\n\t}\n\t\n\t/**\n\t * adds the components of a provided `Vector3f` object to the corresponding components\n\t * of the current object, resulting in an updated representation of the current object.\n\t * \n\t * @param r 3D vector to be added to the current position of the object, and its\n\t * values are used to increment the object's x, y, and z components.\n\t * \n\t * \t- `x`, `y`, and `z` are the coordinates of the vector, each representing a single\n\t * component of the vector in 3D space.\n\t */\n\tpublic void addSelf(Vector3f r) {\n\t\tthis.x += r.x;\n\t\tthis.y += r.y;\n\t\tthis.z += r.z;\n\t}\n\n\t/**\n\t * takes a single float parameter and adds it to the vector's x, y, or z component,\n\t * returning a new Vector3f instance with the updated values.\n\t * \n\t * @param r 3D vector that is added to the current vector value of the object, resulting\n\t * in a new vector with the sum of the two values.\n\t * \n\t * @returns a new `Vector3f` object with the sum of the input vector's x, y, and z\n\t * components and the given scalar value.\n\t * \n\t * The return type of the `add` function is `Vector3f`, which represents a 3D vector\n\t * with floating-point values for x, y, and z components.\n\t * \n\t * The expression `x + r` generates an integer value representing the addition of the\n\t * float argument `r` to the component `x`. Similarly, `y + r` generates an integer\n\t * value representing the addition of `r` to the component `y`, and `z + r` generates\n\t * an integer value representing the addition of `r` to the component `z`.\n\t * \n\t * The resulting vector values are then assigned to a new `Vector3f` object using the\n\t * `new Vector3f()` constructor.\n\t */\n\tpublic Vector3f add(float r) {\n\t\treturn new Vector3f(x + r, y + r, z + r);\n\t}\n\t\n\t/**\n\t * takes a `Vector3f` and a scalar value as input, returns the result of adding the\n\t * scaled vector to the current vector.\n\t * \n\t * @param v 3D vector to be scaled and added to the current vector.\n\t * \n\t * \t- `v` is a Vector3f class instance representing a 3D vector with x, y, and z components.\n\t * \t- `scale` is an input float value representing the scaling factor applied to `v`.\n\t * \n\t * @param scale scalar value that is multiplied with the input `Vector3f` before\n\t * adding it to the current vector.\n\t * \n\t * @returns a new vector that is the result of adding the given `v` vector scaled by\n\t * `scale`.\n\t * \n\t * The output is a new `Vector3f` instance that represents the sum of the original\n\t * vector and the scaled version of the input vector.\n\t * The scale factor is applied to both components of the input vector before adding\n\t * them to the original vector.\n\t * The resulting vector has the same components as the original vector, but with the\n\t * scaled components.\n\t */\n\tpublic Vector3f addScaledVector(Vector3f v, float scale) {\n\t\treturn this.add(v.mul(scale));\n\t}\n\t\n\t/**\n\t * multiplies a `Vector3f` object by a scalar value and adds it to the current vector\n\t * representation of the object.\n\t * \n\t * @param v 3D vector to be scaled.\n\t * \n\t * \t- `v`: A `Vector3f` object representing a 3D vector with x, y, and z components.\n\t * \t- `scale`: A floating-point value representing the scalar factor to be applied\n\t * to the `v` vector.\n\t * \n\t * @param scale scalar value that is multiplied with the `Vector3f` output of the\n\t * `addSelf()` method, thereby scaling the result of the method call.\n\t */\n\tpublic void addSelfScaledVector(Vector3f v, float scale) {\n\t\tthis.addSelf(v.mul(scale));\n\t}\n\n\t/**\n\t * calculates the vector difference between two `Vector3f` objects, returning a new\n\t * vector with the differences.\n\t * \n\t * @param r 3D vector to be subtracted from the input `Vector3f`.\n\t * \n\t * \t- `x`: an integer value representing the x-coordination of `r`.\n\t * \t- `y`: an integer value representing the y-coordination of `r`.\n\t * \t- `z`: an integer value representing the z-coordination of `r`.\n\t * \n\t * @returns a new `Vector3f` object representing the difference between the input\n\t * vector and the reference vector.\n\t * \n\t * \t- The returned value is a new Vector3f instance containing the difference between\n\t * the input vectors' x, y, and z components.\n\t * \t- The values of x, y, and z are calculated by subtracting the corresponding values\n\t * of the input vector r from those of the current vector.\n\t * \t- The resulting vector has the same orientation as the original vector, but it\n\t * moves in the opposite direction.\n\t */\n\tpublic Vector3f sub(Vector3f r) {\n\t\treturn new Vector3f(x - r.getX(), y - r.getY(), z - r.getZ());\n\t}\n\n\t/**\n\t * takes a single floating-point value `r` and subtracts it from the corresponding\n\t * components of a `Vector3f` object, returning a new `Vector3f` object with the\n\t * resultant values.\n\t * \n\t * @param r 3D position from which to subtract the vector.\n\t * \n\t * @returns a new `Vector3f` instance representing the difference between the original\n\t * vector and the provided value.\n\t * \n\t * The `Vector3f` object returned by the function has three components: `x`, `y`, and\n\t * `z`. Each component represents the difference between the original value and the\n\t * input parameter `r`. For example, if `x` is 2.0 and `r` is 1.0, then the `x`\n\t * component of the output will be 1.0.\n\t * \n\t * The components of the output are in a specific order, with the `x`, `y`, and `z`\n\t * components corresponding to the x, y, and z axes of a 3D coordinate system.\n\t * \n\t * The output is a new instance of the `Vector3f` class, which means it has its own\n\t * memory location and can be used independently of the original input parameters.\n\t */\n\tpublic Vector3f sub(float r) {\n\t\treturn new Vector3f(x - r, y - r, z - r);\n\t}\n\n\t/**\n\t * multiplies the components of a `Vector3f` object by the corresponding components\n\t * of another `Vector3f` object, and returns a new `Vector3f` object with the resulting\n\t * values.\n\t * \n\t * @param r 3D vector to which the current vector is multiplied, resulting in a new\n\t * 3D vector output.\n\t * \n\t * \t- `x`, `y`, and `z` are the components of `r`, which represent vectors in 3D space.\n\t * \t- `getX()`, `getY()`, and `getZ()` are methods that provide access to the individual\n\t * components of `r`.\n\t * \n\t * @returns a new vector with the product of the input vectors' coordinates.\n\t * \n\t * \t- The output is a new Vector3f object with the product of the input parameters.\n\t * \t- The x, y, and z components of the output are calculated by multiplying the\n\t * corresponding components of the input vectors.\n\t * \t- The resulting vector has the same semantic meaning as the multiplication of the\n\t * two input vectors in 3D space.\n\t */\n\tpublic Vector3f mul(Vector3f r) {\n\t\treturn new Vector3f(x * r.getX(), y * r.getY(), z * r.getZ());\n\t}\n\n\t/**\n\t * takes a single float argument and multiplies it to the corresponding components\n\t * of a `Vector3f` object, returning a new `Vector3f` object with the result.\n\t * \n\t * @param r scalar value used to multiply each component of the `Vector3f` object.\n\t * \n\t * @returns a new vector with the product of the input vector's components and the\n\t * scalar value `r`.\n\t */\n\tpublic Vector3f mul(float r) {\n\t\treturn new Vector3f(x * r, y * r, z * r);\n\t}\n\n\t/**\n\t * takes a reference to another `Vector3f` object and returns a new `Vector3f` object\n\t * with the componentwise result of dividing the input by the reference argument.\n\t * \n\t * @param r vector to be divided by, and it is used to calculate the output vector's\n\t * components.\n\t * \n\t * The `Vector3f` class represents a three-dimensional vector in homogeneous coordinates.\n\t * The `x`, `y`, and `z` attributes represent the component values of the vector.\n\t * \n\t * Therefore, when dividing a vector by another vector using this function, the output\n\t * vector will have component values computed as the ratio of the corresponding\n\t * components of the input vectors.\n\t * \n\t * @returns a new vector with the same components as the input vector, but scaled by\n\t * the reciprocal of the input value.\n\t * \n\t * \t- The output is a new `Vector3f` instance with scaled values based on the division\n\t * operation performed on the input vectors.\n\t * \t- The x, y, and z components of the output represent the scaled values of the\n\t * corresponding components of the input vectors.\n\t * \t- The scale factor in each component is calculated by dividing the corresponding\n\t * value of the input vector by the corresponding value of the input vector passed\n\t * as a parameter to the function.\n\t */\n\tpublic Vector3f div(Vector3f r) {\n\t\treturn new Vector3f(x / r.getX(), y / r.getY(), z / r.getZ());\n\t}\n\n\t/**\n\t * takes a single float argument `r` and returns a new `Vector3f` instance with x,\n\t * y, and z components scaled by the reciprocal of `r`.\n\t * \n\t * @param r scalar value that is used to divide each component of the `Vector3f`\n\t * object returned by the function.\n\t * \n\t * @returns a vector with x, y, and z components scaled by the input factor `r`.\n\t * \n\t * \t- The output is a new instance of the `Vector3f` class with the values of the\n\t * original input divided by the given scalar value.\n\t * \t- The output has the same dimensions as the input, with each component representing\n\t * the corresponding coordinate of the vector divided by the scalar value.\n\t * \t- The output is normalized to have a length of 1, ensuring that the resulting\n\t * vector is properly scaled.\n\t */\n\tpublic Vector3f div(float r) {\n\t\treturn new Vector3f(x / r, y / r, z / r);\n\t}\n\n\t/**\n\t * computes and returns a new vector with the absolute values of its component.\n\t * \n\t * @returns a new `Vector3f` instance with the absolute values of its components.\n\t * \n\t * The output is a new Vector3f object containing the absolute value of the input\n\t * vector's x, y, and z components.\n\t */\n\tpublic Vector3f abs() {\n\t\treturn new Vector3f(Math.abs(x), Math.abs(y), Math.abs(z));\n\t}\n\n\t/**\n\t * returns a string representation of a object by concatenating three values: `x`,\n\t * `y`, and `z`.\n\t * \n\t * @returns a string representation of a point in 3D space, consisting of three values\n\t * separated by spaces.\n\t */\n\tpublic String toString() {\n\t\treturn \"(\" + x + \" \" + y + \" \" + z + \")\";\n\t}\n\n\t/**\n\t * returns a `Vector2f` object containing the x and y coordinates of an entity.\n\t * \n\t * @returns a vector containing the x and y coordinates of a point.\n\t * \n\t * \t- `x`: The first component of the vector, representing the x-coordinate of the point.\n\t * \t- `y`: The second component of the vector, representing the y-coordinate of the\n\t * point.\n\t * \n\t * Both `x` and `y` are doubles, representing real numbers that represent the coordinates\n\t * of the point in a 2D space.\n\t */\n\tpublic Vector2f getXY() {\n\t\treturn new Vector2f(x, y);\n\t}\n\n\t/**\n\t * returns a `Vector2f` object representing the y and z components of a point.\n\t * \n\t * @returns a `Vector2f` object containing the values of `y` and `z`.\n\t * \n\t * \t- `y`: This represents the y-component of the vector, which is a floating-point\n\t * value.\n\t * \t- `z`: This represents the z-component of the vector, which is also a floating-point\n\t * value.\n\t * \n\t * The vector itself is an instance of the `Vector2f` class, which is a part of the\n\t * Java Foundation Library (JFL). The `Vector2f` class provides methods for manipulating\n\t * 2D vectors and represents mathematical vectors in two dimensions using homogeneous\n\t * coordinates.\n\t */\n\tpublic Vector2f getYZ() {\n\t\treturn new Vector2f(y, z);\n\t}\n\n\t/**\n\t * returns a `Vector2f` object containing the `z` and `x` components of an unknown entity.\n\t * \n\t * @returns a `Vector2f` object representing the coordinate pair (z, x).\n\t * \n\t * \t- z is a double value representing the z-component of the vector.\n\t * \t- x is a double value representing the x-component of the vector.\n\t * \t- The vector is represented as a 2D object with two components (x and z).\n\t */\n\tpublic Vector2f getZX() {\n\t\treturn new Vector2f(z, x);\n\t}\n\n\t/**\n\t * returns a `Vector2f` object representing the position (x and y coordinates) of an\n\t * object.\n\t * \n\t * @returns a `Vector2f` object containing the values of `x` and `y`.\n\t * \n\t * \t- The returned object is of type `Vector2f`, which represents a 2D point in\n\t * homogeneous coordinates.\n\t * \t- The `y` field of the object contains the Y-coordinate of the point, while the\n\t * `x` field contains the X-coordinate.\n\t * \t- The resulting object is a new instance of `Vector2f`, rather than modifying the\n\t * original input parameters.\n\t */\n\tpublic Vector2f getYX() {\n\t\treturn new Vector2f(y, x);\n\t}\n\n\t/**\n\t * generates a vector with the values of z and y.\n\t * \n\t * @returns a `Vector2f` object containing the `z` and `y` coordinates of the point.\n\t * \n\t * \t- The returned Vector2f object represents a point in 2D space with coordinates z\n\t * and y.\n\t * \t- The z coordinate is a float value representing the vertical position of the\n\t * point, ranging from -1 to 1.\n\t * \t- The y coordinate is also a float value representing the horizontal position of\n\t * the point, ranging from -1 to 1.\n\t * \n\t * Overall, the `getZY` function returns a valid 2D coordinate point that can be used\n\t * in various applications.\n\t */\n\tpublic Vector2f getZY() {\n\t\treturn new Vector2f(z, y);\n\t}\n\n\t/**\n\t * returns a `Vector2f` object containing the `x` and `z` coordinates of an entity.\n\t * \n\t * @returns a `Vector2f` object containing the `x` and `z` coordinates of a point.\n\t * \n\t * \t- The `Vector2f` object represents a 2D point with x-axis value `x` and z-axis\n\t * value `z`.\n\t * \t- The `Vector2f` class is a part of the Java Standard Library and provides\n\t * operations on 2D points.\n\t * \t- The returned object can be used in various contexts such as graphics, game\n\t * development, and mathematical calculations.\n\t */\n\tpublic Vector2f getXZ() {\n\t\treturn new Vector2f(x, z);\n\t}\n\n\t/**\n\t * modifies the components of a `Vector3f` object, assigning new values to `x`, `y`,\n\t * and `z`.\n\t * \n\t * @param x 3D position of the vector in the x-axis direction.\n\t * \n\t * @param y 2D position of the vector along the Y-axis.\n\t * \n\t * @param z 3rd component of the vector and sets its value to the provided float value.\n\t * \n\t * @returns a reference to the same `Vector3f` object, which now contains the new x,\n\t * y, and z values.\n\t * \n\t * The `Vector3f` object is modified to have new values for `x`, `y`, and `z`.\n\t * The returned object is itself, with the modifications applied.\n\t */\n\tpublic Vector3f set(float x, float y, float z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * sets the components of the `Vector3f` object to the corresponding values of the\n\t * provided `r` argument.\n\t * \n\t * @param r 3D vector to be set as the value of the `Vector3f` object.\n\t * \n\t * \t- `getX()`: Returns the x-coordinate of `r`.\n\t * \t- `getY()`: Returns the y-coordinate of `r`.\n\t * \t- `getZ()`: Returns the z-coordinate of `r`.\n\t * \n\t * @returns a reference to the modified vector instance.\n\t * \n\t * The function returns a reference to the original object, indicating that the state\n\t * of the object remains unchanged after modification. This is useful for chaining\n\t * methods together or avoiding unnecessary copies of objects.\n\t */\n\tpublic Vector3f set(Vector3f r) {\n\t\tset(r.getX(), r.getY(), r.getZ());\n\t\treturn this;\n\t}\n\n\t/**\n\t * retrieves the value of the `x` field, which is a `float` variable.\n\t * \n\t * @returns a floating-point value representing the variable `x`.\n\t */\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\t/**\n\t * sets the value of the field `x` of its object to the provided float value.\n\t * \n\t * @param x float value that will be assigned to the `x` field of the class instance\n\t * being manipulated by the function.\n\t */\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\t/**\n\t * returns the value of the `y` field.\n\t * \n\t * @returns a floating-point value representing the y coordinate of the point.\n\t */\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\t/**\n\t * sets the value of the `y` field in the current object to the provided float value.\n\t * \n\t * @param y float value that will be assigned to the `y` field of the class instance\n\t * being manipulated by the function.\n\t */\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\t/**\n\t * retrieves the value of the `z` field in the provided object.\n\t * \n\t * @returns the value of the `z` field.\n\t */\n\tpublic float getZ() {\n\t\treturn z;\n\t}\n\n\t/**\n\t * sets the value of the field `z` to the provided float argument.\n\t * \n\t * @param z 3D coordinates of an object in the `x`, `y`, and `z` dimensions, which\n\t * is stored in the instance variable `this.z` after being assigned the value provided\n\t * by the caller.\n\t */\n\tpublic void setZ(float z) {\n\t\tthis.z = z;\n\t}\n\n\t/**\n\t * compares a `Vector3f` object with another vector by checking if its `x`, `y`, and\n\t * `z` components are equal.\n\t * \n\t * @param r 3D vector that is being compared to the current vector for equality.\n\t * \n\t * \t- `x`: The first coordinate of `r`, which represents the x-axis value of the vector.\n\t * \t- `y`: The second coordinate of `r`, which represents the y-axis value of the vector.\n\t * \t- `z`: The third coordinate of `r`, which represents the z-axis value of the vector.\n\t * \n\t * @returns a boolean value indicating whether the vector's coordinates are equal to\n\t * those of the provided vector.\n\t */\n\tpublic boolean equals(Vector3f r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ();\n\t}\n\n}",
            "location": {
              "start": 10,
              "insert": 3,
              "offset": " ",
              "indent": 0,
              "comment": {
                "start": 2,
                "end": 9
              }
            },
            "item_type": "class",
            "length": 687,
            "docLength": 7
          },
          {
            "id": "e2ada3a1-a1cb-4ab3-7041-de83bb5c4970",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "calculates the Euclidean distance of a 3D point from its origin using the square root of the sum of the squares of the x, y, and z coordinates.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the square root of the sum of the squares of the coordinates of a point in 3D space.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vector = new Vector3f(1, 2, 3);\nfloat length = vector.length(); // returns 3.74\n",
              "description": "\nThe example demonstrates how to calculate the length of a 3D vector using its coordinates and the method length(). The result is stored in a variable named length."
            },
            "name": "length",
            "code": "public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z);\n\t}",
            "location": {
              "start": 32,
              "insert": 26,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 25,
                "end": 31
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "372931ee-3bd9-ffac-f140-784fa09ba6a8",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "computes the length of a point in three-dimensional space by squaring its coordinates and summing them.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point representation of the square of the length of the given vector.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "float lengthSquared = new Vector3f(1, 2, 3).squareLength();\n",
              "description": "\nIn this example the method squareLength is called on a vector of (1, 2, 3), which calculates and returns the squared length of the vector.\nThe result is then stored in a float variable named lengthSquared."
            },
            "name": "squareLength",
            "code": "public float squareLength() {\n\t\treturn (float) x*x + y*y + z*z;\n\t}",
            "location": {
              "start": 42,
              "insert": 36,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 35,
                "end": 41
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "27053bbd-697b-09bc-5946-b7c5d42bccd5",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "calculates the maximum value of three arguments: `x`, `y`, and `z`. It returns the maximum value using the `Math.max()` method.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the maximum of the input values `x`, `y`, and `z`.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    // Create a new vector and set its values to 3, -4, and 5.\n    Vector3f myVector = new Vector3f();\n    myVector.set(3, -4, 5);\n    \n    // Print the largest component of the vector using max().\n    System.out.println(\"The largest component of the vector is: \" + myVector.max());\n}\n",
              "description": "\nThis code creates a new Vector3f object and sets its components to 3, -4, and 5. It then uses the max method to print the largest component (which in this case is 5) to the console."
            },
            "name": "max",
            "code": "public float max() {\n\t\treturn Math.max(x, Math.max(y, z));\n\t}",
            "location": {
              "start": 51,
              "insert": 46,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 45,
                "end": 50
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "a9e639d7-7c9f-0ea5-1e4f-108fcda8bab2",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "computes the dot product of a `Vector3f` object and another vector, returning the result as a float value.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to be dot-producted with the current vector.\n\n* `x`, `y`, and `z` are variables of type `float` that represent the coordinates of the vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "float",
              "description": "a floating-point number representing the dot product of the input vector and the vector component.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    Vector3f v1 = new Vector3f(1, 2, 3);\n    Vector3f v2 = new Vector3f(4, 5, 6);\n    \n    float dotProduct = v1.dot(v2);\n    \n    System.out.println(dotProduct);\n}\n",
              "description": "\nIn this example the user is given a vector of (1, 2, 3) and another vector of (4, 5, 6). Then they are asked to use the dot method to find the dot product between these two vectors. This result will be returned as a float value which will then be printed out for the user to see."
            },
            "name": "dot",
            "code": "public float dot(Vector3f r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ();\n\t}",
            "location": {
              "start": 65,
              "insert": 55,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 54,
                "end": 64
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 10
          },
          {
            "id": "6c714558-f9d8-65b0-6047-fd6b9f9e12e7",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "computes the cross product between two vectors in a 3D space, returning a new vector with magnitude and direction based on the dot product of the input vectors.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to cross with the current vector.\n\n* `r` is a `Vector3f` object containing the values for the x, y, and z components.\n* `x`, `y`, and `z` are the individual component values of `r`.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector with the cross product of the input vectors.\n\n* The output is a new Vector3f object that represents the cross product of the input vectors.\n* The components of the output vector are calculated using the dot product formula for cross products, where x, y, and z are the components of the input vectors.\n* The output vector has the same magnitude as the input vectors, but its direction is perpendicular to both input vectors.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f v1 = new Vector3f(5, 7, 9);\nVector3f v2 = new Vector3f(4, 6, 8);\nVector3f result = v1.cross(v2); // returns a new vector with x=15, y=-21, and z=57\n",
              "description": "\nHere, we create two `Vector3f` objects, `v1` and `v2`, using the constructor that takes three float arguments to set their coordinates, then use the `cross()` method of v1 to compute their cross product. The result is a new vector with x=15, y=-21, and z=57, which is stored in the variable `result`."
            },
            "name": "cross",
            "code": "public Vector3f cross(Vector3f r) {\n\t\tfloat x_ = y * r.getZ() - z * r.getY();\n\t\tfloat y_ = z * r.getX() - x * r.getZ();\n\t\tfloat z_ = x * r.getY() - y * r.getX();\n\n\t\treturn new Vector3f(x_, y_, z_);\n\t}",
            "location": {
              "start": 89,
              "insert": 69,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 68,
                "end": 88
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 20
          },
          {
            "id": "76cb1701-1ad2-06b3-3944-2fdc7db64b21",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "normalizes a vector by dividing it by its magnitude, returning a new vector with the same direction but with a length equal to 1.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a normalized version of the input vector, with a length of 1.\n\n* The output is a `Vector3f` object representing a normalized version of the original vector.\n* The x, y, and z components of the output represent the normalized values of the corresponding components of the original vector, scaled by the length of the original vector.\n* The length of the output vector is always non-zero, since the normalization is done to ensure that the resulting vector has a non-zero magnitude.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f v = new Vector3f(1, 2, 3);\nVector3f nv = v.normalize();\nSystem.out.println(\"nv is: \" + nv.getX() + \", \" + nv.getY() + \", \" + nv.getZ()); // Outputs: nv is: 0.26726, 0.53452, 0.80178\n",
              "description": "\nThis code creates a new Vector3f object, sets its values to 1, 2, and 3, respectively and then uses the normalized() method to set those values to their corresponding components of the unit vector in that direction, which is computed by dividing each component by the length.\nThe output shows that the returned vector has a length of one (since the input vector has a length of sqrt(1^2 + 2^2 + 3^2) = sqrt(14) = 3.74166, but it still maintains its original x, y, and z coordinates relative to the direction of the original vector.\nThis example demonstrates how the normalized method can be used in practice by comparing the input vector with a unit vector in the same direction and showing that they are equivalent."
            },
            "name": "normalized",
            "code": "public Vector3f normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Vector3f(x / length, y / length, z / length);\n\t}",
            "location": {
              "start": 111,
              "insert": 97,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 96,
                "end": 110
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 14
          },
          {
            "id": "96560a5e-62f0-4390-9541-814beff37616",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "rotates a 3D vector by an angle around a specified axis, based on the sin and cos of the angle.",
            "params": [
              {
                "name": "axis",
                "type_name": "Vector3f",
                "description": "3D rotation axis around which the object will be rotated.\n\n* `float angle`: The angle of rotation in radians.\n* `Vector3f axis`: The axis of rotation, which can be any 3D vector representing a point in space.",
                "complex_type": true
              },
              {
                "name": "angle",
                "type_name": "float",
                "description": "3D rotation angle of the vector.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector that represents the rotated version of the original vector.\n\n* The output is a `Vector3f` object, representing the rotated position of the original vector.\n* The axis parameter represents the direction of rotation, and the angle parameter represents the angle of rotation in radians.\n* The function first computes the sine and cosine of the angle of rotation using the `Math.sin()` and `Math.cos()` methods.\n* Then, it multiplies the original vector by the sine and cosine values to create two new vectors that represent the rotated position along the axis of rotation.\n* The function then adds the result of the multiplication of the `this` object (representing the original position) and the vector created by multiplying the axis vector by the dot product of the `this` vector and a vector representing the angle of rotation in radians.\n\nThe output of the `rotate` function can be further explained as follows:\n\n* The returned vector represents the rotated position of the original vector along the specified axis of rotation.\n* The magnitude of the returned vector is equal to the magnitude of the original vector, but its direction has been rotated by the specified angle.\n* The rotation is around the origin of the coordinate system, as specified by the axis parameter.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vec = new Vector3f(0, 1, 2);\nfloat angle = (float) Math.PI / 4;\nVector3f axis = new Vector3f(0, 1, 0);\nvec.rotate(axis, angle); // returns the rotated vector\n",
              "description": "\nIn this example, we created a `Vector3f` object with coordinates `(0, 1, 2)`, which is then passed into the method `rotate` along with an axis `Vector3f` object with coordinates `(0, 1, 0)` and an angle of `Math.PI / 4`, which rotates the vector by 45 degrees around the x-axis.\n\nThe output from this code would be a new `Vector3f` object with coordinates `(-0.7071067811865475, -0.7071067811865475, 2)`. This is the result of rotating the original vector by 45 degrees around the x-axis and then adding that rotation to the original vector's coordinates.\n\nThis method first computes the sine and cosine of the angle using `Math.sin` and `Math.cos`, which are passed into the function as arguments. It then cross-multiplies the axis by its sine and multiplies the original vector by its cosine, resulting in two new vectors with the rotated components. The two resulting vectors are then added together to form the final output vector.\n\nThe `rotate` method is a useful tool for rotating 3D vectors around an arbitrary axis in 3D space. By passing in an axis and angle as arguments, it can be used to rotate any given vector by a desired amount around that axis. The method works by first computing the sine and cosine of the angle, which are then used to compute the rotated components of the original vector. These two new vectors are then added together to form the final output vector, which represents the rotated version of the original vector."
            },
            "name": "rotate",
            "code": "public Vector3f rotate(Vector3f axis, float angle) {\n\t\tfloat sinAngle = (float) Math.sin(-angle);\n\t\tfloat cosAngle = (float) Math.cos(-angle);\n\n\t\treturn this.cross(axis.mul(sinAngle)).add((this.mul(cosAngle)).add(axis.mul(this.dot(axis.mul(1 - cosAngle)))));\n\t}",
            "location": {
              "start": 141,
              "insert": 117,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 116,
                "end": 140
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 24
          },
          {
            "id": "e4aaa8f4-2b8b-56b8-914c-6440f0a65316",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "takes a quaternion parameter and rotates a `Vector3f` object by that amount, returning the resultant vector.",
            "params": [
              {
                "name": "rotation",
                "type_name": "Quaternion",
                "description": "4D quaternion of the rotation to be applied to the current vector, which is multiplied with the current vector's components to produce the new vector.\n\nThe `rotation` argument is of type `Quaternion`, which represents a 4D mathematical object used to describe rotations in 3D space. The `conjugate` property returns the conjugate of the quaternion, which is another quaternion that represents the inverse of the original quaternion.\n\nThe multiplication of `rotation` with its conjugate (`w`) results in a new quaternion `w` that represents the rotation of the input vector relative to the origin of the quaternion. The resulting quaternion `w` is then converted into a 3D vector `new Vector3f(w.getX(), w.getY(), w.getZ())`, which represents the rotated vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a vector representing the rotated position of the original vector.\n\n* The output is a `Vector3f` object representing the rotated position of the original input vector.\n* The x, y, and z components of the output represent the rotated position in the x, y, and z directions, respectively.\n* These components are derived from the multiplication of the rotation quaternion with the original input vector followed by the conjugate of the rotation quaternion.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Test {\n\tpublic static void main(String[] args) {\n\t\tQuaternion rotation = new Quaternion();\n\t\tVector3f vector = new Vector3f();\n\t\tvector.rotate(rotation);\n\t}\n}\n",
              "description": "\nThe output of this example is a Vector3f with the rotated coordinates."
            },
            "name": "rotate",
            "code": "public Vector3f rotate(Quaternion rotation) {\n\t\tQuaternion conjugate = rotation.conjugate();\n\n\t\tQuaternion w = rotation.mul(this).mul(conjugate);\n\n\t\treturn new Vector3f(w.getX(), w.getY(), w.getZ());\n\t}",
            "location": {
              "start": 170,
              "insert": 148,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 147,
                "end": 169
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 22
          },
          {
            "id": "d5d58af8-f870-e2b9-3348-bf1566ccf58a",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "interpolates a vector between two given values, using a linear interpolation formula. The resulting vector is the sum of the intermediate vectors multiplied by the interpolation factor and added to the initial vector.",
            "params": [
              {
                "name": "dest",
                "type_name": "Vector3f",
                "description": "3D vector that the current vector is being interpolated towards.\n\n* `dest` is a `Vector3f` instance representing the destination point in 3D space.\n* It has three components: `x`, `y`, and `z`, each representing the coordinate value of the destination point.\n* The `lerpFactor` argument is a floating-point number representing the interpolation factor between the current point and the destination point.",
                "complex_type": true
              },
              {
                "name": "lerpFactor",
                "type_name": "float",
                "description": "0-1 value used to interpolate between the current position of the object and its destination position.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a vector that interpolates between two given vectors.\n\nThe `Vector3f` object that is generated represents a point in 3D space with x, y, and z components.\n\nThe `dest` parameter represents the target position towards which the current position is being interpolated.\n\nThe `lerpFactor` parameter represents the interpolation factor used to blend the current position with the target position.\n\nWhen the `lerpFactor` is applied to the current position, it results in a new position that is a weighted combination of the current position and the target position.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f position = new Vector3f(5, 10, 20);\nVector3f targetPosition = new Vector3f(8, 16, 40);\nfloat lerpFactor = 0.5f;\nposition = position.lerp(targetPosition, lerpFactor);\n",
              "description": "\nIn the above example we create two `Vector3f` objects, 'position' and 'targetPosition'. We also set a float value 'lerpFactor', which represents the amount of interpolation between the current position and target position. The method 'lerp' is then used to interpolate the position object with the target position using the lerp factor."
            },
            "name": "lerp",
            "code": "public Vector3f lerp(Vector3f dest, float lerpFactor) {\n\t\treturn dest.sub(this).mul(lerpFactor).add(this);\n\t}",
            "location": {
              "start": 212,
              "insert": 178,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 177,
                "end": 211
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 34
          },
          {
            "id": "9cff23a8-dda4-7f90-1342-b72920d1c6c5",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "takes a `Vector3f` argument `r` and returns a new `Vector3f` object with the sum of the values of the current instance and the input `r`.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to be added to the current vector, resulting in a new 3D vector output.\n\nThe `Vector3f` class has three fields (`x`, `y`, and `z`) that represent the coordinates of a 3D vector in float format. Therefore, `r` is a `Vector3f` object with specific values assigned to its fields (`x`, `y`, and `z`).",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector instance with the sum of the input vectors' x, y, and z components.\n\n* The output is a `Vector3f` object that represents the sum of the input vectors.\n* The x-component of the output is equal to the sum of the x-components of the input vectors.\n* The y-component of the output is equal to the sum of the y-components of the input vectors.\n* The z-component of the output is equal to the sum of the z-components of the input vectors.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vector1 = new Vector3f(1, 2, 3);\nVector3f vector2 = new Vector3f(4, 5, 6);\nvector1.add(vector2); // vector1 is now (5, 7, 9)\n",
              "description": "\nThis example creates two instances of the `Vector3f` class and uses the add method to add them together. The resulting vector has values `(5, 7, 9)`."
            },
            "name": "add",
            "code": "public Vector3f add(Vector3f r) {\n\t\treturn new Vector3f(x + r.getX(), y + r.getY(), z + r.getZ());\n\t}",
            "location": {
              "start": 231,
              "insert": 216,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 215,
                "end": 230
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 15
          },
          {
            "id": "4748ce23-24d1-639a-fc49-7bd8d5876555",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "adds the component-wise sum of a vector to the corresponding components of the object.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector that adds its components to the corresponding components of the current object, resulting in an updated position for the object.\n\n* `x`, `y`, and `z` represent the components of the vector in the 3D space, respectively.\n* The vector is a class representing a 3D point in the mathematical representation, which is used to perform mathematical operations on it.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\tVector3f v1 = new Vector3f(0, 0, 0);\n\tVector3f v2 = new Vector3f(1, 2, 3);\n\tv1.addSelf(v2);\n}\n",
              "description": "\nThis would set the x component of vector v1 to 1 and its y component to 2 after executing addSelf, making it equal to the provided vector v2."
            },
            "name": "addSelf",
            "code": "public void addSelf(Vector3f r) {\n\t\tthis.x += r.x;\n\t\tthis.y += r.y;\n\t\tthis.z += r.z;\n\t}",
            "location": {
              "start": 245,
              "insert": 235,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 234,
                "end": 244
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 10
          },
          {
            "id": "cd82fbd8-a5b3-ddaf-914b-40f22d17f057",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "adds a scalar value to the components of a `Vector3f` object, returning a new `Vector3f` instance with the modified components.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "3D vector to be added to the current vector's components.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new `Vector3f` instance with the sum of the original vector's components and the given scalar value.\n\n* The `Vector3f` object returned by the function has an x-component that is equal to the sum of the original vector's x-component and the input value r.\n* The y-component of the returned vector is equal to the sum of the original vector's y-component and the input value r.\n* The z-component of the returned vector is equal to the sum of the original vector's z-component and the input value r.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f v1 = new Vector3f(5, 2, 8);\nVector3f v2 = v1.add(4);\nSystem.out.println(v2); // prints (9, 6, 12)\n",
              "description": "\nThe add method takes a float argument named r and returns a new Vector3f object with the sum of the corresponding components of the current vector and the given float value as its coordinates. In this example, v1 is created with the coordinate values (5, 2, 8), then the add method is called on v1 with an argument of 4, resulting in a new Vector3f object with the coordinates (9, 6, 12)."
            },
            "name": "add",
            "code": "public Vector3f add(float r) {\n\t\treturn new Vector3f(x + r, y + r, z + r);\n\t}",
            "location": {
              "start": 272,
              "insert": 251,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 250,
                "end": 271
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 21
          },
          {
            "id": "d8960800-e124-1692-f24c-c13ab9ffcdff",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "adds a scaled version of a `Vector3f` object to the current vector, scaling the components of the original vector by the specified float value.",
            "params": [
              {
                "name": "v",
                "type_name": "Vector3f",
                "description": "3D vector to be scaled and added to the current vector.\n\n* `v`: A `Vector3f` object that contains the vector to be added with a scale factor.\n* `scale`: A float value representing the scaling factor applied to the `v` vector.",
                "complex_type": true
              },
              {
                "name": "scale",
                "type_name": "float",
                "description": "scalar value by which the provided `Vector3f` instance is multiplied before being added to the current vector instance.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector that is the result of adding the provided vector scaled by the given factor to the original vector.\n\nThe `addScaledVector` function takes two arguments - `v` and `scale`. It returns a new `Vector3f` object that represents the sum of the original input vector (`this`) multiplied by the given scale factor. The resulting vector has the same components as the original input vector, but with the magnitude increased by the specified scale factor.\n\nThe returned vector has the following properties:\n\n* Magnitude: The magnitude of the returned vector is equal to the product of the magnitudes of the original input vector and the scale factor.\n* Direction: The direction of the returned vector is the same as that of the original input vector, unchanged by the scaling operation.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n\t\t// Creates two vectors with respective x, y and z components\n\t\tVector3f vector1 = new Vector3f(2.0f, 4.0f, 6.0f);\n\t\tVector3f vector2 = new Vector3f(4.0f, 8.0f, 12.0f);\n\n\t\t// Creates a scale factor of 2 and applies it to vector2\n\t\tfloat scaleFactor = 2.0f;\n\t\tvector2.addScaledVector(scaleFactor);\n}\n",
              "description": ""
            },
            "name": "addScaledVector",
            "code": "public Vector3f addScaledVector(Vector3f v, float scale) {\n\t\treturn this.add(v.mul(scale));\n\t}",
            "location": {
              "start": 298,
              "insert": 276,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 275,
                "end": 297
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 22
          },
          {
            "id": "3fb4382d-334b-dbba-f240-086cc0fdd02e",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "multiplies a `Vector3f` object by a scalar value and adds it to the current vector of the class, scaling the vector's components by the provided scale factor.",
            "params": [
              {
                "name": "v",
                "type_name": "Vector3f",
                "description": "3D vector that is being scaled, and it is multiplied by the `scale` parameter before being added to the current vector.\n\n* `v`: A Vector3f object representing a 3D vector with x, y, and z components.\n* `scale`: A scalar value indicating the scaling factor to be applied to the vector.",
                "complex_type": true
              },
              {
                "name": "scale",
                "type_name": "float",
                "description": "3D vector multiplication factor applied to the `Vector3f` object passed as an argument to the function, which results in the scaling of the vector's components.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Example {\n    public static void main(String[] args) {\n        Vector3f v1 = new Vector3f();\n        Vector3f v2 = new Vector3f();\n        \n        // Initialize the x, y, and z components of vectors v1 and v2\n        v1.setX(0);\n        v1.setY(1);\n        v1.setZ(2);\n        v2.setX(3);\n        v2.setY(4);\n        v2.setZ(5);\n        \n        // Add the scaled vector to itself, resulting in a new vector with \n        // x = 0 + (3 * 0), y = 1 + (4 * 0), and z = 2 + (5 * 0) = 2\n        v1.addSelfScaledVector(v2, 0);\n        \n        // Print the result\n        System.out.println(\"Result: \" + v1);\n    }\n}\n",
              "description": "\nOutput:\n"
            },
            "name": "addSelfScaledVector",
            "code": "public void addSelfScaledVector(Vector3f v, float scale) {\n\t\tthis.addSelf(v.mul(scale));\n\t}",
            "location": {
              "start": 315,
              "insert": 302,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 301,
                "end": 314
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "0014ad5f-d34a-9584-b645-497e7cb05c4d",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "computes the vector difference between two `Vector3f` objects, returning a new `Vector3f` object representing the difference.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector that the method will subtract from the original vector.\n\nThe `Vector3f` class represents a 3D vector with floating-point values. The instance variable `x`, `y`, and `z` represent the coordinates of the vector in the x, y, and z directions, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector representing the difference between the input vector and the given reference vector.\n\n* The Vector3f object represents the difference between the current vector and the reference vector in terms of its x, y, and z components.\n* Each component of the returned vector is calculated by subtracting the corresponding component of the reference vector.\n* The resulting vector has the same units as the original vectors.\n* The properties of the returned vector are independent of the reference vector's magnitude or direction.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector3f vectorA = new Vector3f(1, 2, 3);\n        Vector3f vectorB = new Vector3f(4, 5, 6);\n        \n        // subtracting vectors\n        System.out.println(\"The result of the subtraction is: \" + vectorA.sub(vectorB));\n    }\n}\n",
              "description": "\nThis code creates two `Vector3f` objects, one with values (1, 2, 3) and another with values (4, 5, 6). The `sub()` method is then called on the first object to subtract the second object from it. The result of this operation is printed to the console.\n\nThe output of this program would be:\n"
            },
            "name": "sub",
            "code": "public Vector3f sub(Vector3f r) {\n\t\treturn new Vector3f(x - r.getX(), y - r.getY(), z - r.getZ());\n\t}",
            "location": {
              "start": 339,
              "insert": 319,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 318,
                "end": 338
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 20
          },
          {
            "id": "b7978597-8f81-a3a1-4d40-c97111c0eff4",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "calculates the vector difference between the input vector and the reference vector.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "3D vector offset to be subtracted from the current position of the `Vector3f` object, resulting in the new position after subtraction.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector with the difference of the input value `r` from the original vector's coordinates.\n\nThe `Vector3f` object returned by the function represents a point in 3D space, with x, y, and z components representing the differences between the original position and the subtraction of r from it.\n\nThe value of the x component represents the difference between the original x position and the subtraction of r from it.\n\nThe value of the y component represents the difference between the original y position and the subtraction of r from it.\n\nThe value of the z component represents the difference between the original z position and the subtraction of r from it.\n\nIn summary, the `sub` function returns a new `Vector3f` object that represents the difference between the original position and the subtraction of r from it.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tVector3f vector = new Vector3f(1, 2, 3);\n\t\tfloat r = 5;\n\t\tvector.sub(r); // Returns a new Vector3f object with coordinates (x - r), (y - r), and (z - r)\n\t}\n}\n",
              "description": "\nThis would create a new vector with the same x, y, and z values as the original vector minus the value of 'r'."
            },
            "name": "sub",
            "code": "public Vector3f sub(float r) {\n\t\treturn new Vector3f(x - r, y - r, z - r);\n\t}",
            "location": {
              "start": 364,
              "insert": 343,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 342,
                "end": 363
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 21
          },
          {
            "id": "2bba3d8b-ba86-1890-bf46-531bc7fc7228",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "takes a `Vector3f` argument `r` and returns a new `Vector3f` instance with the product of the component values of the input vector and the corresponding components of the current vector.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to multiply with the current vector.\n\n* `x`, `y`, and `z` are the components of the vector in question.\n* `getX()`, `getY()`, and `getZ()` are methods that retrieve the values of these components, respectively.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new vector with the product of the input vectors' coordinates.\n\n* The output is a new Vector3f object that represents the multiplication of the input vectors x, y, and z with their corresponding components in the r vector.\n* The return type of the function is a Vector3f object, which means that it can hold 3D vector values.\n* The function modifies the original input variables by assigning the result of the multiplication to them.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector3f a = new Vector3f(1, 2, 3);\n        Vector3f b = new Vector3f(4, 5, 6);\n        \n        // Multiply vector a with vector b\n        Vector3f c = a.mul(b);\n        \n        System.out.println(\"Vector c: (\" + c.getX() + \", \" + c.getY() + \", \" + c.getZ() + \")\");\n    }\n}\n",
              "description": "\nThis example will print the following output on console:\n"
            },
            "name": "mul",
            "code": "public Vector3f mul(Vector3f r) {\n\t\treturn new Vector3f(x * r.getX(), y * r.getY(), z * r.getZ());\n\t}",
            "location": {
              "start": 388,
              "insert": 368,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 367,
                "end": 387
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 20
          },
          {
            "id": "1c21fff5-6e40-0eb5-234c-cae3415c211d",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "multiplies its input vector by a scalar value and returns the result as a new vector.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "scalar value used to multiply each component of the `Vector3f` instance being passed in.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a vector with the product of the component values and the input scalar value `r`.\n\nThe `Vector3f` object that is returned has three elements, each representing the product of the corresponding component of the input vector and the scalar value `r`.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vector = new Vector3f(1, 2, 3);\nvector = vector.mul(5); // x = 5, y = 10, z = 15\n",
              "description": "\nThis code will create a new `Vector3f` object with values of (5, 10, 15), which was produced by multiplying the original `Vector3f` object by the value 5."
            },
            "name": "mul",
            "code": "public Vector3f mul(float r) {\n\t\treturn new Vector3f(x * r, y * r, z * r);\n\t}",
            "location": {
              "start": 401,
              "insert": 392,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 391,
                "end": 400
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "e38432b0-5dd7-dc9e-a24b-889b2ab18922",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "divides its input vector by a given reference vector, returning a new vector with the result.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "scalar value that divides the vector `x`, `y`, and `z`.\n\n`x`, `y`, and `z` are the components of the vector, which represent the magnitude or length of the vector in the corresponding directions. These components are used to calculate the resultant vector after division with another vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a vector with the same x, y, and z components as the input vector, scaled by the reciprocal of the input value.\n\n* The output is a new `Vector3f` instance with elements scaled by the reciprocals of the corresponding elements in the input vector `r`.\n* The scaling is done element-wise, meaning that each element of the output is calculated as the input element multiplied by the reciprocal of its corresponding element in `r`.\n* The resultant vector has the same magnitude as the input vector, but its direction is inverted, meaning that it points in the opposite direction of the input vector.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Create a vector object with the coordinates (2, 4, 6)\nVector3f v = new Vector3f(2, 4, 6);\n\n// Create another vector object with the coordinates (1, 1, 1)\nVector3f r = new Vector3f(1, 1, 1);\n\n// Divide vector v by vector r and store the result in a third vector object\nVector3f q = v.div(r);\n\n// Print the x-axis, y-axis, and z-axis values of the result vector q\nSystem.out.println(\"q.x: \" + q.getX());\nSystem.out.println(\"q.y: \" + q.getY());\nSystem.out.println(\"q.z: \" + q.getZ());\n",
              "description": "\nThis code will produce the following output:\n"
            },
            "name": "div",
            "code": "public Vector3f div(Vector3f r) {\n\t\treturn new Vector3f(x / r.getX(), y / r.getY(), z / r.getZ());\n\t}",
            "location": {
              "start": 430,
              "insert": 405,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 404,
                "end": 429
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 25
          },
          {
            "id": "f5a826ab-403b-9f9e-304c-a2c25e35799a",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "takes a scalar value `r` and returns a vector with its components divided by `r`.",
            "params": [
              {
                "name": "r",
                "type_name": "float",
                "description": "scalar value used to perform the division operation on the instance variables of the `Vector3f` class.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a vector with the same x, y, and z components scaled by the given factor `r`.\n\nThe output is a `Vector3f` object, which represents a 3D vector with x, y, and z components. The values of these components are calculated by dividing the corresponding variables of the input vector by the input parameter `r`.\n\nThe returned vector has the same direction as the input vector, but its magnitude is reduced by a factor of `r`. This means that the output vector represents a scaled-down version of the original vector.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Example 1:\nVector3f a = new Vector3f(2, 4, 6);\nfloat r = 2;\na.div(r).toString(); // Output: (1, 2, 3)\n",
              "description": "\nIn this example, the `div` method is used to divide all three components of a vector by the constant `r`, which is `2`. The resulting vector is then converted into a string using its `toString()` method. It is expected that the output would be \"(1, 2, 3)\", since:\n"
            },
            "name": "div",
            "code": "public Vector3f div(float r) {\n\t\treturn new Vector3f(x / r, y / r, z / r);\n\t}",
            "location": {
              "start": 450,
              "insert": 434,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 433,
                "end": 449
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 16
          },
          {
            "id": "c323c0ee-613f-c1aa-2943-eaa3b01bbf3a",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "computes the absolute value of a vector, returning a new vector with the absolute values of its components.",
            "params": [],
            "returns": {
              "type_name": "Vector3f",
              "description": "a new `Vector3f` instance representing the absolute value of the original vector's components.\n\nThe output is a `Vector3f` object, representing a 3D vector with magnitude equal to the absolute value of the input vector's coordinates.\nThe coordinate values are in the range (-∞, +∞), where each component represents the magnitude of the corresponding component of the input vector.\nThe resulting vector has the same orientation as the input vector, i.e., its direction is unchanged.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f v1 = new Vector3f(-2, -5, 8);\nv1 = v1.abs(); // v1 is now (2, 5, 8)\n",
              "description": "\nIt returns a new vector with the absolute value of each component."
            },
            "name": "abs",
            "code": "public Vector3f abs() {\n\t\treturn new Vector3f(Math.abs(x), Math.abs(y), Math.abs(z));\n\t}",
            "location": {
              "start": 462,
              "insert": 454,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 453,
                "end": 461
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 8
          },
          {
            "id": "7e1b421b-3286-fda2-b740-3f7138567bb6",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a string representation of a given object, including its three component parts: `x`, `y`, and `z`.",
            "params": [],
            "returns": {
              "type_name": "String",
              "description": "a string representation of a point in 3D space, consisting of three numbers separated by spaces.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector3f vector = new Vector3f();\n        System.out.println(\"Vector3f Object: \" + vector);\n    }\n}\n",
              "description": "\nThe output should look like the following:\n"
            },
            "name": "toString",
            "code": "public String toString() {\n\t\treturn \"(\" + x + \" \" + y + \" \" + z + \")\";\n\t}",
            "location": {
              "start": 473,
              "insert": 466,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 465,
                "end": 472
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "a830aeb2-f44a-91a2-ef4e-036e2cea75e7",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a `Vector2f` object containing the x and y coordinates of a point.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a `Vector2f` object containing the x and y coordinates of the point.\n\n* The `Vector2f` object returned represents a 2D point in homogeneous coordinates, with x and y components representing the horizontal and vertical positions of the point, respectively.\n* The `x` and `y` components of the vector have real-valued attributes that represent the absolute values of the corresponding position coordinates.\n* As a result, the `getXY` function returns a valid 2D point with x and y components that can be used in various contexts within the code.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vec = new Vector3f(1, 2, 3);\nVector2f xy = vec.getXY();\n\n// The returned vector (xy) has the coordinates of the original vector (vec), but with only two dimensions.\nSystem.out.println(xy); // Outputs: (1, 2)\n",
              "description": "\nThis example shows how to use the getXY method on an instance of Vector3f and retrieve a new instance of Vector2f with only two dimensions containing the original vector's x and y coordinates."
            },
            "name": "getXY",
            "code": "public Vector2f getXY() {\n\t\treturn new Vector2f(x, y);\n\t}",
            "location": {
              "start": 489,
              "insert": 477,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 476,
                "end": 488
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 12
          },
          {
            "id": "6b920820-d5a6-e095-b944-99981e6f25f0",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a `Vector2f` object representing the y and z coordinates of a point.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a `Vector2f` object representing the y- and z-coordinates of a point.\n\nThe `Vector2f` object returned represents a 2D point in homogeneous coordinates with two components, `y` and `z`, which represent the Y and Z coordinates, respectively.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public class Example {\n\tpublic static void main(String[] args) {\n\t\tVector3f vector = new Vector3f();\n\t\tvector.set(1, 2, 3);\n\t\tVector2f yz = vector.getYZ();\n\t\tSystem.out.println(\"y: \" + yz.getY() + \", z: \" + yz.getZ()); // Outputs: y: 2, z: 3\n\t}\n}\n",
              "description": "\nThe above code creates a new instance of `Vector2f` from the values of `y` and `z` in the provided `Vector3f`. The returned vector is then printed out to the console."
            },
            "name": "getYZ",
            "code": "public Vector2f getYZ() {\n\t\treturn new Vector2f(y, z);\n\t}",
            "location": {
              "start": 508,
              "insert": 493,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 492,
                "end": 507
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 15
          },
          {
            "id": "d3fdafd2-6307-c489-ba4b-70a59cefae7d",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a `Vector2f` object representing the component values of z and x.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a vector object of type `Vector2f`, containing the values of `z` and `x`.\n\n* `z`: The z-coordinate of the point represented by the Vector2f object. It is a double value that represents the vertical component of the point in the xy plane.\n* `x`: The x-coordinate of the point represented by the Vector2f object. It is also a double value that represents the horizontal component of the point in the xy plane.\n\nThese values can be used to represent any point in the 2D space, with the z-coordinate representing the height and the x and y coordinates representing the position on the xy plane.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector2f vector2d = new Vector3f(0, 1, 0).getZX();\n",
              "description": "\nThis code creates a new 2D vector that has the values of x and z from the original 3D vector. The created vector would have the coordinates (0, 0) in the x-axis direction and (0, 1) in the y-axis direction."
            },
            "name": "getZX",
            "code": "public Vector2f getZX() {\n\t\treturn new Vector2f(z, x);\n\t}",
            "location": {
              "start": 521,
              "insert": 512,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 511,
                "end": 520
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 9
          },
          {
            "id": "d4d1a218-6b73-d3af-964d-1e0593dca54b",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a `Vector2f` object containing the `y` and `x` coordinates of a point.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a `Vector2f` object containing the `y` and `x` coordinates of a point.\n\nThe output is a `Vector2f` object, which represents a 2D point with two elements - `y` and `x`. The values of these elements correspond to the x-coordinate and y-coordinate of the point, respectively.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public Vector2f v = new Vector3f(1, 2, 3);\n\nVector2f yx = v.getYX();\nSystem.out.println(\"Y-component of vector: \" + yx.getY());\nSystem.out.println(\"X-component of vector: \" + yx.getX());\n",
              "description": "\nThe above code will print out the following output to the console:\n"
            },
            "name": "getYX",
            "code": "public Vector2f getYX() {\n\t\treturn new Vector2f(y, x);\n\t}",
            "location": {
              "start": 538,
              "insert": 525,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 524,
                "end": 537
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "1d6bdd66-0bec-7697-4946-b32c5cda3074",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a `Vector2f` object representing the z-coordinate and y-coordinate of a point.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a `Vector2f` object representing the component values of z and y.\n\n* z: The y-coordinate value of the vector.\n* y: The x-coordinate value of the vector.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vector = new Vector3f(1, 2, 3);\nVector2f zy = vector.getZY();\nSystem.out.println(\"X coordinate of the ZY component: \" + zy.getX());\nSystem.out.println(\"Y coordinate of the ZY component: \" + zy.getY());\n",
              "description": "\nHere is an explanation of how to use the getZY method and why it works. The getZY() method returns a new Vector2f object with the coordinates from the 3D vector (x, y, z) in the order of z-component followed by y-component. The example uses the getX() and getY() methods to retrieve the coordinates of the ZY component."
            },
            "name": "getZY",
            "code": "public Vector2f getZY() {\n\t\treturn new Vector2f(z, y);\n\t}",
            "location": {
              "start": 557,
              "insert": 542,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 541,
                "end": 556
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 15
          },
          {
            "id": "faf2b213-da04-63bd-2e4f-934f209303a9",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns a `Vector2f` object representing the x and z coordinates of a point.",
            "params": [],
            "returns": {
              "type_name": "Vector2f",
              "description": "a `Vector2f` object containing the x and z coordinates of a point.\n\n* `x`: The first component of the vector represents the x-coordinate of the point. It is a double value that ranges from -1 to 1.\n* `z`: The second component of the vector represents the z-coordinate of the point. It is a double value that ranges from -1 to 1.\n\nThe output of the function is a `Vector2f` object, which is a two-dimensional vector in the homogeneous coordinates format. This means that the x and z components are represented as separate values, rather than being combined into a single value as in other coordinate systems.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "public static void main(String[] args) {\n    Vector3f vector = new Vector3f(1, 2, 3);\n    Vector2f xzVector = vector.getXZ();\n    System.out.println(\"x = \" + xzVector.getX());\n    System.out.println(\"y = \" + xzVector.getY());\n}\n",
              "description": "\nIn this example, a new Vector3f instance is created with values 1, 2, and 3 in the x, y, and z components respectively. A method call to getXZ() is made on this instance, which returns a Vector2f object containing values for its x and z coordinates, while leaving the value of y unchanged. The resulting Vector2f object is then printed out using getters for its respective components (x and y)."
            },
            "name": "getXZ",
            "code": "public Vector2f getXZ() {\n\t\treturn new Vector2f(x, z);\n\t}",
            "location": {
              "start": 573,
              "insert": 561,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 560,
                "end": 572
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 12
          },
          {
            "id": "5876a14c-d2a4-3bae-f249-c709e056d18a",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "updates the components of a `Vector3f` object with the specified values, returning the modified object for further manipulation.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "3D position of the vector along the x-axis.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "float",
                "description": "2D position of the vector in the Y-axis.",
                "complex_type": false
              },
              {
                "name": "z",
                "type_name": "float",
                "description": "3rd component of the `Vector3f` object, which is being set to the provided value.",
                "complex_type": false
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a reference to the modified `Vector3f` object.\n\nThe `Vector3f` object is modified to have its `x`, `y`, and `z` components set to the input values `x`, `y`, and `z`, respectively.\n\nAfter modification, the returned object is a reference to the same instance of `Vector3f`. This means that any modifications made to the returned object will affect the original object as well.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "Vector3f vec1 = new Vector3f(0, 0, 0);\nvec1.set(5, 10, 20); // Sets the x, y, and z components of vec1 to 5, 10, and 20, respectively.\n",
              "description": "\nThe method set takes three arguments (x, y, and z) which are all floats. The method returns a reference to the same Vector3f object that is being modified by this call. This allows for chaining methods together or avoiding unnecessary copies of objects."
            },
            "name": "set",
            "code": "public Vector3f set(float x, float y, float z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\treturn this;\n\t}",
            "location": {
              "start": 593,
              "insert": 577,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 576,
                "end": 592
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 16
          },
          {
            "id": "008f1398-e258-86b8-e747-1183d4a182d1",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "sets the component values of this vector to the corresponding values of the provided reference object.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to set the values of the `Vector3f` object.\n\nThe function takes in a `Vector3f` object `r`, which represents a 3D vector with three components: `x`, `y`, and `z`. Each component is a floating-point number that represents the magnitude and direction of the vector. The function sets each component of the receiver vector to the corresponding component of the input vector, updating the properties of the receiver object.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "Vector3f",
              "description": "a reference to the original `Vector3f` instance, unchanged.\n\n* `Vector3f r`: This is the input parameter passed to the function, which represents a 3D vector in homogeneous coordinates.\n* `set(r.getX(), r.getY(), r.getZ())`: This line of code sets the components of the returned output vector to the corresponding values of the input vector `r`.",
              "complex_type": true
            },
            "usage": {
              "language": "java",
              "code": "// Create two vector objects with different values for x, y, and z\nVector3f v1 = new Vector3f(10, 20, 30);\nVector3f v2 = new Vector3f(40, 50, 60);\n\n// Set the first object's coordinates to those of the second vector\nv1.set(v2);\n",
              "description": ""
            },
            "name": "set",
            "code": "public Vector3f set(Vector3f r) {\n\t\tset(r.getX(), r.getY(), r.getZ());\n\t\treturn this;\n\t}",
            "location": {
              "start": 616,
              "insert": 600,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 599,
                "end": 615
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 16
          },
          {
            "id": "f82bc069-9910-fa86-9843-69f3426e95f0",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "returns the value of the `x` field.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "the value of the `x` field.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Example {\n\tpublic static void main(String[] args) {\n\t\tVector3f v = new Vector3f();\n\t\tv.set(1, 2, 3);\n\t\tSystem.out.println(v.getX()); // prints 1.0\n\t}\n}\n",
              "description": "\nThe example code uses the getX() method to print the value of the variable x in the Vector3f object v, which is initially set to (1, 2, 3) using the constructor. The result is 1.0 because the x coordinate is represented as a floating-point number in Java."
            },
            "name": "getX",
            "code": "public float getX() {\n\t\treturn x;\n\t}",
            "location": {
              "start": 626,
              "insert": 621,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 620,
                "end": 625
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "f28e65e3-42d6-aaac-ab44-9a2a8c10845a",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "sets the value of the object's `x` field to the provided float argument.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "float value to be assigned to the instance variable `x` of the class on which the `setX()` method is defined.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Vector3f {\n    private float x;\n    private float y;\n    private float z;\n\n    public Vector3f(float x, float y, float z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    // getters and setters\n    public float getX() { return x; }\n    public void setX(float x) {\n        this.x = x;\n    }\n\n    public float getY() { return y; }\n    public void setY(float y) {\n        this.y = y;\n    }\n\n    public float getZ() { return z; }\n    public void setZ(float z) {\n        this.z = z;\n    }\n}\n\n// Example usage\nVector3f myVector = new Vector3f(0, 0, 0);\nmyVector.setX(12);\nSystem.out.println(\"x: \" + myVector.getX()); // prints x: 12\n",
              "description": ""
            },
            "name": "setX",
            "code": "public void setX(float x) {\n\t\tthis.x = x;\n\t}",
            "location": {
              "start": 636,
              "insert": 630,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 629,
                "end": 635
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "1f32ef32-1cea-f48a-3e49-59740a831d94",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "retrieves the value of the `y` field, which is a `float` variable.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point value representing the y-coordinate of a point.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n  public static void main(String[] args) {\n    Vector3f vector = new Vector3f();\n    float y = vector.getY();\n    System.out.println(\"Y: \" + y);\n  }\n}\n",
              "description": "\nThis program creates a new `Vector3f` object and retrieves the value of its `y` component using the method getY(). The retrieved value is then printed to the console."
            },
            "name": "getY",
            "code": "public float getY() {\n\t\treturn y;\n\t}",
            "location": {
              "start": 645,
              "insert": 640,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 639,
                "end": 644
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "7460cdc4-a12f-cb82-4e48-9268d2fbe4ed",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "sets the value of the object's `y` field to the provided float value.",
            "params": [
              {
                "name": "y",
                "type_name": "float",
                "description": "new value of the `y` field in the object being modified by the `setY()` method.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "Vector3f v = new Vector3f(1, 2, 3);\nv.setY(4);\nSystem.out.println(v); // prints \"(1.0, 4.0, 3.0)\"\n",
              "description": "\nThe input for the method is a float value (y) and it sets the y-axis coordinate of the vector to that value. The output of the setY method will be the coordinates of the modified vector object."
            },
            "name": "setY",
            "code": "public void setY(float y) {\n\t\tthis.y = y;\n\t}",
            "location": {
              "start": 655,
              "insert": 649,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 648,
                "end": 654
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "94155d1b-e100-de96-4546-7981f9ab3fca",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "retrieves the value of the variable `z`.",
            "params": [],
            "returns": {
              "type_name": "float",
              "description": "a floating-point value representing the z component of an object's position.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n    public static void main(String[] args) {\n        Vector3f vec = new Vector3f();\n        System.out.println(\"X: \" + vec.getX());\n        System.out.println(\"Y: \" + vec.getY());\n        System.out.println(\"Z: \" + vec.getZ());\n    }\n}\n",
              "description": "\nThis example creates a new `Vector3f` object and prints the values of its x, y, and z components. The output should be something like this:\n"
            },
            "name": "getZ",
            "code": "public float getZ() {\n\t\treturn z;\n\t}",
            "location": {
              "start": 664,
              "insert": 659,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 658,
                "end": 663
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 5
          },
          {
            "id": "9db8eff2-f68c-fdaf-1341-f2bc8a051d67",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "sets the value of the `z` field of an object to the provided float value.",
            "params": [
              {
                "name": "z",
                "type_name": "float",
                "description": "3D coordinate of the object in the x, y, and z dimensions, and its value is assigned to the `z` field of the class instance.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Example {\n  public static void main(String[] args) {\n    Vector3f vector = new Vector3f();\n    float zValue = 5;\n    vector.setZ(zValue);\n    System.out.println(vector.getZ()); // Outputs: 5\n  }\n}\n",
              "description": ""
            },
            "name": "setZ",
            "code": "public void setZ(float z) {\n\t\tthis.z = z;\n\t}",
            "location": {
              "start": 675,
              "insert": 668,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 667,
                "end": 674
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "80a5d69f-93db-01aa-774d-36279c008c51",
            "ancestors": [
              "a1d007b2-e2f9-a783-fa41-666931ecc2df"
            ],
            "type": "function",
            "description": "compares the `x`, `y`, and `z` components of two `Vector3f` objects and returns `true` if they are equal, otherwise `false`.",
            "params": [
              {
                "name": "r",
                "type_name": "Vector3f",
                "description": "3D vector to which the current vector is compared for equality.\n\n* `x`: The first component of the `Vector3f` object, which corresponds to the x-coordinate of the vector.\n* `y`: The second component of the `Vector3f` object, which corresponds to the y-coordinate of the vector.\n* `z`: The third component of the `Vector3f` object, which corresponds to the z-coordinate of the vector.",
                "complex_type": true
              }
            ],
            "returns": {
              "type_name": "boolean",
              "description": "a boolean value indicating whether the vector's components are equal to those of the provided vector.",
              "complex_type": false
            },
            "usage": {
              "language": "java",
              "code": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tVector3f v1 = new Vector3f(0, 0, 0);\n\t\tVector3f v2 = new Vector3f(0, 0, 0);\n\t\tSystem.out.println(\"v1 and v2 are equal: \" + v1.equals(v2)); // Output: v1 and v2 are equal: true\n\t}\n}\n",
              "description": ""
            },
            "name": "equals",
            "code": "public boolean equals(Vector3f r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ();\n\t}",
            "location": {
              "start": 692,
              "insert": 679,
              "offset": "\t",
              "indent": 1,
              "comment": {
                "start": 678,
                "end": 691
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          }
        ]
      }
    }
  },
  {
    "name": "Block.java",
    "path": "src/com/ch/voxel/Block.java",
    "content": {
      "structured": {
        "description": "A class called `Block` that represents a 3D voxel in a grid. The class has several instance fields, including `x`, `y`, and `z` which represent the position of the voxel in the grid, and `ft`, `bk`, `tp`, `bt`, `lt`, and `rt` which represent various flags or properties of the voxel. The code also includes a constructor that initializes the instance fields and sets the flags to their default values.",
        "diagram": "digraph G {\n    label=\"com.ch.voxel.Block\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Block [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    Chunk\n    Block -> Chunk \n}\n",
        "items": [
          {
            "id": "3b997320-4de0-1a8c-7048-36f43401f2fe",
            "ancestors": [],
            "type": "function",
            "description": "represents a three-dimensional block with various properties, including position (x, y, z) and flags for different states (ft, bk, tp, bt, lt, rt).\nFields:\n\t- z (int): represents the block's depth in the voxel world.\n\t- rt (boolean): in the Block class represents whether the block is right-clickable.\n\n",
            "fields": [
              {
                "name": "z",
                "type_name": "int",
                "value": null,
                "constant": false,
                "class_name": "Block",
                "description": "represents the block's depth in the voxel world."
              },
              {
                "name": "rt",
                "type_name": "boolean",
                "value": null,
                "constant": false,
                "class_name": "Block",
                "description": "in the Block class represents whether the block is right-clickable."
              }
            ],
            "name": "Block",
            "code": "public class Block {\n\t\n\tpublic int x, y, z;\n\tpublic boolean ft, bk, tp, bt, lt, rt;\n\t\n\tpublic Block(int x, int y, int z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\t\n\t\tthis.ft = false;\n\t\tthis.bk = false;\n\t\tthis.tp = false;\n\t\tthis.bt = false;\n\t\tthis.lt = false;\n\t\tthis.rt = false;\n\t}\n\n}",
            "location": {
              "start": 3,
              "insert": 3,
              "offset": " ",
              "indent": 0,
              "comment": null
            },
            "item_type": "class",
            "length": 19,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "Chunk.java",
    "path": "src/com/ch/voxel/Chunk.java",
    "content": {
      "structured": {
        "description": "",
        "diagram": "digraph G {\n    label=\"com.ch.voxel.Chunk\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Chunk [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Block\n    }\n    subgraph cluster_1 {\n        label=\"math\"\n        color=\"#33363A\"\n        Matrix4f\n    }\n    Model\n    Block -> Chunk \n    Chunk -> Model \n    Chunk -> Matrix4f \n}\n",
        "items": [
          {
            "id": "6773cd94-c890-44a3-9f5d-7e3a7a931321",
            "ancestors": [],
            "type": "function",
            "name": "toGenModel",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 148,
              "start": 148
            },
            "returns": false,
            "params": [
              {
                "name": "now",
                "type": "boolean"
              }
            ],
            "code": "public void toGenModel(boolean now) {\n\n\t\tint max_index = 0;\n//\t\tSystem.out.println(\"gen model\");\n\t\tfor (int i = 0; i < CHUNK_SIZE_CUBED; i++) {\n\t\t\tBlock b = blocks[i];\n\t\t\tif (b != null) {\n\t\t\t\tmax_index = gen(vertices, indices, b, max_index);\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"vertice   : \" + vertices.size() / 5 + \" -- floats : \" + vertices.size());\n//\t\tSystem.out.println(\"indices   : \" + indices.size());\n//\t\tSystem.out.println(\"triangles : \" + indices.size() / 3);\n//\t\tSystem.out.println(\"quads     : \" + indices.size() / 6);\n//\t\tSystem.out.println(\"---------------------------\\nloading model arrays\");\n\t\t\n\t\t// cant implement filtering and re-indexing for textured cubes\n//\t\t{\n//\t\t\t\n//\t\t\tArrayList<Integer>\n//\t\t\t\n//\t\t}\n\t\t\n//\t\treturn Model.load(Util.toFloatArray(new_vertices), Util.toIntArray(new_indices));\n\t\t\n\t\tif (now) {\n\t\t\tcreateModel();\n\t\t\tto_gen_model = false;\n\t\t} else {\n\t\t\tto_gen_model = true;\n\t\t}\n\t\t\n\t}",
            "skip": false,
            "docLength": null,
            "length": 34,
            "comment": {
              "description": "Generates a 3D model from a set of vertices, indices, and blocks. It determines the maximum index, generates new vertices and indices, and creates the model.",
              "params": [
                {
                  "name": "now",
                  "type": "boolean",
                  "description": "boolean flag to indicate whether the model should be re-generated or loaded from existing arrays, with a value of `true` for re-generation and `false` for loading."
                }
              ],
              "returns": null
            }
          },
          {
            "id": "442e8c80-0f89-4ab3-8250-579646d9792a",
            "ancestors": [],
            "type": "function",
            "name": "gen",
            "location": {
              "offset": "\t",
              "indent": 1,
              "insert": 194,
              "start": 194
            },
            "returns": "int",
            "params": [
              {
                "name": "vertices",
                "type": "List<Float>"
              },
              {
                "name": "indices",
                "type": "List<Integer>"
              },
              {
                "name": "block",
                "type": "Block"
              },
              {
                "name": "max_index",
                "type": "int"
              }
            ],
            "code": "private static int gen(List<Float> vertices, List<Integer> indices, Block block, int max_index) {\n\t\t\n\t\tfloat x = block.x;\n\t\tfloat y = block.y;\n\t\tfloat z = block.z;\n\t\t\n\t\tif (block.ft) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,   0, 0, //\n\t\t\t\tx+1, y,   z,   1, 0, //\n\t\t\t\tx+1, y+1, z,   1, 1, //\n\t\t\t\tx,   y+1, z,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bk) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z+1,   1, 0, //\n\t\t\t\tx+1, y,   z+1,   0, 0, //\n\t\t\t\tx+1, y+1, z+1,   0, 1, //\n\t\t\t\tx,   y+1, z+1,   1, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.bt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     0, 0, //\n\t\t\t\tx+1, y,   z,   \t 1, 0, //\n\t\t\t\tx+1, y,   z+1,   1, 1, //\n\t\t\t\tx,   y,   z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.tp) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y+1, z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     1, 0, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.lt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx,   y,   z,     1, 0, //\n\t\t\t\tx,   y+1, z,     1, 1, //\n\t\t\t\tx,   y+1, z+1,   0, 1, //\n\t\t\t\tx,   y,   z+1,   0, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 1, 2, 0, 2, 3}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\tif (block.rt) {\n\t\t\tfloat[] tmp_v = { //\n\t\t\t\tx+1, y,   z,     0, 0, //\n\t\t\t\tx+1, y+1, z,     0, 1, //\n\t\t\t\tx+1, y+1, z+1,   1, 1, //\n\t\t\t\tx+1, y,   z+1,   1, 0, //\n\t\t\t}; //\n\t\t\tfor (float f : tmp_v) vertices.add(f);\n\t\t\tfor (int i : new int[] {0, 3, 2, 0, 2, 1}) indices.add(max_index + i);\n\t\t\tmax_index += 4;\n\t\t}\n\t\treturn max_index;\n\t}",
            "skip": false,
            "docLength": null,
            "length": 74,
            "comment": {
              "description": "Generates high-quality documentation for given code by adding vertices and indices to a list, based on the block type and its position in the space.",
              "params": [
                {
                  "name": "vertices",
                  "type": "List<Float>",
                  "description": "2D coordinates of the vertices that make up the 3D shape of the block, and is used to add those vertices to a list for further processing."
                },
                {
                  "name": "indices",
                  "type": "List<Integer>",
                  "description": "3D indices of vertices in the mesh, and is used to update the array `vertices` by adding or removing indices based on the type of block being processed."
                },
                {
                  "name": "block",
                  "type": "Block",
                  "description": "3D block being generated and determines which type of geometry is added to the vertices and indices lists."
                },
                {
                  "name": "max_index",
                  "type": "int",
                  "description": "0-based index of the current block being processed, and is used to update the indices array with the new vertex positions and to increment the index for each new block."
                }
              ],
              "returns": {
                "type": "int",
                "description": "an integer representing the maximum index value added to the `indices` list for each block type."
              }
            }
          }
        ]
      }
    }
  },
  {
    "name": "World.java",
    "path": "src/com/ch/voxel/World.java",
    "content": {
      "structured": {
        "description": "A 3D rendering engine for generating and updating chunks of a 3D world. The engine uses a separate thread for chunk generation, which is executed when the main thread is idle. The chunk generation algorithm checks if the current position in the world is within a chunk boundary, and if so, generates a new chunk if none exists or updates an existing one. The render method takes a shader and camera object as input and renders the chunks using the shader's uniforms to color them based on their positions in the world.",
        "image": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera Pages: 1 -->\n<svg width=\"115pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 115.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"100,-74 7,-74 7,-55 100,-55 100,-74\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera3D.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"107,-19 0,-19 0,0 107,0 107,-19\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D</text>\n</a>\n</g>\n</g>\n<!-- Node1&#45;&gt;Node2 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node1&#45;&gt;Node2</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M53.5,-44.66C53.5,-35.93 53.5,-25.99 53.5,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"50,-44.75 53.5,-54.75 57,-44.75 50,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n",
        "diagram": "digraph G {\n    label=\"com.ch.voxel.World\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            World [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n    }\n    Camera\n    Shader\n    Shader -> World \n    Camera -> World \n}\n",
        "items": [
          {
            "id": "05a4a8b5-9aba-caa9-e145-47b16eb26470",
            "ancestors": [],
            "type": "function",
            "description": "in the provided code is a 3D rendering engine that manages a grid of chunks, each representing a small part of the game world. The World class has several methods for updating and rendering the chunks, including `gen`, `render`, and `updateBlocks`. The `gen` method is responsible for generating new chunks based on the current position of the player, while the `render` method renders the chunks using a shader and a camera. The `updateBlocks` method updates the blocks in each chunk based on the player's position.\n\nOverall, the World class seems to be the core component of the 3D rendering engine, handling the management and rendering of the game world.",
            "name": "World",
            "code": "public class World {\n\n\tprivate int x, y, z; // in chunks\n\t\t\t// private int cunk_max;\n\tprivate Chunk[][][] chunks; // TODO: unwrap\n\tprivate int W = 4, H = 2, D = 4;\n\n\tpublic World() {\n\t\tx = 0;\n\t\ty = 0;\n\t\tz = 0;\n\t\tchunks = new Chunk[W][H][D];\n\t\tgen();\n\t}\n\t\n\tprivate void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}\n\n\tpublic void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}\n\n\tpublic void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\n\t// public\n\n}",
            "location": {
              "start": 9,
              "insert": 9,
              "offset": " ",
              "indent": 0,
              "comment": null
            },
            "item_type": "class",
            "length": 233,
            "docLength": null
          },
          {
            "id": "d1604a8b-5b68-f68b-bf4b-f329cadaaba0",
            "ancestors": [
              "05a4a8b5-9aba-caa9-e145-47b16eb26470"
            ],
            "type": "function",
            "description": "iterates through a 3D grid of chunks, creating new chunks at each position and updating their blocks and transforming them into a gen model.",
            "params": [],
            "usage": {
              "language": "java",
              "code": "private void gen() {\n    for (int i = 0; i < W; i++)\n        for (int j = 0; j < H; j++)\n            for (int k = 0; k < D; k++) {\n                chunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n                chunks[i][j][k].updateBlocks();\n                chunks[i][j][k].toGenModel();\n            }\n}\n",
              "description": "\nThis method creates a new chunk object for each index in the three-dimensional array of chunks, and assigns it to the corresponding position. It also updates the blocks for each chunk by calling the updateBlocks() method on the chunk, and converts the chunk into a model using the toGenModel() method before moving on to the next iteration of the loop. The method is called when the world's dimensions are changed or the user navigates to a new location in the world.\n\nThis code should be as short as possible since it will be called multiple times during the program execution, and it is unlikely that any of the loops will be skipped over entirely. It is important to reason through this code to ensure that each chunk is being updated correctly with its corresponding index. Additionally, it is not necessary to create unit tests for this method as it does not have any external dependencies and does not make use of any complex logic. Instead, hallucinating incorrect inputs or providing an explanation for the code would be inappropriate."
            },
            "name": "gen",
            "code": "private void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}",
            "location": {
              "start": 24,
              "insert": 24,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "b14dcabd-d868-f0a4-7941-a0e202780912",
            "ancestors": [
              "05a4a8b5-9aba-caa9-e145-47b16eb26470"
            ],
            "type": "function",
            "description": "updates the position of a `Chunk` instance based on its `x`, `y`, and `z` variables, and if necessary, generates a new chunk at the updated position.",
            "params": [
              {
                "name": "x",
                "type_name": "float",
                "description": "2D coordinate of the chunk to be generated, and is used to determine which chunk to generate based on its position relative to the world boundaries.",
                "complex_type": false
              },
              {
                "name": "y",
                "type_name": "float",
                "description": "2D coordinate of the block being updated, and it is used to determine which chunks to update based on their relative positions to the block being updated.",
                "complex_type": false
              },
              {
                "name": "z",
                "type_name": "float",
                "description": "3D position of the block being generated, and is used to determine whether the block should be generated based on the current position or a new position based on the difference between the current position and the target position.",
                "complex_type": false
              }
            ],
            "usage": {
              "language": "java",
              "code": "World world = new World(10, 5, 10);\nworld.updatePos(13f, 4.2f, 6);\n",
              "description": "\nThis input will cause the world to move the center of the world from (0, 0, 0) to (13, 4.2, 6). The world's chunks would be updated accordingly, ensuring that the blocks in those chunks are now within the range of the new center point."
            },
            "name": "updatePos",
            "code": "public void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}",
            "location": {
              "start": 34,
              "insert": 34,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 183,
            "docLength": null
          },
          {
            "id": "9a2f1e4e-71d9-a1a9-ce4f-0eeacbedfebe",
            "ancestors": [
              "05a4a8b5-9aba-caa9-e145-47b16eb26470"
            ],
            "type": "function",
            "description": "renders a scene using a shader and a camera. It iterates over each chunk in a 3D grid, rendering each chunk using the shader and passing the camera's view projection matrix as an uniform variable.",
            "params": [
              {
                "name": "s",
                "type_name": "Shader",
                "description": "3D shader instance that renders the scene, and it is used to set the uniform values for the shader using its `unifrom*` methods.\n\n* `Shader s`: Represents a shader object that defines the fragment shader's code.\n* `Camera c`: Represents a camera object that provides the viewpoint for rendering the 3D scene.\n* `W`, `H`, and `D`: Indicate the dimensions of the image to be rendered, respectively.\n* `chunks[][][]`: A two-dimensional array representing a 3D scene with chunks of varying sizes. Each chunk has three properties: `x`, `y`, and `z`, which represent its position in the 3D space.\n* `Chunk ch`: Represents an individual chunk in the 3D scene, with properties `x`, `y`, and `z`.\n* `Color cl`: Represents a color object created from the hash code of the chunk's position in the 3D space. The color is used to set the fragment shader's uniform values.\n* `r`, `g`, and `b`: Represents the red, green, and blue components of the color, respectively. These values are set using the `unifrom` method.\n* `MVP`: Represents a matrix object that represents the viewprojection transformation of the camera. This transformation is used to transform the chunk's position in 3D space into screen coordinates.\n* `modelMatrix`: Represents a matrix object that represents the modelview transformation of the chunk's position in 3D space. This transformation is used to transform the chunk's position in 3D space into the world coordinate system.",
                "complex_type": true
              },
              {
                "name": "c",
                "type_name": "Camera",
                "description": "3D camera object, which is used to transform the model's vertices according to the camera's viewprojection matrix.\n\n* `c`: A `Camera` object representing the camera used for rendering. Its properties include the viewport dimensions (`W`, `H`), field of view (`fov`), and projection matrix (`getViewProjection`).\n\nThe code inside the function iterates over the chunks in a 3D grid, applying the following operations to each chunk:\n\n1. Creating a color object based on the chunk's position (`ch.x`, `ch.y`, `ch.z`) using hash code method.\n2. Calculating and storing the red, green, and blue values of the color object in the `r`, `g`, and `b` variables respectively.\n3. Setting the uniform values for the shader program using the `uniformf` method with the name `\"color\"` and passing the calculated values as arguments.\n4. Setting the uniform value for the modelview matrix (`MVP`) using the `unifromMat4` method with the name `\"MVP\"` and passing the product of the viewprojection matrix and the model matrix as an argument.\n5. Drawing the 3D model associated with the chunk using the `getModel().draw()` method.",
                "complex_type": true
              }
            ],
            "usage": {
              "language": "java",
              "code": "public class Game {\n    private Shader s;\n    private Camera c;\n\n    public void run() {\n        // create shader, camera, and world\n        this.s = new Shader();\n        this.c = new Camera();\n        World w = new World();\n\n        while (true) {\n            // render the scene\n            s.use();\n            c.setView(new Vec3f());\n            c.setProjection(Matrix4f.IDENTITY);\n            w.render(s, c);\n        }\n    }\n}\n",
              "description": "\nThis code creates a Shader, Camera, and World object, and then repeatedly renders the scene using the render() method. The parameters of the render() method are the shader used for drawing (the first parameter) and the camera that is being used to view the scene (the second parameter). This code assumes that the render() method has already been implemented to perform the actual rendering, and it will not work as-is."
            },
            "name": "render",
            "code": "public void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}",
            "location": {
              "start": 218,
              "insert": 218,
              "offset": "\t",
              "indent": 1,
              "comment": null
            },
            "item_type": "method",
            "length": 20,
            "docLength": null
          }
        ]
      }
    }
  }
]