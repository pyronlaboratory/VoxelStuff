{"name":"SimplexNoise.java","path":"src/com/ch/SimplexNoise.java","content":{"structured":{"description":"a function that calculates the signed distance transform of an input image using the Parzen windowing technique. The function takes an image as input and returns the transformed image in the form of a scalar value representing the signed distance from each pixel's center to the nearest corner of a regular hexagon inscribed within the image. The code uses the Java Collections Framework (JCF) for storing and manipulating the image's corners in a 2D array, as well as the Java Math library for calculating dot products and scalar multiplications. Specifically, it:\n\n* Uses a 2D array to store the image's corners in a structured format.\n* Defines a function that iterates over each corner of the image and calculates its contribution to the signed distance transform by computing the dot product of the gradient vector at that corner with the input pixel's coordinates, and then scales the result by a factor that ranges from -1 to 1.\n* Combines the contributions from all corners to produce the final signed distance transform value for each pixel in the image.","diagram":"digraph G {\n    label=\"com.ch.SimplexNoise\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n}\n","items":[{"id":"f613fda5-8f11-ada9-e842-5b0fcab3a66c","ancestors":[],"type":"function","description":"in Java is used to generate noise patterns using the Simplex Noise algorithm. It provides a simple way to generate noise patterns for various applications such as graphics, games, and scientific simulations. The class has several methods that take integer parameters and return a double value representing the noise pattern at that location. These methods include:\n\n* `noise(int x, int y)`: Generates noise at a specific location (x,y) based on the Simplex Noise algorithm.\n* `noise2D(int x0, int y0, int w0, int h0)`: Generates noise in a 2D space using the second simplex corner.\n* `noise3D(int x0, int y0, int z0, int w0)`: Generates noise in a 3D space using all four simplex corners.\n* `perlinNoise(int x, int y)`: Generates Perlin noise at a specific location (x,y) based on the Simplex Noise algorithm.\n\nThese methods take different integer parameters and return a double value representing the noise pattern at that location.","name":"SimplexNoise","code":"public class SimplexNoise { // Simplex noise in 2D, 3D and 4D\n\t private static int grad3[][] = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},\n\t {1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},\n\t {0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};\n\t private static int grad4[][]= {{0,1,1,1}, {0,1,1,-1}, {0,1,-1,1}, {0,1,-1,-1},\n\t {0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},\n\t {1,0,1,1}, {1,0,1,-1}, {1,0,-1,1}, {1,0,-1,-1},\n\t {-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},\n\t {1,1,0,1}, {1,1,0,-1}, {1,-1,0,1}, {1,-1,0,-1},\n\t {-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},\n\t {1,1,1,0}, {1,1,-1,0}, {1,-1,1,0}, {1,-1,-1,0},\n\t {-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}};\n\t private static int p[] = {151,160,137,91,90,15,\n\t 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n\t 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n\t 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n\t 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n\t 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n\t 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n\t 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n\t 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n\t 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n\t 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n\t 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};\n\t // To remove the need for index wrapping, double the permutation table length\n\t private static int perm[] = new int[512];\n\t static { for(int i=0; i<512; i++) perm[i]=p[i & 255]; }\n\t // A lookup table to traverse the simplex around a given point in 4D.\n\t // Details can be found where this table is used, in the 4D noise method.\n\t private static int simplex[][] = {\n\t {0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},\n\t {0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},\n\t {1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},\n\t {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},\n\t {2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},\n\t {2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}};\n\t // This method is a *lot* faster than using (int)Math.floor(x)\n\t\t/**\n\t\t * computes the nearest integer to a given double value, either rounding up or down\n\t\t * depending on the value's sign.\n\t\t * \n\t\t * @param x double value to be rounded, which is used to determine the integer return\n\t\t * value between 0 and (inclusive) or between 0 and (exclusive).\n\t\t * \n\t\t * @returns an integer value representing the nearest integer to the given double value.\n\t\t */\n\t private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }\n\t\t/**\n\t\t * takes a two-dimensional array `g` and two scalar arguments `x` and `y`, returning\n\t\t * their dot product.\n\t\t * \n\t\t * @param g 2D coordinates of a point in the Cartesian coordinate system, with the\n\t\t * first element of the array representing the x-coordinate and the second element\n\t\t * representing the y-coordinate.\n\t\t * \n\t\t * @param x 0-based coordinate of a point in the two-dimensional space, where it is\n\t\t * multiplied by the corresponding element of the input array `g` to produce the dot\n\t\t * product value.\n\t\t * \n\t\t * @param y 2nd element of the input array `g`.\n\t\t * \n\t\t * @returns a double value computed as the product of two input arguments.\n\t\t */\n\t private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }\n\t\t/**\n\t\t * takes four arguments: `g`, `x`, `y`, and `z`. It returns a double value calculated\n\t\t * by multiplying the elements of the `g` array with `x`, `y`, and `z`, respectively,\n\t\t * and then summing them.\n\t\t * \n\t\t * @param g 3D coordinates of a point in the function's calculation of the dot product\n\t\t * between the 3D vector (represented by `x`, `y`, and `z`) and some other unknown\n\t\t * 3D vector.\n\t\t * \n\t\t * @param x 0th element of an array of doubles, which is multiplied by the input value\n\t\t * before being combined with the inputs for the 1st and 2nd parameters to produce\n\t\t * the output value.\n\t\t * \n\t\t * @param y second dimension of the array `g`, which is multiplied by the argument\n\t\t * `y` and added to the result of the multiplication of the first element of the array\n\t\t * with the argument `x`.\n\t\t * \n\t\t * @param z 3rd dimension of the input array `g`, and is multiplied by the corresponding\n\t\t * element of the array when calculating the output value.\n\t\t * \n\t\t * @returns a scalar value representing the dot product of the given vectors.\n\t\t */\n\t private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }\n\t\t/**\n\t\t * computes the dot product of a given array of integers `g` with a set of scalars\n\t\t * `x`, `y`, `z`, and `w`. The function returns the result of the dot product computation.\n\t\t * \n\t\t * @param g 4-dimensional coordinates of a point in space, with each element of the\n\t\t * array representing one dimension of the coordinate system.\n\t\t * \n\t\t * @param x 0th element of the input array `g`.\n\t\t * \n\t\t * @param y 2nd element of the input array `g`.\n\t\t * \n\t\t * @param z 3rd dimension of the array `g`, and is multiplied by the value of `w`\n\t\t * before being combined with the other input parameters to produce the output result.\n\t\t * \n\t\t * @param w 4th component of a point in 3D space, which is multiplied by the corresponding\n\t\t * value of the array `g` to produce the output result.\n\t\t * \n\t\t * @returns a double value representing the dot product of the input vectors.\n\t\t */\n\t private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }\n\t // 2D simplex noise\n\t\t/**\n\t\t * generates a noise value based on the input coordinates (x, y) and a simplex-based\n\t\t * hash function. The output is a scaled value between [-1, 1].\n\t\t * \n\t\t * @param xin 2D coordinate of the point where the noise is being evaluated, and it\n\t\t * is used to calculate the hashed gradient indices for the three simplex corners.\n\t\t * \n\t\t * @param yin 2D noise value for the y-coordinate of the pixel being processed, which\n\t\t * is used to compute the contribution from the middle simplex corner.\n\t\t * \n\t\t * @returns a scaled noise value between [-1, 1], calculated based on the distances\n\t\t * from three simplex corners in Cartesian coordinates.\n\t\t */\n\t public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }\n\t // 3D simplex noise\n\t\t/**\n\t\t * generates a noise value based on four corner points in 3D space, using a Hashed\n\t\t * Gradient Index (HGI) approach to calculate the contribution from each corner. The\n\t\t * output is a scaled noise value within [-1,1].\n\t\t * \n\t\t * @param xin 3D noise simulation's x-coordinate of the current position.\n\t\t * \n\t\t * @param yin 3D noise generator's input value for the vertical dimension, which is\n\t\t * skewed and then used to determine the simplex cell it belongs to.\n\t\t * \n\t\t * @param zin 3D coordinate of the current point in the noise simulation, which is\n\t\t * used to calculate the contributions from the four simplex corners and the final\n\t\t * noise value.\n\t\t * \n\t\t * @returns a scalar value between -1 and 1, representing a noise value for a given\n\t\t * set of input coordinates.\n\t\t */\n\t public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }\n\t // 4D simplex noise\n\t\t/**\n\t\t * generates a noise signal in the Gradient Descent optimization algorithm, by\n\t\t * calculating the contribution from five simplex corners and scaling it to cover the\n\t\t * range [-1,1].\n\t\t * \n\t\t * @param x 3D coordinates of the point for which the gradient is being computed, and\n\t\t * it is used to calculate the contributions from the five simplex corners.\n\t\t * \n\t\t * @param y 2nd dimension of the simplex grid, and is used to calculate the contributions\n\t\t * from each corner of the simplex in the gradient calculation.\n\t\t * \n\t\t * @param z 3D position of the simplex corner being evaluated, and it is used to\n\t\t * calculate the contribution from that corner to the gradient of the objective function.\n\t\t * \n\t\t * @param w 4th coordinate of the current point in the \"simplex\" array, which is used\n\t\t * to calculate the contribution from the fourth corner of the simplex in the dot\n\t\t * product with the gradient vectors.\n\t\t * \n\t\t * @returns a scalar value between -1 and 1 that represents the noise added to the\n\t\t * gradient of a signed distance field.\n\t\t */\n\t double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }\n\t}","location":{"start":10,"insert":3,"offset":" ","indent":0,"comment":{"start":2,"end":9}},"item_type":"class","length":424,"docLength":7},{"id":"8ced5120-624e-47ba-aa4d-e0231467983e","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"computes the nearest integer to a given double value, returning it as an int. If the input is positive, it returns the exact integer value. Otherwise, it returns the integer value minus 1.","params":[{"name":"x","type_name":"double","description":"floating-point number that is to be rounded to an integer using the fast floor algorithm.","complex_type":false}],"returns":{"type_name":"int","description":"an integer value between 0 and the original double value, inclusive.","complex_type":false},"name":"fastfloor","code":"private static int fastfloor(double x) {\n\t return x>0 ? (int)x : (int)x-1;\n\t }","location":{"start":59,"insert":50,"offset":"\t","indent":2,"comment":{"start":49,"end":58}},"item_type":"method","length":3,"docLength":9},{"id":"881c96cc-af3d-2f91-e047-a8a5e301f6ca","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"computes the dot product of a given vector and another scalar value.","params":[{"name":"g","type_name":"int","description":"2D coordinates of a point in the function.","complex_type":false},{"name":"x","type_name":"double","description":"0-based index of the first element in the input array of integers, which is multiplied by the value of `x` before being combined with the value of `y`.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point being calculated and is multiplied by `g[1]` before being added to the result of the multiplication of `g[0]` and `x`.","complex_type":false}],"returns":{"type_name":"double","description":"a double value calculated by multiplying the elements of an integer array with the input values `x` and `y`.","complex_type":false},"name":"dot","code":"private static double dot(int g[], double x, double y) {\n\t return g[0]*x + g[1]*y; }","location":{"start":78,"insert":62,"offset":"\t","indent":2,"comment":{"start":61,"end":77}},"item_type":"method","length":2,"docLength":16},{"id":"629f78ce-bb45-fca1-f246-f5d974636246","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"computes the dot product of a given vector and another scalar value, using the elements of the input vector as coefficients.","params":[{"name":"g","type_name":"int","description":"3D coordinates of a point in the function, with each element of the array corresponding to a coordinate (x, y, or z).","complex_type":false},{"name":"x","type_name":"double","description":"0th component of the input array `g`.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the dot product calculation in the function `dot()`.","complex_type":false},{"name":"z","type_name":"double","description":"3rd dimension of the array `g`, which is multiplied by the corresponding element of the array to calculate the output value.","complex_type":false}],"returns":{"type_name":"double","description":"a value representing the dot product of the given vectors.","complex_type":false},"name":"dot","code":"private static double dot(int g[], double x, double y, double z) {\n\t return g[0]*x + g[1]*y + g[2]*z; }","location":{"start":102,"insert":80,"offset":"\t","indent":2,"comment":{"start":79,"end":101}},"item_type":"method","length":2,"docLength":22},{"id":"a7719c1b-7340-35bf-bd4a-be9e175223c2","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"computes the dot product of four arguments: `x`, `y`, `z`, and `w`. It returns the result as a double value.","params":[{"name":"g","type_name":"int","description":"4-dimensional coordinate of the point where the dot product is being computed, with each element of `g` corresponding to one of the four coordinates (x, y, z, and w).","complex_type":false},{"name":"x","type_name":"double","description":"0th element of an array `g`, which is multiplied by `x` before combining with the other parameters to compute the output value.","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point in 3D space where the dot product is being calculated.","complex_type":false},{"name":"z","type_name":"double","description":"3rd dimension of the input array `g`, which is multiplied by the value of `w` and added to the results of the previous multiplication and addition operations.","complex_type":false},{"name":"w","type_name":"double","description":"4th component of the input array, which is multiplied by `g[3]` and added to the output result.","complex_type":false}],"returns":{"type_name":"double","description":"a floating-point number representing the dot product of the input vectors.","complex_type":false},"name":"dot","code":"private static double dot(int g[], double x, double y, double z, double w) {\n\t return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }","location":{"start":123,"insert":104,"offset":"\t","indent":2,"comment":{"start":103,"end":122}},"item_type":"method","length":2,"docLength":19},{"id":"65197806-fee1-1e83-de47-ba2815f72f1e","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"generates a noise value based on the distance from a grid origin, using an equilateral triangle simplex to estimate the noise at different locations. The function calculates the contribution from each corner of the simplex and returns the scaled final noise value within the interval [-1,1].","params":[{"name":"xin","type_name":"double","description":"2D position of the point in the input space, which is skewed to determine which simplex cell it belongs to.","complex_type":false},{"name":"yin","type_name":"double","description":"2D noise input coordinate, which is used to calculate the hashed gradient indices and contribute to the final noise value.","complex_type":false}],"returns":{"type_name":"double","description":"a scaled value between -1 and 1, representing a noise value in the interval [-1,1].","complex_type":false},"name":"noise","code":"public static double noise(double xin, double yin) {\n\t double n0, n1, n2; // Noise contributions from the three corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n\t double s = (xin+yin)*F2; // Hairy factor for 2D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t final double G2 = (3.0-Math.sqrt(3.0))/6.0;\n\t double t = (i+j)*G2;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y) space\n\t double Y0 = j-t;\n\t double x0 = xin-X0; // The x,y distances from the cell origin\n\t double y0 = yin-Y0;\n\t // For the 2D case, the simplex shape is an equilateral triangle.\n\t // Determine which simplex we are in.\n\t int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\t if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\t // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t // c = (3-sqrt(3))/6\n\t double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\t double y1 = y0 - j1 + G2;\n\t double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\t double y2 = y0 - 1.0 + 2.0 * G2;\n\t // Work out the hashed gradient indices of the three simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int gi0 = perm[ii+perm[jj]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1]] % 12;\n\t int gi2 = perm[ii+1+perm[jj+1]] % 12;\n\t // Calculate the contribution from the three corners\n\t double t0 = 0.5 - x0*x0-y0*y0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n\t }\n\t double t1 = 0.5 - x1*x1-y1*y1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1);\n\t }\n\t double t2 = 0.5 - x2*x2-y2*y2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to return values in the interval [-1,1].\n\t return 70.0 * (n0 + n1 + n2);\n\t }","location":{"start":139,"insert":126,"offset":"\t","indent":2,"comment":{"start":125,"end":138}},"item_type":"method","length":54,"docLength":13},{"id":"c5ebbdc2-2e61-019d-9f46-8aae1d8d4658","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"generates a noise value for a given point in a 3D space, based on the coordinates of four simplex corners and their hashed gradient indices. The noise value is calculated as a sum of contributions from each corner, scaled to stay within [-1,1].","params":[{"name":"xin","type_name":"double","description":"3D coordinate of the point at which noise is being calculated.","complex_type":false},{"name":"yin","type_name":"double","description":"2D input value for the current 3D noise generation, which is skewed and unskewed to determine the simplex cell it belongs to.","complex_type":false},{"name":"zin","type_name":"double","description":"3D noise value at a specific point in space, which is used as an input to the function and affects the calculation of the noise contribution from each simplex corner.","complex_type":false}],"returns":{"type_name":"double","description":"a scaled noise value between [-1, 1], calculated from the contributions of four simplex corners.","complex_type":false},"name":"noise","code":"public static double noise(double xin, double yin, double zin) {\n\t double n0, n1, n2, n3; // Noise contributions from the four corners\n\t // Skew the input space to determine which simplex cell we're in\n\t final double F3 = 1.0/3.0;\n\t double s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D\n\t int i = fastfloor(xin+s);\n\t int j = fastfloor(yin+s);\n\t int k = fastfloor(zin+s);\n\t final double G3 = 1.0/6.0; // Very nice and simple unskew factor, too\n\t double t = (i+j+k)*G3;\n\t double X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n\t double Y0 = j-t;\n\t double Z0 = k-t;\n\t double x0 = xin-X0; // The x,y,z distances from the cell origin\n\t double y0 = yin-Y0;\n\t double z0 = zin-Z0;\n\t // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n\t // Determine which simplex we are in.\n\t int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\t int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\t if(x0>=y0) {\n\t if(y0>=z0)\n\t { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order\n\t }\n\t else { // x0<y0\n\t if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t }\n\t // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n\t // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n\t // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n\t // c = 1/6.\n\t double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\t double y1 = y0 - j1 + G3;\n\t double z1 = z0 - k1 + G3;\n\t double x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n\t double y2 = y0 - j2 + 2.0*G3;\n\t double z2 = z0 - k2 + 2.0*G3;\n\t double x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n\t double y3 = y0 - 1.0 + 3.0*G3;\n\t double z3 = z0 - 1.0 + 3.0*G3;\n\t // Work out the hashed gradient indices of the four simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;\n\t int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;\n\t // Calculate the contribution from the four corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);\n\t }\n\t // Add contributions from each corner to get the final noise value.\n\t // The result is scaled to stay just inside [-1,1]\n\t return 32.0*(n0 + n1 + n2 + n3);\n\t }","location":{"start":211,"insert":194,"offset":"\t","indent":2,"comment":{"start":193,"end":210}},"item_type":"method","length":81,"docLength":17},{"id":"ed369083-ebc5-b0b8-4b42-20978b8290a1","ancestors":["f613fda5-8f11-ada9-e842-5b0fcab3a66c"],"type":"function","description":"calculates a Perlin noise simulation at a given position and scale, using a simplex-based algorithm to generate a set of coordinates that are then used to calculate the noise value.","params":[{"name":"x","type_name":"double","description":"3D coordinates of the point to evaluate the gradient at, and it is used in the calculation of the contribution from each simplex corner in the gradients array (`grad4`).","complex_type":false},{"name":"y","type_name":"double","description":"2nd coordinate of the point being gradients computed for, and is used to calculate the contribution from the second corner of the simplex in the gradient calculation.","complex_type":false},{"name":"z","type_name":"double","description":"3D position of the simplex corner in the grid, which is used to calculate the gradient contribution from that corner in the dot product calculation.","complex_type":false},{"name":"w","type_name":"double","description":"4th coordinate of the gradient vector, which is used to compute the dot product with the simplex corners' positions in the `(x,y,z)` space.","complex_type":false}],"returns":{"type_name":"double","description":"a scalar value between -1 and 1 that represents the complexity of a given point cloud.","complex_type":false},"usage":{"language":"java","code":"import java.util.Random;\npublic class NoiseExample {\n    public static void main(String[] args) {\n        //Initialize the random object with a seed for reproducible results\n        Random r = new Random(1234);\n        int width = 500;\n        int height = 500;\n        double[][] noiseMap = new double[width][height];\n        for (int i = 0; i < width; i++) {\n            for (int j = 0; j < height; j++) {\n                //Use the method noise to generate a value between 0 and 1\n                noiseMap[i][j] = SimplexNoise.noise(i * 0.01, j * 0.01, r);\n            }\n        }\n    }\n}\n","description":""},"name":"noise","code":"double noise(double x, double y, double z, double w) {\n\n\t // The skewing and unskewing factors are hairy again for the 4D case\n\t final double F4 = (Math.sqrt(5.0)-1.0)/4.0;\n\t final double G4 = (5.0-Math.sqrt(5.0))/20.0;\n\t double n0, n1, n2, n3, n4; // Noise contributions from the five corners\n\t // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\t double s = (x + y + z + w) * F4; // Factor for 4D skewing\n\t int i = fastfloor(x + s);\n\t int j = fastfloor(y + s);\n\t int k = fastfloor(z + s);\n\t int l = fastfloor(w + s);\n\t double t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\t double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\t double Y0 = j - t;\n\t double Z0 = k - t;\n\t double W0 = l - t;\n\t double x0 = x - X0; // The x,y,z,w distances from the cell origin\n\t double y0 = y - Y0;\n\t double z0 = z - Z0;\n\t double w0 = w - W0;\n\t // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n\t // To find out which of the 24 possible simplices we're in, we need to\n\t // determine the magnitude ordering of x0, y0, z0 and w0.\n\t // The method below is a good way of finding the ordering of x,y,z,w and\n\t // then find the correct traversal order for the simplex were in.\n\t // First, six pair-wise comparisons are performed between each possible pair\n\t // of the four coordinates, and the results are used to add up binary bits\n\t // for an integer index.\n\t int c1 = (x0 > y0) ? 32 : 0;\n\t int c2 = (x0 > z0) ? 16 : 0;\n\t int c3 = (y0 > z0) ? 8 : 0;\n\t int c4 = (x0 > w0) ? 4 : 0;\n\t int c5 = (y0 > w0) ? 2 : 0;\n\t int c6 = (z0 > w0) ? 1 : 0;\n\t int c = c1 + c2 + c3 + c4 + c5 + c6;\n\t int i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\t int i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\t int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n\t // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n\t // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n\t // impossible. Only the 24 indices which have non-zero entries make any sense.\n\t // We use a thresholding to set the coordinates in turn from the largest magnitude.\n\t // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\t i1 = simplex[c][0]>=3 ? 1 : 0;\n\t j1 = simplex[c][1]>=3 ? 1 : 0;\n\t k1 = simplex[c][2]>=3 ? 1 : 0;\n\t l1 = simplex[c][3]>=3 ? 1 : 0;\n\t // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\t i2 = simplex[c][0]>=2 ? 1 : 0;\n\t j2 = simplex[c][1]>=2 ? 1 : 0;\n\t k2 = simplex[c][2]>=2 ? 1 : 0;\n\t l2 = simplex[c][3]>=2 ? 1 : 0;\n\t // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\t i3 = simplex[c][0]>=1 ? 1 : 0;\n\t j3 = simplex[c][1]>=1 ? 1 : 0;\n\t k3 = simplex[c][2]>=1 ? 1 : 0;\n\t l3 = simplex[c][3]>=1 ? 1 : 0;\n\t // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\t double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\t double y1 = y0 - j1 + G4;\n\t double z1 = z0 - k1 + G4;\n\t double w1 = w0 - l1 + G4;\n\t double x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords\n\t double y2 = y0 - j2 + 2.0*G4;\n\t double z2 = z0 - k2 + 2.0*G4;\n\t double w2 = w0 - l2 + 2.0*G4;\n\t double x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords\n\t double y3 = y0 - j3 + 3.0*G4;\n\t double z3 = z0 - k3 + 3.0*G4;\n\t double w3 = w0 - l3 + 3.0*G4;\n\t double x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords\n\t double y4 = y0 - 1.0 + 4.0*G4;\n\t double z4 = z0 - 1.0 + 4.0*G4;\n\t double w4 = w0 - 1.0 + 4.0*G4;\n\t // Work out the hashed gradient indices of the five simplex corners\n\t int ii = i & 255;\n\t int jj = j & 255;\n\t int kk = k & 255;\n\t int ll = l & 255;\n\t int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;\n\t int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;\n\t int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;\n\t int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;\n\t int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;\n\t // Calculate the contribution from the five corners\n\t double t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n\t if(t0<0) n0 = 0.0;\n\t else {\n\t t0 *= t0;\n\t n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);\n\t }\n\t double t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n\t if(t1<0) n1 = 0.0;\n\t else {\n\t t1 *= t1;\n\t n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);\n\t }\n\t double t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n\t if(t2<0) n2 = 0.0;\n\t else {\n\t t2 *= t2;\n\t n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);\n\t }\n\t double t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n\t if(t3<0) n3 = 0.0;\n\t else {\n\t t3 *= t3;\n\t n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);\n\t }\n\t double t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n\t if(t4<0) n4 = 0.0;\n\t else {\n\t t4 *= t4;\n\t n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);\n\t }\n\t // Sum up and scale the result to cover the range [-1,1]\n\t return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\t }","location":{"start":314,"insert":293,"offset":"\t","indent":2,"comment":{"start":292,"end":313}},"item_type":"method","length":119,"docLength":21}]}}}