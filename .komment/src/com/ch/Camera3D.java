{"name":"Camera3D.java","path":"src/com/ch/Camera3D.java","content":{"structured":{"description":"A class called `CameraStruct3D` that encapsulates a 3D camera's perspective projection matrix and provides methods for calculating the matrix and getting its elements. It also includes a `processInput` method that processes input events from the mouse and keyboard to adjust the position and rotation of an object based on user input, with modulation of movement speed by a factor determined by the L shift key. Additionally, it includes a `move` method for moving an entity in a 3D space by applying a translation to its current position based on a direction vector and a scaling factor.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera3D.CameraStruct3D Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera3D.CameraStruct3D</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera_1_1CameraStruct.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2&#45;&gt;Node1 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node2&#45;&gt;Node1</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","diagram":"digraph G {\n    label=\"com.ch.Camera3D\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        Vector3f\n        Matrix4f\n    }\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Camera3D [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    CameraStruct\n    Camera3D -> Matrix4f \n    Vector3f -> Camera3D \n    CameraStruct -> Camera3D \n}\n","items":[{"id":"d43a10c0-293d-67b3-524c-b150a655694f","ancestors":[],"type":"function","description":"is an extension of the Matrix4f class and provides methods for creating and modifying perspective projection matrices. It also includes methods for processing input events from the mouse and keyboard, adjusting the position and rotation of an object based on user input. Additionally, it has a move() method that moves the position of an entity by applying a translation to its current position in a 3D space.","name":"Camera3D","code":"public class Camera3D extends Camera {\n\n\tpublic Camera3D(float fov, float aspect, float zNear, float zFar) {\n\t\tsuper(new Matrix4f());\n\t\tthis.values = new CameraStruct3D(fov, aspect, zNear, zFar);\n\t\tcalculateProjectionMatrix(values);\n\t}\n\n\t/**\n\t * calculates a projection matrix based on the provided `CameraStruct` data and returns\n\t * it as a `Matrix4f` object.\n\t * \n\t * @param data 3D camera's projection matrix as a Matrix4f object, which is then\n\t * assigned to the function's return value.\n\t * \n\t * \t- `projection`: This is the projection matrix that is being calculated and returned\n\t * by the function. It is a 4x4 matrix.\n\t * \t- `getAsMatrix4()`: This is the method called on the `data` object to retrieve\n\t * the projection matrix as a 4x4 matrix.\n\t * \n\t * @returns a Matrix4f object representing the projection matrix.\n\t * \n\t * \t- The output is a `Matrix4f` object representing the perspective projection matrix.\n\t * \t- The matrix contains 16 elements that determine the shape and size of the projected\n\t * image, including the position, rotation, and scaling of the camera in the world\n\t * coordinate system.\n\t * \t- The matrix is constructed using the `getAsMatrix4()` method of the `CameraStruct`\n\t * class, which retrieves the projection matrix from the `data` parameter.\n\t */\n\t@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}\n\n\t/**\n\t * adjusts the camera's projection and view matrices to fit within a specified viewport\n\t * size, based on the aspect ratio of the viewport.\n\t * \n\t * @param width 2D viewport width of the display device, which is used to calculate\n\t * the appropriate projection and view matrices for rendering the 3D scene.\n\t * \n\t * @param height 2D viewport size of the renderer and is used to calculate the\n\t * appropriate projection matrix for rendering 3D objects within the viewport.\n\t */\n\t@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}\n\n\t/**\n\t * is a subclass of CameraStruct that represents a 3D camera. It has additional fields\n\t * for fov, aspect, zNear, and zFar, which are used to calculate the camera's projection\n\t * matrix. The class also provides a method to get the camera's perspective matrix\n\t * as a Matrix4f object.\n\t */\n\tprotected class CameraStruct3D extends CameraStruct {\n\n\t\tpublic float fov, aspect, zNear, zFar;\n\n\t\tpublic CameraStruct3D(float fov, float aspect, float zNear, float zFar) {\n\t\t\tthis.fov = fov;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.zNear = zNear;\n\t\t\tthis.zFar = zFar;\n\t\t}\n\n\t\t/**\n\t\t * returns a `Matrix4f` object representing a perspective projection matrix with field\n\t\t * of view (fov), aspect ratio, near and far distances.\n\t\t * \n\t\t * @returns a matrix representation of a perspective projection, initialized with the\n\t\t * specified field of view, aspect ratio, near and far z-values.\n\t\t * \n\t\t * \t- The `Matrix4f` object represents a 4x4 matrix that contains the perspective\n\t\t * projection transformation.\n\t\t * \t- The `fov`, `aspect`, `zNear`, and `zFar` parameters are used to initialize the\n\t\t * matrix with a perspective projection.\n\t\t * \t- The matrix is initialized using the `initPerspective` method of the `Matrix4f`\n\t\t * class, which sets the matrix's elements based on the provided values.\n\t\t */\n\t\tpublic Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}\n\n\t}\n\n\t/**\n\t * processes input events from the mouse and keyboard, adjusting the position and\n\t * rotation of an object based on user input. It also multiplies the speed of movement\n\t * by a factor determined by the L shift key.\n\t * \n\t * @param dt time step or elapsed time since the last iteration of the function, which\n\t * is used to compute and apply the movement speed modulation based on the pressed keys.\n\t * \n\t * @param speed 3D movement speed of the object being controlled, which is multiplied\n\t * by the time increment `dt` to determine the total distance moved.\n\t * \n\t * @param sens sensitivity of the object's rotation to mouse input, and it affects\n\t * the amount of rotation applied to the object when the user moves the mouse cursor.\n\t */\n\tpublic void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}\n\n\t/**\n\t * takes a direction vector `dir` and a scaling factor `amt`, and moves the position\n\t * of an entity by applying the given translation to its current position.\n\t * \n\t * @param dir 3D direction to move the object in the specified amount.\n\t * \n\t * \t- `dir` is a `Vector3f` object representing a 3D vector with x, y, and z components.\n\t * \t- The `mul()` method is used to multiply the `dir` vector by a scalar value `amt`,\n\t * which represents the amount of movement in the specified direction.\n\t * \n\t * The function then uses the `setPos()` method of the transform object to move the\n\t * position of the element represented by the `getTransform()` method by adding the\n\t * multiplied `dir` vector to the existing position.\n\t * \n\t * @param amt amount of movement along the specified direction, which is added to the\n\t * current position of the transform.\n\t */\n\tprivate void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}\n\n}","location":{"start":17,"insert":10,"offset":" ","indent":0,"comment":{"start":9,"end":16}},"item_type":"class","length":152,"docLength":7},{"id":"d7977aa3-075b-bf8b-904f-4a78622ad1ee","ancestors":["d43a10c0-293d-67b3-524c-b150a655694f"],"type":"function","description":"calculates and returns a Matrix4f object representing the projection matrix as defined by the input `CameraStruct` data.","params":[{"name":"data","type_name":"CameraStruct","description":"3D camera data required to calculate the perspective projection matrix.\n\n1. `getAsMatrix4()` - This method returns a `Matrix4f` object representing the projection matrix as defined by the `data` variable.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a Matrix4f object representing the projection matrix.\n\nThe `Matrix4f` object returned by the function represents the projection matrix for the given camera data. Specifically, it encodes the intrinsic and extrinsic parameters of the camera in a 4x4 homogeneous transformation matrix. The matrix elements represent the distortion coefficients, aspect ratio, and other camera-specific properties that are used to project 3D points from the world coordinates into image coordinates.","complex_type":true},"usage":{"language":"java","code":"@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}\n","description":"\nThis code uses a `CameraStruct` object called `data`, and gets the perspective projection matrix from it using its `getAsMatrix4()` method. The resulting matrix is then assigned to the variable `projection`. This code assumes that the `calculateProjectionMatrix` method is being overridden within a class that extends the `Camera` class, and that the `projection` variable already exists."},"name":"calculateProjectionMatrix","code":"@Override\n\tpublic Matrix4f calculateProjectionMatrix(CameraStruct data) {\n\t\treturn (projection = data.getAsMatrix4());\n\t}","location":{"start":46,"insert":25,"offset":"\t","indent":1,"comment":{"start":24,"end":45}},"item_type":"method","length":4,"docLength":21},{"id":"564df75c-c7b6-2980-8043-e174d8cc1ebd","ancestors":["d43a10c0-293d-67b3-524c-b150a655694f"],"type":"function","description":"adjusts the camera's projection and view matrices to fit within the given viewport dimensions, and sets the viewport size to the specified width and height.","params":[{"name":"width","type_name":"int","description":"2D viewport width for which the `adjustToViewport()` method is called.","complex_type":false},{"name":"height","type_name":"int","description":"2D viewport size in pixels and is used to calculate the aspect ratio of the 3D scene and to set the viewport dimensions in the GL11 glViewport method.","complex_type":false}],"usage":{"language":"java","code":"@Override\npublic void adjustToViewport(int width, int height) {\n    ((CameraStruct3D) this.values).aspect = (float) width / height;\n    calculateProjectionMatrix(values);\n    try {\n        calculateViewMatrix();\n    } catch (NullPointerException e) {\n    }\n    GL11.glViewport(0, 0, width, height);\n}\n","description":"\nThis method is a part of an implementation of a Camera3D object, which provides the necessary methods to implement a camera in the game engine. The adjustToViewport() method takes an integer width and height as input, which are used to compute the aspect ratio and call the calculateProjectionMatrix() and calculateViewMatrix() methods. Finally, the GL11.glViewport() method is called to set the viewport for rendering.\nThe calculateProjectionMatrix() and calculateViewMatrix() methods are also part of the Camera3D object implementation, and they provide the necessary functionality to compute the projection matrix and view matrix of the camera. The calculateProjectionMatrix() method takes an input of type `CameraStruct3D`, which contains the fov, aspect, zNear, and zFar values that are used to create a perspective projection matrix for the camera. The calculateViewMatrix() method computes the view matrix for the camera based on its position, rotation, and orientation.\nThe example code uses an instance of Camera3D object as `this` and casts its internal values member to type `CameraStruct3D`. Then, it sets the aspect ratio by dividing the width and height inputs. After that, it calls the calculateProjectionMatrix() method on the input `values`, which computes a perspective projection matrix based on the camera's field of view (fov), aspect ratio, zNear, and zFar values. Finally, it tries to call the calculateViewMatrix() method on the `values` parameter, but in case it throws a NullPointerException, it catches that exception and does nothing.\nThe adjustToViewport() method is then called with an integer width and height as input, which are used to set the viewport for rendering. The GL11.glViewport() method is then called with 0, 0, width, and height parameters to set the OpenGL viewport."},"name":"adjustToViewport","code":"@Override\n\tpublic void adjustToViewport(int width, int height) {\n\t\t((CameraStruct3D) this.values).aspect = (float) width / height;\n\t\tcalculateProjectionMatrix(values);\n\t\ttry {\n\t\t\tcalculateViewMatrix();\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tGL11.glViewport(0, 0, width, height);\n\t}","location":{"start":61,"insert":51,"offset":"\t","indent":1,"comment":{"start":50,"end":60}},"item_type":"method","length":10,"docLength":10},{"id":"ab6f0bdf-077e-68af-644a-9f9602be538d","ancestors":["d43a10c0-293d-67b3-524c-b150a655694f"],"type":"function","description":"is a custom class that extends the CameraStruct class and provides additional functionality for representing a camera in a 3D environment. It takes in the field of view (fov), aspect ratio, near distance (zNear), and far distance (zFar) as parameters in its constructor, and uses these values to initialize a matrix representation of a perspective projection. This matrix can then be used to transform 3D points and positions using the `getAsMatrix4()` method. Additionally, the class provides methods for processing input events from the mouse and keyboard, which can be used to adjust the position and rotation of an object based on user input.","name":"CameraStruct3D","code":"protected class CameraStruct3D extends CameraStruct {\n\n\t\tpublic float fov, aspect, zNear, zFar;\n\n\t\tpublic CameraStruct3D(float fov, float aspect, float zNear, float zFar) {\n\t\t\tthis.fov = fov;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.zNear = zNear;\n\t\t\tthis.zFar = zFar;\n\t\t}\n\n\t\t/**\n\t\t * returns a `Matrix4f` object representing a perspective projection matrix with field\n\t\t * of view (fov), aspect ratio, near and far distances.\n\t\t * \n\t\t * @returns a matrix representation of a perspective projection, initialized with the\n\t\t * specified field of view, aspect ratio, near and far z-values.\n\t\t * \n\t\t * \t- The `Matrix4f` object represents a 4x4 matrix that contains the perspective\n\t\t * projection transformation.\n\t\t * \t- The `fov`, `aspect`, `zNear`, and `zFar` parameters are used to initialize the\n\t\t * matrix with a perspective projection.\n\t\t * \t- The matrix is initialized using the `initPerspective` method of the `Matrix4f`\n\t\t * class, which sets the matrix's elements based on the provided values.\n\t\t */\n\t\tpublic Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}\n\n\t}","location":{"start":78,"insert":72,"offset":"\t","indent":1,"comment":{"start":71,"end":77}},"item_type":"class","length":30,"docLength":6},{"id":"26464e65-7d58-8bb9-af43-9e9c53558dbc","ancestors":["d43a10c0-293d-67b3-524c-b150a655694f","ab6f0bdf-077e-68af-644a-9f9602be538d"],"type":"function","description":"Initializes a matrix that represents a perspective projection, with the specified field of view (fov), aspect ratio, near and far distances.","params":[],"returns":{"type_name":"Matrix4f","description":"a matrix representing a perspective projection, with values computed based on the provided fov, aspect, zNear, and zFar parameters.\n\n* The return value is a `Matrix4f` object representing a 4x4 matrix, which contains the perspective projection parameters in its elements.\n* The matrix's entries are determined by the input parameters `fov`, `aspect`, `zNear`, and `zFar`. Specifically, the elements of the matrix are:\n\t+ `m00` = 2 / (tan(fov/2) * zNear)\n\t+ `m11` = 1 / (tan(fov/2) * zNear)\n\t+ `m20` = 0\n\t+ `m21` = 0\n\t+ `m30` = 0\n\t+ `m31` = -2 / (zFar - zNear)\n* The matrix is used to transform 3D points from the object space to the image space, applying the perspective projection.","complex_type":true},"usage":{"language":"java","code":"public class PerspectiveCamera extends CameraStruct3D {\n    public static void main(String[] args) {\n        // create a perspective camera with 90 degrees field of view, 16:9 aspect ratio, 0.1 unit near plane distance, and 500 units far plane distance\n        PerspectiveCamera cam = new PerspectiveCamera(Math.toRadians(90), 16f/9f, 0.1f, 500f);\n        \n        // use the camera's perspective matrix to transform a point in world space into screen space\n        Matrix4f perspMat = cam.getAsMatrix4();\n        Vector3f pointInWorldSpace = new Vector3f(10f, 10f, 10f);\n        System.out.println(\"pointInWorldSpace: \" + pointInWorldSpace);\n        Vector4f transformedPoint = perspMat.transform(new Vector4f(pointInWorldSpace));\n        System.out.println(\"transformedPoint: \" + transformedPoint);\n    }\n}\n","description":"\nThis will produce the following output:\n"},"name":"getAsMatrix4","code":"public Matrix4f getAsMatrix4() {\n\t\t\treturn new Matrix4f().initPerspective(fov, aspect, zNear, zFar);\n\t\t}","location":{"start":103,"insert":89,"offset":"\t","indent":2,"comment":{"start":88,"end":102}},"item_type":"method","length":3,"docLength":14},{"id":"27b5132b-3c5b-58b3-c34b-4b1ca9fd6ae4","ancestors":["d43a10c0-293d-67b3-524c-b150a655694f"],"type":"function","description":"rotates and moves a transform based on mouse input, keyboard input, and time. It also scales the speed based on the LShift key.","params":[{"name":"dt","type_name":"float","description":"time step of the simulation, which determines the amount of movement performed by the entity.","complex_type":false},{"name":"speed","type_name":"float","description":"3D movement speed of the object being controlled by the code, and its value is multiplied by the time interval `dt` to determine the total distance moved during each frame.","complex_type":false},{"name":"sens","type_name":"float","description":"sensitivity of the object's rotation to the mouse input, and it affects how quickly the object rotates in response to mouse movements.","complex_type":false}],"usage":{"language":"java","code":"// ... \npublic static void main(String[] args) {\n    // ...\n    Camera camera = new Camera();\n    camera.processInput(1, 5, 2);\n}\n","description":"\nThis code would call the method `processInput` on an instance of `Camera`. The parameters to this method are `dt`, which is a time step or elapsed time since the last iteration of the function, and `speed`, which is 3D movement speed of the object being controlled. The `sensitivity` parameter is used to adjust the amount of rotation applied by the mouse input.\n\nThe values passed to processInput in this example are:\n"},"name":"processInput","code":"public void processInput(float dt, float speed, float sens) {\n\n\t\tfloat dx = Mouse.getDX();\n\t\tfloat dy = Mouse.getDY();\n\t\tfloat roty = (float)Math.toRadians(dx * sens);\n\t\tgetTransform().rotate(new Vector3f(0, 1, 0), (float) roty);\n\t\tgetTransform().rotate(getTransform().getRot().getRight(), (float) -Math.toRadians(dy * sens));\n\t\t\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))\n\t\t\tspeed *= 10;\n\t\t\n\t\tfloat movAmt = speed * dt;\n\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_W))\n\t\t\tmove(getTransform().getRot().getForward(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_S))\n\t\t\tmove(getTransform().getRot().getForward(), -movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_A))\n\t\t\tmove(getTransform().getRot().getLeft(), movAmt);\n\t\tif (Keyboard.isKeyDown(Keyboard.KEY_D))\n\t\t\tmove(getTransform().getRot().getRight(), movAmt);\n\t\t\n\t}","location":{"start":123,"insert":109,"offset":"\t","indent":1,"comment":{"start":108,"end":122}},"item_type":"method","length":23,"docLength":14},{"id":"b8dbe004-e884-46aa-5344-bb5849f9096e","ancestors":["d43a10c0-293d-67b3-524c-b150a655694f"],"type":"function","description":"moves an object's position by a specified distance along a given direction, applying the transformation to the object's position.","params":[{"name":"dir","type_name":"Vector3f","description":"3D direction in which the object should be moved, with the movement amount determined by the `amt` parameter.\n\n* `dir` is a `Vector3f` instance representing a 3D direction vector.\n* `amt` is an instance of a floating-point number indicating the distance to move along the specified direction.","complex_type":true},{"name":"amt","type_name":"float","description":"amount of movement along the specified direction, which is added to the current position of the transform.","complex_type":false}],"usage":{"language":"java","code":"Vector3f direction = new Vector3f(1, 0, 0);\nfloat amount = 5;\nmove(direction, amount);\n","description":"\nIn this example, the method is called with a vector and a scalar representing a movement of 5 units in the x-axis. The method will then use this information to move the object by adding the direction vector multiplied by the scalar amount to its current position."},"name":"move","code":"private void move(Vector3f dir, float amt) {\n\t\tgetTransform().setPos(getTransform().getPos().add(dir.mul(amt)));\n\t}","location":{"start":164,"insert":147,"offset":"\t","indent":1,"comment":{"start":146,"end":163}},"item_type":"method","length":3,"docLength":17}]}}}