{"name":"World.java","path":"src/com/ch/voxel/World.java","content":{"structured":{"description":"A 3D rendering engine for generating and updating chunks of a 3D world. The engine uses a separate thread for chunk generation, which is executed when the main thread is idle. The chunk generation algorithm checks if the current position in the world is within a chunk boundary, and if so, generates a new chunk if none exists or updates an existing one. The render method takes a shader and camera object as input and renders the chunks using the shader's uniforms to color them based on their positions in the world.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera Pages: 1 -->\n<svg width=\"115pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 115.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"100,-74 7,-74 7,-55 100,-55 100,-74\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera3D.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"107,-19 0,-19 0,0 107,0 107,-19\"/>\n<text text-anchor=\"middle\" x=\"53.5\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D</text>\n</a>\n</g>\n</g>\n<!-- Node1&#45;&gt;Node2 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node1&#45;&gt;Node2</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M53.5,-44.66C53.5,-35.93 53.5,-25.99 53.5,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"50,-44.75 53.5,-54.75 57,-44.75 50,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","diagram":"digraph G {\n    label=\"com.ch.voxel.World\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            World [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n    }\n    Camera\n    Shader\n    Shader -> World \n    Camera -> World \n}\n","items":[{"id":"05a4a8b5-9aba-caa9-e145-47b16eb26470","ancestors":[],"type":"function","description":"in the provided code is a 3D rendering engine that manages a grid of chunks, each representing a small part of the game world. The World class has several methods for updating and rendering the chunks, including `gen`, `render`, and `updateBlocks`. The `gen` method is responsible for generating new chunks based on the current position of the player, while the `render` method renders the chunks using a shader and a camera. The `updateBlocks` method updates the blocks in each chunk based on the player's position.\n\nOverall, the World class seems to be the core component of the 3D rendering engine, handling the management and rendering of the game world.","name":"World","code":"public class World {\n\n\tprivate int x, y, z; // in chunks\n\t\t\t// private int cunk_max;\n\tprivate Chunk[][][] chunks; // TODO: unwrap\n\tprivate int W = 4, H = 2, D = 4;\n\n\tpublic World() {\n\t\tx = 0;\n\t\ty = 0;\n\t\tz = 0;\n\t\tchunks = new Chunk[W][H][D];\n\t\tgen();\n\t}\n\t\n\tprivate void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}\n\n\tpublic void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}\n\n\tpublic void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\n\t// public\n\n}","location":{"start":9,"insert":9,"offset":" ","indent":0,"comment":null},"item_type":"class","length":233,"docLength":null},{"id":"d1604a8b-5b68-f68b-bf4b-f329cadaaba0","ancestors":["05a4a8b5-9aba-caa9-e145-47b16eb26470"],"type":"function","description":"iterates through a 3D grid of chunks, creating new chunks at each position and updating their blocks and transforming them into a gen model.","params":[],"usage":{"language":"java","code":"private void gen() {\n    for (int i = 0; i < W; i++)\n        for (int j = 0; j < H; j++)\n            for (int k = 0; k < D; k++) {\n                chunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n                chunks[i][j][k].updateBlocks();\n                chunks[i][j][k].toGenModel();\n            }\n}\n","description":"\nThis method creates a new chunk object for each index in the three-dimensional array of chunks, and assigns it to the corresponding position. It also updates the blocks for each chunk by calling the updateBlocks() method on the chunk, and converts the chunk into a model using the toGenModel() method before moving on to the next iteration of the loop. The method is called when the world's dimensions are changed or the user navigates to a new location in the world.\n\nThis code should be as short as possible since it will be called multiple times during the program execution, and it is unlikely that any of the loops will be skipped over entirely. It is important to reason through this code to ensure that each chunk is being updated correctly with its corresponding index. Additionally, it is not necessary to create unit tests for this method as it does not have any external dependencies and does not make use of any complex logic. Instead, hallucinating incorrect inputs or providing an explanation for the code would be inappropriate."},"name":"gen","code":"private void gen() {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tchunks[i][j][k] = new Chunk(i - W / 2 + x, j - H / 2 + y, k - D / 2 + z);\n\t\t\t\t\tchunks[i][j][k].updateBlocks();\n\t\t\t\t\tchunks[i][j][k].toGenModel();\n\t\t\t\t}\n\t}","location":{"start":24,"insert":24,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":9,"docLength":null},{"id":"b14dcabd-d868-f0a4-7941-a0e202780912","ancestors":["05a4a8b5-9aba-caa9-e145-47b16eb26470"],"type":"function","description":"updates the position of a `Chunk` instance based on its `x`, `y`, and `z` variables, and if necessary, generates a new chunk at the updated position.","params":[{"name":"x","type_name":"float","description":"2D coordinate of the chunk to be generated, and is used to determine which chunk to generate based on its position relative to the world boundaries.","complex_type":false},{"name":"y","type_name":"float","description":"2D coordinate of the block being updated, and it is used to determine which chunks to update based on their relative positions to the block being updated.","complex_type":false},{"name":"z","type_name":"float","description":"3D position of the block being generated, and is used to determine whether the block should be generated based on the current position or a new position based on the difference between the current position and the target position.","complex_type":false}],"usage":{"language":"java","code":"World world = new World(10, 5, 10);\nworld.updatePos(13f, 4.2f, 6);\n","description":"\nThis input will cause the world to move the center of the world from (0, 0, 0) to (13, 4.2, 6). The world's chunks would be updated accordingly, ensuring that the blocks in those chunks are now within the range of the new center point."},"name":"updatePos","code":"public void updatePos(float x, float y, float z) {\n\t\tfinal int _x = (int) (x / Chunk.CHUNK_SIZE);\n\t\tfinal int _y = 0;//(int) (y / Chunk.CHUNK_SIZE);\n\t\tfinal int _z = (int) (z / Chunk.CHUNK_SIZE);\n\n\t\tif (this.x == _x && this.y == _y && this.z == _z) { // short circuit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check for any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n\t\t\t//System.out.println(\"hello\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint wx = this.x;\n\t\tint wy = this.y;\n\t\tint wz = this.z;\n\t\t\n//\t\tclass internal_chunk_thread extends Thread {\n//\t\t\t\n//\t\tprivate int  wx, wy, wz;\n//\t\t\n//\t\tvoid set(int x, int y, int z) {\n//\t\t\tthis.wx = x;\n//\t\t\tthis.wy = y;\n//\t\t\tthis.wz = z;\n//\t\t}\n//\t\t\t\n//\t\tpublic void run() {\n\n\t\t/*\n\t\t * all logic is unwrapped because its more efficient.. while its a pain\n\t\t * to code and read.. tradeoff taken :D\n\t\t */\n\n\t\t/* dont think these cases occure\n\t\tif (this.x != _x && this.y != _y && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.y != _y) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.y < _y) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.x != _x && this.z != _z) {\n\t\t\tif (this.x < _x) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.y != _y && this.z != _z) {\n\t\t\tif (this.y < _y) {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.z < _z) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} else \n\t\t*/\n\t\tif (wx != _x) {\n\t\t\tif (wx < _x) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wy != _y) {\n\t\t\tif (wy < _y) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (wz != _z) {\n\t\t\tif (wz < _z) {\n\t\t\t\tint dif = _z - wz;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 0; k < D - 1; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, (D - 1) - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][D - 1].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint dif = wz - _z;\n\t\t\t\tif (dif > D) {\n\t\t\t\t\twx = _x;\n\t\t\t\t\twy = _y;\n\t\t\t\t\twz = _z;\n\t\t\t\t\tgen();\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tChunk[][][] n_chunks = new Chunk[W][H][D];\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\t\t\t\tfor (int k = 1; k < D; k++) {\n\t\t\t\t\t\t\t\tn_chunks[i][j][k] = chunks[i][j][k - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 0; i < W; i++)\n\t\t\t\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\t\t\t\tn_chunks[i][j][0] = new Chunk(i - W / 2 + _x, j - H / 2 + _y, 0 - D / 2 + _z);\n\t\t\t\t\t\t\tn_chunks[i][j][0].updateBlocks();\n\t\t\t\t\t\t\tn_chunks[i][j][0].toGenModel();\n\t\t\t\t\t\t}\n\t\t\t\t\tWorld.this.chunks = n_chunks;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\t\n//\t\t}\n//\t\t\n//\t\t};\n//\t\tinternal_chunk_thread t = new internal_chunk_thread();\n//\t\tt.set(this.x, this.y, this.z);\n//\t\tt.start();\n\t\t\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.z = _z;\n\t\t\n\t\t/* welp... this logic sure looks aweful */\n\t}","location":{"start":34,"insert":34,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":183,"docLength":null},{"id":"9a2f1e4e-71d9-a1a9-ce4f-0eeacbedfebe","ancestors":["05a4a8b5-9aba-caa9-e145-47b16eb26470"],"type":"function","description":"renders a scene using a shader and a camera. It iterates over each chunk in a 3D grid, rendering each chunk using the shader and passing the camera's view projection matrix as an uniform variable.","params":[{"name":"s","type_name":"Shader","description":"3D shader instance that renders the scene, and it is used to set the uniform values for the shader using its `unifrom*` methods.\n\n* `Shader s`: Represents a shader object that defines the fragment shader's code.\n* `Camera c`: Represents a camera object that provides the viewpoint for rendering the 3D scene.\n* `W`, `H`, and `D`: Indicate the dimensions of the image to be rendered, respectively.\n* `chunks[][][]`: A two-dimensional array representing a 3D scene with chunks of varying sizes. Each chunk has three properties: `x`, `y`, and `z`, which represent its position in the 3D space.\n* `Chunk ch`: Represents an individual chunk in the 3D scene, with properties `x`, `y`, and `z`.\n* `Color cl`: Represents a color object created from the hash code of the chunk's position in the 3D space. The color is used to set the fragment shader's uniform values.\n* `r`, `g`, and `b`: Represents the red, green, and blue components of the color, respectively. These values are set using the `unifrom` method.\n* `MVP`: Represents a matrix object that represents the viewprojection transformation of the camera. This transformation is used to transform the chunk's position in 3D space into screen coordinates.\n* `modelMatrix`: Represents a matrix object that represents the modelview transformation of the chunk's position in 3D space. This transformation is used to transform the chunk's position in 3D space into the world coordinate system.","complex_type":true},{"name":"c","type_name":"Camera","description":"3D camera object, which is used to transform the model's vertices according to the camera's viewprojection matrix.\n\n* `c`: A `Camera` object representing the camera used for rendering. Its properties include the viewport dimensions (`W`, `H`), field of view (`fov`), and projection matrix (`getViewProjection`).\n\nThe code inside the function iterates over the chunks in a 3D grid, applying the following operations to each chunk:\n\n1. Creating a color object based on the chunk's position (`ch.x`, `ch.y`, `ch.z`) using hash code method.\n2. Calculating and storing the red, green, and blue values of the color object in the `r`, `g`, and `b` variables respectively.\n3. Setting the uniform values for the shader program using the `uniformf` method with the name `\"color\"` and passing the calculated values as arguments.\n4. Setting the uniform value for the modelview matrix (`MVP`) using the `unifromMat4` method with the name `\"MVP\"` and passing the product of the viewprojection matrix and the model matrix as an argument.\n5. Drawing the 3D model associated with the chunk using the `getModel().draw()` method.","complex_type":true}],"usage":{"language":"java","code":"public class Game {\n    private Shader s;\n    private Camera c;\n\n    public void run() {\n        // create shader, camera, and world\n        this.s = new Shader();\n        this.c = new Camera();\n        World w = new World();\n\n        while (true) {\n            // render the scene\n            s.use();\n            c.setView(new Vec3f());\n            c.setProjection(Matrix4f.IDENTITY);\n            w.render(s, c);\n        }\n    }\n}\n","description":"\nThis code creates a Shader, Camera, and World object, and then repeatedly renders the scene using the render() method. The parameters of the render() method are the shader used for drawing (the first parameter) and the camera that is being used to view the scene (the second parameter). This code assumes that the render() method has already been implemented to perform the actual rendering, and it will not work as-is."},"name":"render","code":"public void render(Shader s, Camera c) {\n\t\tfor (int i = 0; i < W; i++)\n\t\t\tfor (int j = 0; j < H; j++)\n\t\t\t\tfor (int k = 0; k < D; k++) {\n\t\t\t\t\tChunk ch = chunks[i][j][k];\n\t\t\t\t\tif (ch != null) { // just in case for now although i dont suspect it will ever be\n\t//\t\t\t\t\tfloat r = (W - i) / (float) W;\n\t//\t\t\t\t\tfloat g = j / (float) H;\n\t//\t\t\t\t\tfloat b = k / (float) D;\n\t\t\t\t\t\tColor cl = new Color((\"\" + ch.x + ch.y + ch.z + (ch.x * ch.z) + (ch.y * ch.y)).hashCode());\n\t\t\t\t\t\t\n\t\t\t\t\t\tfloat r = cl.getRed() / 255f;\n\t\t\t\t\t\tfloat g = cl.getGreen() / 255f;\n\t\t\t\t\t\tfloat b = cl.getBlue() / 255f;\n\t\t\t\t\t\ts.uniformf(\"color\", r, g, b);\n\t\t\t\t\t\ts.unifromMat4(\"MVP\", (c.getViewProjection().mul(ch.getModelMatrix())));\n\t\t\t\t\t\tch.getModel().draw();\n\t\t\t\t\t}\n\t\t\t\t}\n\t}","location":{"start":218,"insert":218,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null}]}}}