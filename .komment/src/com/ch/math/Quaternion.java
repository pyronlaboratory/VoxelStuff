{"name":"Quaternion.java","path":"src/com/ch/math/Quaternion.java","content":{"structured":{"description":"A `Quaternion` class that represents 4D quaternions in a graphical user interface (GUI) application. The class has several methods for manipulating the x, y, z, and w components of a quaternion, as well as methods for comparing quaternions and retrieving their component values. The code also defines a `set` method that allows a quaternion to be set to the values of another quaternion, and an `equals` method that compares two quaternions for equality based on their component values.","diagram":"digraph G {\n    label=\"com.ch.math.Quaternion\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        Matrix4f\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Quaternion [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Vector3f\n    }\n    Transform\n    Quaternion -> Vector3f \n    Quaternion -> Quaternion \n    Quaternion -> Quaternion [style=\"dashed\"]\n    Quaternion -> Transform \n    Quaternion -> Matrix4f \n    Quaternion -> Vector3f [style=\"dashed\"]\n    Vector3f -> Quaternion [style=\"dashed\"]\n    Transform -> Quaternion \n    Vector3f -> Quaternion \n}\n","items":[{"id":"19e8e215-53aa-4a8f-084d-0452ec3fe116","ancestors":[],"type":"function","description":"is a Java class that represents a quaternion as a mathematical object. It has several methods for calculating and manipulating quaternions, including setting the values of its components, retrieving the values of its components, and comparing two quaternions for equality. The class also provides a few instance variables for storing the values of its components.","name":"Quaternion","code":"public class Quaternion {\n\n\tprivate float x;\n\tprivate float y;\n\tprivate float z;\n\tprivate float w;\n\n\tpublic Quaternion() {\n\t\tthis(0, 0, 0, 0);\n\t}\n\n\t\n\tpublic Quaternion(float w, float x, float y, float z) {\n\t\tthis.w = w;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\tpublic Quaternion(Vector3f axis, float angle) {\n\t\tfloat sinHalfAngle = (float) Math.sin(angle / 2);\n\t\tfloat cosHalfAngle = (float) Math.cos(angle / 2);\n\n\t\tthis.x = axis.getX() * sinHalfAngle;\n\t\tthis.y = axis.getY() * sinHalfAngle;\n\t\tthis.z = axis.getZ() * sinHalfAngle;\n\t\tthis.w = cosHalfAngle;\n\t}\n\n\t/**\n\t * calculates the magnitude of a 3D vector by taking the square root of the sum of\n\t * its x, y, and z components.\n\t * \n\t * @returns the square root of the sum of the squares of the coordinates of a 3D point.\n\t */\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}\n\n\t/**\n\t * normalizes a given quaternion by dividing each component by its length, resulting\n\t * in a new quaternion with a length of 1.\n\t * \n\t * @returns a normalized quaternion representation of the original input quaternion.\n\t * \n\t * The function returns a new Quaternion instance with the given input's length\n\t * normalized. The length is calculated using the `length()` method and is used to\n\t * scale the quaternion components. As a result, the quaternion is now in a unit form,\n\t * making it more useful for various mathematical operations.\n\t */\n\tpublic Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}\n\n\t/**\n\t * generates a new quaternion object by providing the original quaternion's scalar\n\t * component and the negative of each vector component.\n\t * \n\t * @returns a new quaternion object with the conjugate of the input quaternion's coordinates.\n\t * \n\t * \t- The output is a Quaternion object, representing the conjugate of the input Quaternion.\n\t * \t- The conjugate of a Quaternion is defined as the vector that is obtained by\n\t * multiplying the original Quaternion by its own conjugate.\n\t * \t- The conjugate of a Quaternion has the same magnitude as the original Quaternion,\n\t * but its direction is reversed. In other words, if the original Quaternion points\n\t * in the direction of a certain axis, then the conjugate Quaternion points in the\n\t * opposite direction of that axis.\n\t */\n\tpublic Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}\n\n\t/**\n\t * multiplies a quaternion by a scalar value and returns a new quaternion with the product.\n\t * \n\t * @param r scalar value that is multiplied with the quaternion's components to produce\n\t * the resulting quaternion.\n\t * \n\t * @returns a quaternion object representing the product of the original quaternion\n\t * and the scalar value `r`.\n\t */\n\tpublic Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}\n\n\t/**\n\t * multiplies a quaternion by another quaternion, calculating the product of the two\n\t * rotations and storing it in a new quaternion object.\n\t * \n\t * @param r quaternion to be multiplied with the current quaternion, and its values\n\t * are used to calculate the output quaternion's components.\n\t * \n\t * \t- `w`: The real part of the quaternion representation.\n\t * \t- `x`, `y`, `z`: The imaginary parts of the quaternion representation.\n\t * \n\t * @returns a new quaternion instance representing the product of the input quaternions.\n\t * \n\t * \t- `w_`: The magnitude (or length) of the resultant quaternion, which is equal to\n\t * the product of the magnitudes of the input quaternions.\n\t * \t- `x_`, `y_`, and `z_`: The three components of the resultant quaternion, which\n\t * are obtained by multiplying the corresponding components of the input quaternions.\n\t * These components represent the rotational part of the resultant quaternion.\n\t */\n\tpublic Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\t/**\n\t * multiplies a quaternion by a vector, computing the resulting quaternion's coordinates\n\t * in a straightforward manner.\n\t * \n\t * @param r 3D vector that is multiplied with the quaternion.\n\t * \n\t * \t- `r` is a `Vector3f` instance representing a 3D vector with real values for `x`,\n\t * `y`, and `z`.\n\t * \n\t * @returns a quaternion representing the result of multiplying the input vector `r`\n\t * by the quaternion represented by the function parameters.\n\t * \n\t * The `Quaternion` object returned has four components: w_, x_, y_, and z_. These\n\t * components represent the product of the input quaternion and the vector passed as\n\t * an argument.\n\t * \n\t * The value of w_ is equal to the dot product of the input quaternion's w component\n\t * and the argument vector's x, y, and z components, minus the product of the input\n\t * quaternion's x, y, and z components and the argument vector's x, y, and z components.\n\t * \n\t * The value of x_ is equal to the dot product of the input quaternion's x component\n\t * and the argument vector's x, y, and z components, plus the product of the input\n\t * quaternion's w component and the argument vector's y component, minus the product\n\t * of the input quaternion's y component and the argument vector's x component.\n\t * \n\t * The value of y_ is equal to the dot product of the input quaternion's y component\n\t * and the argument vector's x, y, and z components, plus the product of the input\n\t * quaternion's w component and the argument vector's z component, minus the product\n\t * of the input quaternion's z component and the argument vector's y component.\n\t * \n\t * The value of z_ is equal to the dot product of the input quaternion's z component\n\t * and the argument vector's x, y, and z components, plus the product of the input\n\t * quaternion's w component and the argument vector's x component, minus the product\n\t * of the input quaternion's x component and the argument vector's y component.\n\t */\n\tpublic Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\t/**\n\t * takes a `Quaternion` object `r` as input and returns a new `Quaternion` object\n\t * representing the difference between the two quaternions.\n\t * \n\t * @param r quaternion to be subtracted from the current quaternion, resulting in a\n\t * new quaternion that represents the difference between the two.\n\t * \n\t * \t- `w`: The real part of the quaternion.\n\t * \t- `x`, `y`, and `z`: The imaginary parts of the quaternion, representing the angle\n\t * and direction of rotation around the x, y, and z axes, respectively.\n\t * \n\t * @returns a new quaternion representing the difference between the input quaternion\n\t * and the reference quaternion.\n\t * \n\t * \t- The `Quaternion` object represents the difference between two quaternions, which\n\t * means that it holds the residual value after subtracting the right-hand side\n\t * quaternion from the left-hand side quaternion.\n\t * \t- The values of the four components (w, x, y, and z) represent the residual values\n\t * in each dimension.\n\t * \t- The order of the quaternions is preserved in the returned object, meaning that\n\t * the resulting quaternion has the same orientation as the original quaternion.\n\t */\n\tpublic Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}\n\n\t/**\n\t * takes a `Quaternion` object `r` as input and returns a new `Quaternion` object\n\t * representing the sum of the two quaternions. The returned quaternion has the same\n\t * components (w, x, y, and z) as the original quaternion plus the corresponding\n\t * components of the input quaternion.\n\t * \n\t * @param r quaternion to be added to the current quaternion.\n\t * \n\t * The `Quaternion` class represents a quaternion in 3D space, which is a mathematical\n\t * object that can be used to rotate points or vectors in 3D space. The instance\n\t * variable `w` represents the real part of the quaternion, while `x`, `y`, and `z`\n\t * represent the imaginary parts.\n\t * \n\t * @returns a new quaternion with the sum of the inputs' coefficients.\n\t * \n\t * \t- The output is a `Quaternion` instance representing the sum of the input arguments.\n\t * \t- The `W`, `X`, `Y`, and `Z` components of the output are calculated by adding\n\t * the corresponding components of the input arguments.\n\t * \t- The output has the same orientation as the input, but with the sum of their values.\n\t */\n\tpublic Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}\n\n\t/**\n\t * takes a quaternion representation of a rotation and returns a corresponding 4x4\n\t * homogeneous matrix.\n\t * \n\t * @returns a 4x4 rotation matrix.\n\t * \n\t * \t- The return type is `Matrix4f`, which represents a 4x4 homogeneous transformation\n\t * matrix.\n\t * \t- The method `initRotation` is called to create a rotation matrix from the forward,\n\t * up, and right vectors.\n\t * \t- The forward vector has a magnitude of 2.0f and directional components that are\n\t * twice the corresponding elements of the input matrix.\n\t * \t- The up vector has a magnitude of 1.0f and directional components that are equal\n\t * to the corresponding elements of the input matrix minus twice the corresponding\n\t * elements of the forward vector.\n\t * \t- The right vector has a magnitude of 1.0f and directional components that are\n\t * equal to the corresponding elements of the input matrix minus the corresponding\n\t * elements of the up vector.\n\t * \n\t * Overall, the `toRotationMatrix` function returns a rotation matrix that can be\n\t * used to perform rotations in 3D space based on the input vectors.\n\t */\n\tpublic Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}\n\n\t/**\n\t * computes the dot product of two quaternions, returning a scalar value.\n\t * \n\t * @param r 4D quaternion value to which the `x`, `y`, `z`, and `w` components of the\n\t * current quaternion are dot-producted, resulting in a scalar value.\n\t * \n\t * \t- `x`, `y`, `z`, and `w` are the components of the Quaternion structure.\n\t * \t- `getX()`, `getY()`, `getZ()`, and `getW()` are methods that return the corresponding\n\t * component values of `r`.\n\t * \n\t * @returns a floating-point number representing the dot product of the input quaternion\n\t * and another quaternion argument.\n\t */\n\tpublic float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}\n\n\t/**\n\t * computes a linear interpolation between two quaternions based on the given factor,\n\t * and returns the result normalized to have length equal to the maximum value of the\n\t * input quaternions.\n\t * \n\t * @param dest 4-dimensional vector that the function will be lerped to, with its\n\t * components being updated based on the provided `lerpFactor` and `shortest` parameters.\n\t * \n\t * \t- `dest`: A Quaternion object representing the destination point in 3D space. It\n\t * has four components: `w`, `x`, `y`, and `z`.\n\t * \t- `lerpFactor`: A floating-point value representing the interpolation factor\n\t * between the current position and the destination position.\n\t * \t- `shortest`: An optional boolean value indicating whether to shorten the\n\t * interpolated quaternion to avoid overshooting. If set to `true`, the function will\n\t * adjust the destination quaternion if it would result in a negative dot product\n\t * with the original quaternion.\n\t * \n\t * @param lerpFactor 0-1 interpolating factor used to blend between the starting and\n\t * ending quaternions.\n\t * \n\t * @param shortest direction of rotation to be performed, and when set to `true`, it\n\t * forces the function to return the shortest quaternion possible to achieve the\n\t * desired rotation, even if it results in a non-normalized quaternion.\n\t * \n\t * @returns a quaternion that represents the intermediate result of interpolating\n\t * between two given quaternions using the linear interpolation formula.\n\t * \n\t * \t- The output is a Quaternion object, representing a linear interpolation between\n\t * the input `dest` and the inverse of the input multiplied by the given `lerpFactor`.\n\t * \t- If the input `shortest` is set to true, then the output will be corrected to\n\t * ensure that the resulting quaternion has a dot product with the input `dest` closer\n\t * to zero. This is done by multiplying the input by its conjugate and subtracting\n\t * it from the input.\n\t * \t- The returned Quaternion object has four components representing the x, y, z,\n\t * and w axes of the quaternion rotation.\n\t */\n\tpublic Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}\n\n\t/**\n\t * computes a quaternion interpolation between two given quaternions, weighted by a\n\t * factor and shortest path if necessary. It first computes the dot product of the\n\t * two quaternions and uses it to determine the interpolation direction and angle.\n\t * Then it applies the interpolation using the quaternion multiplication and adds the\n\t * destination quaternion to obtain the final result.\n\t * \n\t * @param dest 4D quaternion value that is the result of the interpolation, and it\n\t * is modified based on the `shortest` parameter to ensure the interpolated quaternion\n\t * is properly oriented.\n\t * \n\t * \t- `dest.getW()`: represents the scalar component of the quaternion along the z-axis.\n\t * \t- `dest.getX()` and `dest.getY()`: represent the scalar components of the quaternion\n\t * along the x and y axes, respectively.\n\t * \t- `dest.getZ()`: represents the scalar component of the quaternion along the z-axis.\n\t * \t- `correctedDest`: is a new quaternion instance created by adjusting the input\n\t * `dest` if the shortest route criterion is met. Its properties are unchanged from\n\t * `dest`.\n\t * \n\t * @param lerpFactor 0-to-1 value that determines how much the quaternion should be\n\t * interpolated between the source and destination values.\n\t * \n\t * @param shortest shortest path between the two quaternions and when it is set to\n\t * `true`, the function calculates the shortest path by reversing the quaternion if\n\t * the cosine of the dot product is negative.\n\t * \n\t * @returns a new Quaternion instance representing the linear interpolation of the\n\t * original Quaternion based on the given lerp factor and shortest path calculation.\n\t * \n\t * \t- The `Quaternion` object is constructed by multiplying the source quaternion by\n\t * a factor and adding the destination quaternion.\n\t * \t- The `srcFactor` and `destFactor` variables represent the interpolation factors\n\t * between the source and destination quaternions, respectively. These factors are\n\t * computed using the sine of the angle between the source and destination quaternions,\n\t * scaled by the magnitude of the source quaternion.\n\t * \t- The returned quaternion represents a linear combination of the source and\n\t * destination quaternions, with the weights determined by the `lerpFactor` parameter.\n\t */\n\tpublic Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}\n\n\t// From Ken Shoemake's \"Quaternion Calculus and Fast Animation\" article\n\tpublic Quaternion(Matrix4f rot) {\n\t\tfloat trace = rot.get(0, 0) + rot.get(1, 1) + rot.get(2, 2);\n\n\t\tif (trace > 0) {\n\t\t\tfloat s = 0.5f / (float) Math.sqrt(trace + 1.0f);\n\t\t\tw = 0.25f / s;\n\t\t\tx = (rot.get(1, 2) - rot.get(2, 1)) * s;\n\t\t\ty = (rot.get(2, 0) - rot.get(0, 2)) * s;\n\t\t\tz = (rot.get(0, 1) - rot.get(1, 0)) * s;\n\t\t} else {\n\t\t\tif (rot.get(0, 0) > rot.get(1, 1) && rot.get(0, 0) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(0, 0) - rot.get(1, 1) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(1, 2) - rot.get(2, 1)) / s;\n\t\t\t\tx = 0.25f * s;\n\t\t\t\ty = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\tz = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t} else if (rot.get(1, 1) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(1, 1) - rot.get(0, 0) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(2, 0) - rot.get(0, 2)) / s;\n\t\t\t\tx = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\ty = 0.25f * s;\n\t\t\t\tz = (rot.get(2, 1) + rot.get(1, 2)) / s;\n\t\t\t} else {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(2, 2) - rot.get(0, 0) - rot.get(1, 1));\n\t\t\t\tw = (rot.get(0, 1) - rot.get(1, 0)) / s;\n\t\t\t\tx = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t\ty = (rot.get(1, 2) + rot.get(2, 1)) / s;\n\t\t\t\tz = 0.25f * s;\n\t\t\t}\n\t\t}\n\n\t\tfloat length = (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t\tx /= length;\n\t\ty /= length;\n\t\tz /= length;\n\t\tw /= length;\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees around the x-axis to create a forward vector,\n\t * returning a new Vector3f object.\n\t * \n\t * @returns a vector pointing in the forward direction of the object's rotation.\n\t * \n\t * The output is a `Vector3f` object representing the direction from the origin to\n\t * the current position of the rotated object. The vector's coordinates represent the\n\t * x, y, and z components of the forward direction, respectively.\n\t */\n\tpublic Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}\n\n\t/**\n\t * rotates a `Vector3f` instance by 90 degrees around the z-axis, resulting in a\n\t * vector that points backwards from the original position.\n\t * \n\t * @returns a rotated vector with a magnitude of -1.\n\t * \n\t * The `Vector3f` object returned by the function is a transformed version of the\n\t * original vector, where it has been rotated by 90 degrees around the x-axis. This\n\t * means that the x-coordinate of the vector remains unchanged, while the y-coordinate\n\t * is shifted to the negative z-axis, and the z-coordinate is shifted to the positive\n\t * y-axis.\n\t */\n\tpublic Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees around the z-axis, resulting in a vector pointing\n\t * upward from the original position.\n\t * \n\t * @returns a rotated version of the original vector, pointing upwards.\n\t * \n\t * The `Vector3f` object returned represents the upward direction from the current\n\t * position of the entity. The rotation is performed using the `rotate` method, which\n\t * takes the current position of the entity as its argument and returns a new `Vector3f`\n\t * object in the rotated position.\n\t */\n\tpublic Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}\n\n\t/**\n\t * rotates a 3D vector by 90 degrees around the z-axis, resulting in a new vector\n\t * pointing downwards from the original position.\n\t * \n\t * @returns a rotated vector representing the downward direction.\n\t * \n\t * The output is a `Vector3f` object representing the downward direction from the\n\t * current position of the rotation axis.\n\t * \n\t * It has a magnitude of 0 in all dimensions, indicating that it points directly\n\t * downward from the origin.\n\t * \n\t * Its orientation is identical to the orientation of the rotation axis at the time\n\t * the function was called, as determined by the `rotate` method's rotation angle.\n\t */\n\tpublic Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees clockwise to produce a new vector pointing rightward\n\t * in the same coordinate system as the original vector.\n\t * \n\t * @returns a rotated vector representing the right component of the object's position.\n\t * \n\t * The output is a `Vector3f` object, which represents a 3D vector with three elements\n\t * representing x, y, and z components. The value of each element is determined by\n\t * multiplying the corresponding component of the original vector by a scalar value\n\t * of 1.\n\t */\n\tpublic Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}\n\n\t/**\n\t * rotates a vector by 90 degrees clockwise around the x-axis, resulting in a new\n\t * vector that points left from the original position.\n\t * \n\t * @returns a rotated vector with a magnitude of -1 and a direction that is perpendicular\n\t * to the original vector.\n\t * \n\t * The Vector3f object returned is a rotated version of the original vector, with its\n\t * x-axis component shifted to the left by a factor of -1.\n\t * \n\t * The y-axis and z-axis components remain unchanged.\n\t * \n\t * As a result, the new vector has a negative x-axis component, while the other two\n\t * components remain positive.\n\t */\n\tpublic Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}\n\n\t/**\n\t * sets the `x`, `y`, `z`, and `w` fields of a `Quaternion` object to the specified\n\t * values, returning the modified object.\n\t * \n\t * @param x 3D coordinate of the quaternion's axis of rotation.\n\t * \n\t * @param y 2D component of the quaternion, which is multiplied with the original\n\t * quaternion's `x` component to produce the new quaternion value.\n\t * \n\t * @param z 3rd component of the quaternion, which is updated to match the value\n\t * provided by the user.\n\t * \n\t * @param w 4th component of the quaternion, which is used to rotate the object along\n\t * the `z` axis.\n\t * \n\t * @returns a new instance of the `Quaternion` class with the updated values of `x`,\n\t * `y`, `z`, and `w`.\n\t * \n\t * The `Quaternion` object is updated with the new values for `x`, `y`, `z`, and `w`.\n\t * \n\t * After calling the `set` function, the resulting quaternion object retains its\n\t * original values for `x`, `y`, `z`, and `w`.\n\t * \n\t * The `set` function returns a reference to the same `Quaternion` object, allowing\n\t * for chaining of method calls.\n\t */\n\tpublic Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param eulerAngles - @see <a href=\"https://en.wikipedia.org/wiki/Euler_angles#Proper_Euler_angles\">Wikipedia's Article on Euler Angles</a> for a description\n\t *                    of their usage/definition.\n\t * @return The {@link Quaternion} associated with the Euler angles.\n\t */\n\tpublic static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}\n\n\t/**\n\t * sets the values of a quaternion object to those of another quaternion object.\n\t * \n\t * @param r 4-component quaternion that, when passed to the function, sets the\n\t * corresponding components of the output quaternion.\n\t * \n\t * \t- `getX()`, `getY()`, `getZ()`, and `getW()` - These are methods that retrieve\n\t * the real-valued components of a Quaternion object.\n\t * \n\t * @returns a reference to the same `Quaternion` object, with its fields updated with\n\t * the provided values.\n\t * \n\t * \t- The function sets the `x`, `y`, `z`, and `w` components of the `Quaternion`\n\t * object to those of the provided `r` argument.\n\t * \t- The function returns a reference to the modified `Quaternion` object, which is\n\t * the same as the original object passed as an argument.\n\t * \t- The function does not modify the original `Quaternion` object.\n\t */\n\tpublic Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}\n\n\t/**\n\t * retrieves the value of the `x` field, which is a `float` variable.\n\t * \n\t * @returns a floating-point value representing the variable `x`.\n\t */\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\t/**\n\t * sets the value of the `x` field of its object reference parameter to the passed\n\t * float value.\n\t * \n\t * @param x floating-point value that will be assigned to the `x` field of the class\n\t * instance being modified by the `setX()` method.\n\t */\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\t/**\n\t * returns the value of the `y` field.\n\t * \n\t * @returns the value of the `y` field.\n\t */\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\t/**\n\t * sets the value of the object's `y` field to the input `float` value.\n\t * \n\t * @param y 3D position of an object in the `setY()` method, specifying its new value\n\t * for storage within the class instance.\n\t */\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\t/**\n\t * retrieves the value of the `z` field.\n\t * \n\t * @returns a floating-point value representing the z component of an object's position.\n\t */\n\tpublic float getZ() {\n\t\treturn z;\n\t}\n\n\t/**\n\t * sets the value of the field `z` in a class to the argument passed as a float.\n\t * \n\t * @param z 2D coordinate of the current point in the graphical user interface (GUI)\n\t * and sets its corresponding field `this.z` to match the value provided.\n\t */\n\tpublic void setZ(float z) {\n\t\tthis.z = z;\n\t}\n\n\t/**\n\t * retrieves the value of the `w` field, which is a `float` variable representing a\n\t * width value.\n\t * \n\t * @returns the value of the `w` field.\n\t */\n\tpublic float getW() {\n\t\treturn w;\n\t}\n\n\t/**\n\t * sets the value of the field `w` to the argument passed as a float.\n\t * \n\t * @param w 2D width of an object being manipulated by the function.\n\t */\n\tpublic void setW(float w) {\n\t\tthis.w = w;\n\t}\n\n\t/**\n\t * compares two `Quaternion` objects and returns a boolean indicating whether they\n\t * are equal in terms of their x, y, z, and w components.\n\t * \n\t * @param r 4D quaternion to be compared with the current 4D quaternion.\n\t * \n\t * \t- `x`: A double variable representing the x-coordinate of the quaternion.\n\t * \t- `y`: A double variable representing the y-coordinate of the quaternion.\n\t * \t- `z`: A double variable representing the z-coordinate of the quaternion.\n\t * \t- `w`: A double variable representing the w-coordinate of the quaternion.\n\t * \n\t * @returns a boolean value indicating whether the Quaternion object is equal to\n\t * another Quaternion object.\n\t */\n\tpublic boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}\n\t\n}","location":{"start":13,"insert":6,"offset":" ","indent":0,"comment":{"start":5,"end":12}},"item_type":"class","length":681,"docLength":7},{"id":"980155a9-b3df-42b4-d14c-da0e05cdf25d","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"calculates the magnitude or length of a 3D vector by squaring its components and taking the square root.","params":[],"returns":{"type_name":"float","description":"the square root of the sum of the squares of the component values of a vector.","complex_type":false},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0.8f, 0.5f, 0.2f, 0.3f);\nSystem.out.println(\"Length of the quaternion is: \" + q1.length()); // Outputs: Length of the quaternion is: 1.0897644854881722\n","description":""},"name":"length","code":"public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}","location":{"start":48,"insert":42,"offset":"\t","indent":1,"comment":{"start":41,"end":47}},"item_type":"method","length":3,"docLength":6},{"id":"9e13b682-c259-908b-b04c-a97dfe3a0666","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"normalizes a given quaternion by dividing each component by its length, resulting in a new quaternion with a length of 1.","params":[],"returns":{"type_name":"instance","description":"a normalized quaternion representation of the original quaternion.\n\nThe output is a Quaternion object, which represents a rotational transformation in 3D space.\nThe first component of the Quaternion (w / length) represents the direction of the rotation.\nThe second and third components (x / length and y / length) represent the magnitude of the rotation.\nThe fourth component (z / length) represents the axis of rotation.\nAll the components are normalized, meaning they have a length of 1 in the range of -1 to 1.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nSystem.out.println(\"Normalized quaternion: \" + q.normalized());\n","description":"\nExpected output:\n"},"name":"normalized","code":"public Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}","location":{"start":63,"insert":52,"offset":"\t","indent":1,"comment":{"start":51,"end":62}},"item_type":"method","length":5,"docLength":11},{"id":"ec17c474-e3b3-fb93-4849-6e26689b5ba9","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"calculates the conjugate of a quaternion, which is a quaternion with its coordinates reversed.","params":[],"returns":{"type_name":"Quaternion","description":"a new quaternion object with the conjugate of its input values.\n\n* The returned object is of type `Quaternion`, indicating that it represents a quaternion value.\n* The `w` field of the returned object contains the magnitude (or length) of the quaternion.\n* The `-x`, `-y`, and `-z` fields contain the coordinates of the quaternion, which are negated in the returned object relative to their original values in the input quaternion.","complex_type":true},"usage":{"language":"java","code":"// Conjugation of a quaternion object\nQuaternion q1 = new Quaternion(x, y, z, w); // initializing a quaternion object with arbitrary values\nQuaternion q2 = q1.conjugate(); // calling the conjugate() method on the quaternion object and storing the result in q2\n\n// printing out the components of the conjugated quaternion object to check if they are correct\nSystem.out.println(\"Conjugated Quaternion:\");\nSystem.out.println(\"x = \" + q2.getX());\nSystem.out.println(\"y = \" + q2.getY());\nSystem.out.println(\"z = \" + q2.getZ());\nSystem.out.println(\"w = \" + q2.getW());\n","description":""},"name":"conjugate","code":"public Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}","location":{"start":83,"insert":69,"offset":"\t","indent":1,"comment":{"start":68,"end":82}},"item_type":"method","length":3,"docLength":14},{"id":"9417aeea-c7ff-31b8-3b42-11097263ff4f","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"multiplies a quaternion by a scalar value and returns the result as another quaternion.","params":[{"name":"r","type_name":"float","description":"scalar value that is multiplied with the quaternion's components to produce the result quaternion.","complex_type":false}],"returns":{"type_name":"float","description":"a new quaternion instance with the product of the input `r` multiplied by each component of the original quaternion.","complex_type":false},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(1, 0, 0, 0);\nfloat r = 2;\nq1.mul(r).print(); // Prints (4, 0, 0, 0)\n","description":"\nThe input value 'r' is a float representing the scalar multiplication of the quaternion by itself. In this case, since the quaternion has components (1, 0, 0, 0), the output would be (2, 0, 0, 0)."},"name":"mul","code":"public Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}","location":{"start":96,"insert":87,"offset":"\t","indent":1,"comment":{"start":86,"end":95}},"item_type":"method","length":3,"docLength":9},{"id":"60e76816-f896-cfa7-6841-19faf55efc5e","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"multiplies two quaternions element-wise, computing the product of their real and imaginary parts.","params":[{"name":"r","type_name":"Quaternion","description":"4D quaternion to be multiplied with the current quaternion, resulting in a new quaternion output.\n\n* `w`: The magnitude (or length) of the quaternion.\n* `x`, `y`, and `z`: The coordinates of the quaternion.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion instance with the product of two given quaternions.\n\n* The output is a new instance of the `Quaternion` class.\n* The `w_`, `x_,`, `y_`, and `z_` fields of the output represent the product of the `w`, `x`, `y`, and `z` fields of the input `r` Quaternion.\n* The order of the multiplication is (w, x, y, z) * (r.w, r.x, r.y, r.z).","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 2, 3, 4);\nQuaternion q2 = new Quaternion(5, 6, 7, 8);\nQuaternion result = q1.mul(q2);\n","description":"\nIn this example, the method mul would be used to multiply two quaternions together, resulting in a new quaternion object (result) that represents their product. The input arguments are two quaternion objects (q1 and q2) which are being multiplied together using the mul method."},"name":"mul","code":"public Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":118,"insert":100,"offset":"\t","indent":1,"comment":{"start":99,"end":117}},"item_type":"method","length":8,"docLength":18},{"id":"7e7e1ca5-c1f3-ae97-e646-3ff859841c48","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"multiplies a quaternion by a vector and returns the result as a new quaternion.","params":[{"name":"r","type_name":"Vector3f","description":"3D vector to be multiplied with the quaternion.\n\n* `r` is an instance of `Vector3f`, which represents a 3D vector with three components (x, y, and z).\n* `getX()` and `getY()` are methods that retrieve the x and y coordinates of the vector, respectively.\n* `getZ()` is a method that retrieves the z coordinate of the vector.\n\nThe function then computes the product of the quaternion with `r` using the formula: `w_ = -x * r.getX() - y * r.getY() - z * r.getZ();`. The other three components (x_, y_, and z_) are computed as follows: `x_ = w * r.getX() + y * r.getZ() - z * r.getY();`, `y_ = w * r.getY() + x * r.getX() - z * r.getZ();`, and `z_ = w * r.getZ() + x * r.getY() - y * r.getX()`.\n\nFinally, the function returns a new instance of `Quaternion` with the computed values of w_, x_, y_, and z_.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a Quaternion object representing the result of multiplying the input vector `r` by the quaternion.\n\nThe output is a `Quaternion` instance, which represents a rotation matrix in 4D space.\nThe `w_` attribute of the output contains the magnitude (or length) of the quaternion.\nThe `x_, y_, and z_` attributes represent the three axes of the rotation, which can be used to compute the rotation matrix using the following equations:\n\n* x_ represents the axis of rotation around the x-axis\n* y_ represents the axis of rotation around the y-axis\n* z_ represents the axis of rotation around the z-axis\n\nThese axes can be used to create a 3D rotation matrix by multiplying them with their corresponding dot products.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nVector3f v = new Vector3f(1, 2, 3);\n\n// Returns a new quaternion with the product of the two inputs.\nQuaternion p = q.mul(v);\n","description":"\nThe `x` and `y` components of the quaternion are negated, and the `w` component is positive or negative depending on whether the vector points in the same direction as the rotation axis of the quaternion or not."},"name":"mul","code":"public Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":162,"insert":127,"offset":"\t","indent":1,"comment":{"start":126,"end":161}},"item_type":"method","length":8,"docLength":35},{"id":"2060f0f5-3df0-1385-f645-10dce55460af","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"takes a `Quaternion` argument `r` and returns a new `Quaternion` instance with the difference between the original quaternion's values and the given `r`.","params":[{"name":"r","type_name":"Quaternion","description":"4D vector to be subtracted from the current 4D vector, resulting in a new 4D vector that represents the difference between the two vectors.\n\n* `w`: The real part of the quaternion.\n* `x`, `y`, and `z`: The imaginary parts of the quaternion.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new Quaternion object representing the difference between the current Quaternion and the provided Quaternion.\n\n* The output is a new `Quaternion` object with the difference between the input `w`, `x`, `y`, and `z` components.\n* The resulting quaternion represents the difference between the original and input quaternions.\n* The output has the same dimension as the input, meaning it is also a 4-dimensional vector.\n* The order of the output is the opposite of the input, meaning that if the input quaternion is represented as (w, x, y, z), then the output of the `sub` function will be represented as (-w, -x, -y, -z).","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion(0, 1, 0, 0);\nQuaternion q3 = q1.sub(q2);\nSystem.out.println(\"q1 - q2 = \" + q3);\n","description":"\nIn this example, the sub method is being called on an instance of a Quaternion object q1 with the input argument q2. The resulting output of the sub method will be stored in the variable q3.\nThe output for the code will be: q1 - q2 = 0 0 1 -1\nThis is because subtracting the two quaternions results in a new Quaternion object with values of w = 1, x = 0, y = 1, and z = -1."},"name":"sub","code":"public Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}","location":{"start":193,"insert":171,"offset":"\t","indent":1,"comment":{"start":170,"end":192}},"item_type":"method","length":3,"docLength":22},{"id":"287b4a2f-2247-abbb-1140-9d9929bd0f27","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"takes a `Quaternion` object `r` as input and returns a new `Quaternion` object with the sum of its components.","params":[{"name":"r","type_name":"Quaternion","description":"quaternion to be added to the current quaternion, and its value is used to compute the resultant quaternion.\n\n* `r`: A Quaternion object representing the second quaternion to be added. It has four attributes - `W`, `X`, `Y`, and `Z` - which correspond to the real and imaginary parts of the quaternion, respectively.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new Quaternion object representing the sum of the input quaternions.\n\n* The new quaternion is constructed by adding the scalar values of the input quaternions (w, x, y, and z) element-wise.\n* The resulting quaternion represents the sum of the two input quaternions.\n* The quaternion components (w, x, y, and z) are non-negative and sum to 1, ensuring that the quaternion is properly normalized.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    // create a quaternion object and set its values\n    Quaternion q1 = new Quaternion();\n    q1.setX(0);\n    q1.setY(0);\n    q1.setZ(0);\n    q1.setW(1);\n    \n    // create a quaternion object and set its values\n    Quaternion q2 = new Quaternion();\n    q2.setX(1);\n    q2.setY(0);\n    q2.setZ(0);\n    q2.setW(1);\n    \n    // add the quaternions together and set the result to a variable\n    Quaternion sum = q1.add(q2);\n    System.out.println(\"Quaternion Sum: \" + sum);\n}\n","description":"\nThe output of this example would be `Quaternion Sum: (1, 0, 0, 2)`. This is because the add method takes two quaternion objects as parameters, and then returns a new quaternion object that represents the result of adding those two quaternions together. In this case, the resulting quaternion would have x, y, z, and w values of 1, 0, 0, and 2 respectively.\n\nIt's worth noting that this is a simple example, and in reality, you might need to perform more complex operations on two quaternions before returning the result as a new object. For instance, you may need to normalize one or both of the quaternions before performing the addition. Additionally, you may also need to handle boundary conditions where the input quaternion objects have values that are not within the valid range for a Quaternion."},"name":"add","code":"public Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}","location":{"start":217,"insert":197,"offset":"\t","indent":1,"comment":{"start":196,"end":216}},"item_type":"method","length":3,"docLength":20},{"id":"c38449e2-fe12-9ea9-d949-47c3df572c24","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"generates a rotation matrix based on three vector inputs representing the x, y, and z axes of a 3D space. The resulting matrix is used to represent a rotation in a 3D space.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 rotation matrix.\n\n* The `Matrix4f` object is initialized with the forward, up, and right vectors as input.\n* These vectors represent the rotation axis and direction in 3D space.\n* The rotation matrix is returned in a 4x4 format, which represents the orientation of the rotation in homogeneous coordinates.\n* Each element of the matrix represents the dot product of the corresponding vector in the input with the rotation axis.\n* The resulting matrix can be used to perform rotations in 3D space, such as rotating an object around a specific axis or aligning multiple objects relative to each other.","complex_type":true},"usage":{"language":"java","code":"// Declare a variable for the quaternion.\nQuaternion q = new Quaternion(1f, 2f, 3f, 4f);\n\n// Convert the quaternion to a rotation matrix and store it in a variable.\nMatrix4f rotationMatrix = q.toRotationMatrix();\n","description":"\nThis code will take the given quaternion and convert it into a rotation matrix that can be used for rotation purposes. The resulting Matrix4f object stores the resulting rotation matrix, which is used to rotate objects using the Quaternion class's rotation methods."},"name":"toRotationMatrix","code":"public Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}","location":{"start":243,"insert":221,"offset":"\t","indent":1,"comment":{"start":220,"end":242}},"item_type":"method","length":7,"docLength":22},{"id":"abc1a1a3-a5cb-d78e-eb48-8c6308d47912","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"computes the dot product of two Quaternions, returning a floating-point value between -1 and 1.","params":[{"name":"r","type_name":"Quaternion","description":"4D quaternion to be multiplied with the `x`, `y`, `z`, and `w` components of the current quaternion, resulting in the dot product of the two quaternions.\n\n* `x`, `y`, `z`, and `w` are float values representing the components of the quaternion.\n* `getX()`, `getY()`, `getZ()`, and `getW()` are methods that return these component values for further processing in the function body.","complex_type":true}],"returns":{"type_name":"float","description":"a float value representing the dot product of two quaternions.","complex_type":false},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(1, 2, 3, 4);\nQuaternion r = new Quaternion(5, 6, 7, 8);\n\nfloat result = q1.dot(r);\nSystem.out.println(\"The dot product between quaternions q1 and r is \" + result); // prints \"The dot product between quaternions q1 and r is 70\"\n","description":""},"name":"dot","code":"public float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}","location":{"start":264,"insert":251,"offset":"\t","indent":1,"comment":{"start":250,"end":263}},"item_type":"method","length":3,"docLength":13},{"id":"7a864b7e-8289-7eaf-504e-263f5f7791c3","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"computes a quaternion interpolation between two given quaternions using the linear interpolation formula. The function takes into account the shortest path and returns the interpolated quaternion normalized to have a length of 1.","params":[{"name":"dest","type_name":"Quaternion","description":"4-element quaternion value that will be lerped towards the provided target value.\n\n* `Quaternion dest`: The destination quaternion to which the interpolation will be applied.\n* `lerpFactor`: A float value representing the interpolation factor between the start and end quaternions.\n* `shortest`: An boolean value indicating whether the shortest path should be taken (true) or not (false). If true, the function will correct the destination quaternion if its dot product with the input quaternion is negative.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0-1 value that determines how much the destination quaternion is linearly interpolated from the source quaternion during the nearest-neighbor search.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"4-vector of the shortest quaternion that will be returned if it is set to `true`, otherwise, the normalized quaternion will be returned regardless of its length.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a normalized quaternion that represents the linear interpolation of the given quaternion based on the provided factor.\n\n* The output is a Quaternion object, representing a linear interpolation between the input `dest` and the current value of the `this` parameter.\n* If the `shortest` parameter is set to `true`, and the dot product of the `this` parameter and the `dest` parameter is less than zero, the output is inverted to ensure that the interpolation points towards the origin.\n* The output is normalized to have a length of one.","complex_type":true},"usage":{"language":"java","code":"Quaternion quat1 = new Quaternion(1, 0, 0, 0); // quaternion with w component 1 and x, y, z components all 0.\nQuaternion quat2 = new Quaternion(2, 3, 4, 5); // quaternion with w component 2, x component 3, y component 4, and z component 5.\n\nfloat lerpFactor = 0.7f; // interpolate between the two quaternions by this factor.\nboolean shortest = true; // make sure to take the shortest path from this.\n\nQuaternion result = quat1.NLerp(quat2, lerpFactor, shortest);\n","description":"\nThe above code would set 'result' to be a quaternion with w component 1.485714 and x, y, z components all 0.793655. This is because the dot product between 'quat1' and 'quat2' is negative, so we need to invert the second quaternion before interpolating. The lerp factor is set at 0.7, which means that 70% of the way from 'quat1' to 'quat2', and 30% of the way back to 'quat1'. When we add this result to 'quat1', we get a quaternion that is 80% of the distance between 'quat1' and 'quat2', and 20% of the distance from 'quat2' to '-quat2'.\nBy setting 'shortest = true', the method takes into account that the shortest path is taken. This means that instead of interpolating through '-quat2', it takes the shorter path which goes through quat1. As a result, the resulting quaternion has w component 1.76534 and x, y, z components all -0.893695. This is because the dot product between 'quat1' and '-quat2' is negative, but the dot product between 'quat1' and '-quat2' is positive, so we need to invert '-quat2' before interpolating. The lerp factor is set at 0.7 again, which means that 70% of the way from 'quat1' to '-quat2', and 30% of the way back to 'quat1'. When we add this result to 'quat1', we get a quaternion that is 84% of the distance between 'quat1' and '-quat2', and 16% of the distance from '-quat2' to '-quat2'."},"name":"NLerp","code":"public Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}","location":{"start":304,"insert":268,"offset":"\t","indent":1,"comment":{"start":267,"end":303}},"item_type":"method","length":8,"docLength":36},{"id":"0c58f678-a964-7184-0c4b-2bbca20d9931","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"computes a linear interpolation between two Quaternion values based on the input lerp factor and a boolean flag for shortest path.","params":[{"name":"dest","type_name":"Quaternion","description":"4-component quaternion that the returned quaternion will be blended with, based on the specified `lerpFactor`.\n\n* `dest.getW()` represents the scalar component of the quaternion.\n* `dest.getX()`, `dest.getY()`, and `dest.getZ()` represent the vector components of the quaternion.\n\nThe `correctedDest` variable is created to handle the case where the dot product between the current quaternion and the destination quaternion is negative, which indicates that the quaternion needs to be inverted before interpolating.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0-1 value that determines how much the quaternion should be linearly interpolated towards the destination quaternion, with values closer to 0 resulting in slower interpolation and values closer to 1 resulting in faster interpolation.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"shortest quaternion path between the source and destination, which is computed by negating the destination quaternion when the cosine of the dot product between the two quaternions is less than or equal to 1, and then using the `NLerp()` function to interpolate the quaternion.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a Quaternion representation of the linear interpolation between two given Quaternions, based on the specified lerp factor and shortest path setting.\n\n* The output is a Quaternion object, representing a rotational transformation.\n* The quaternion is constructed by multiplying the input source and destination quaternions with scaling factors, and then adding the resulting vectors.\n* The scaling factors are calculated using the sine of the angle between the source and destination quaternions, and the length of the source quaternion.\n* If `shortest` is set to true, the quaternion is corrected to ensure that the result is always a rotation towards the destination quaternion, regardless of the orientation of the source quaternion. This is done by negating the source quaternion if the dot product of the source and destination quaternions is negative.\n* The output quaternion represents a linear interpolation between the source and destination quaternions, based on the `lerpFactor` parameter.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion(1, 1, 1, 1);\nfloat lerpFactor = 0.5f;\nboolean shortest = false;\nQuaternion result = q1.SLerp(q2, lerpFactor, shortest);\n","description":"\nIn this example, q1 and q2 are two Quaternion objects that represent the rotation of an object in 3D space. The SLerp method is used to interpolate between these two rotations with a factor of 0.5 (halfway) and without considering the shortest path (shortest argument is false). The result is stored in the variable result, which is also a Quaternion object that represents the rotation that results from interpolating between q1 and q2 at a factor of 0.5."},"name":"SLerp","code":"public Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}","location":{"start":351,"insert":313,"offset":"\t","indent":1,"comment":{"start":312,"end":350}},"item_type":"method","length":23,"docLength":38},{"id":"90b531be-225c-f2bb-e845-ebc4e268a382","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis to produce a forward-facing vector.","params":[],"returns":{"type_name":"Vector3f","description":"a vector representing the forward direction of the rotated object.\n\nThe return value is a `Vector3f` object, indicating that it has three components - x, y, and z. The values of these components are determined by multiplying the corresponding components of the original vector by a scalar value of 0, 0, and 1, respectively. This results in a vector that points in the direction of the original vector but with its magnitude reduced to 1.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 1, 0, 0);\nVector3f forward = q.getForward();\n","description":"\nThis method is a simple wrapper to the rotate method of the Vector3f class, which rotates a vector by a quaternion. It creates a new vector with (0, 0, 1) coordinates and returns the result of the rotation.\nThe reason for this method is that it provides an easy way to get the forward direction of an object defined by its rotation. The quaternion can be used as an input to the rotate method of other objects to create a new vector that is in the same direction as the original vector, but rotated according to the rotation defined by the Quaternion.\nFor example, if we wanted to get the forward direction of an object defined by its rotation, we could use this method as follows:\n"},"name":"getForward","code":"public Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}","location":{"start":424,"insert":414,"offset":"\t","indent":1,"comment":{"start":413,"end":423}},"item_type":"method","length":3,"docLength":10},{"id":"9932b588-bd62-0fa3-b44c-6d4b07aa5153","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"rotates a `Vector3f` instance by 90 degrees around the x-axis, resulting in a vector pointing towards the negative z-axis.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of -1 in the opposite direction of the original vector.\n\n* The output is a vector with three elements, representing the position of an object in 3D space.\n* The first element represents the x-coordinate of the position, the second element represents the y-coordinate, and the third element represents the z-coordinate.\n* The vector is created by rotating the original vector (0, 0, -1) around the center of the object using the `rotate` method. This results in a vector that points in the opposite direction of the object's facing.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 1, 0, 0);\nVector3f v = q.getBack();\nSystem.out.println(v.toString()); // (0, 0, -1)\n","description":"\nThis example creates a Quaternion with the following components: x = 0, y = 1, z = 0, w = 0. It then uses the method getBack() on this quaternion to calculate its back vector, which is represented as a Vector3f object with (0, 0, -1). The output is printed using the toString method of the vector and shows that the x, y, and z components are all equal to zero, while the w component is negative one."},"name":"getBack","code":"public Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}","location":{"start":440,"insert":428,"offset":"\t","indent":1,"comment":{"start":427,"end":439}},"item_type":"method","length":3,"docLength":12},{"id":"03e7b44e-a1e4-ffaf-7945-2fc521873eca","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"rotates a vector by 90 degrees around the z-axis, resulting in a new vector pointing upwards from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of 1 and an orientation of upwards.\n\n* The output is a `Vector3f` object representing the up direction in 3D space.\n* The vector has an x-component of 0, a y-component of 1, and a z-component of 0, indicating that it points directly upwards in the 3D space.\n* The rotation is applied to the input vector using the `rotate` method, which creates a new vector by rotating the original vector around the specified axis. In this case, the axis is the same as the direction of the output vector.","complex_type":true},"usage":{"language":"java","code":"Vector3f up = new Vector3f(0, 1, 0);\nQuaternion q = new Quaternion();\n\nup = up.rotate(q); // rotates the vector by the quaternion q\n","description":"\nThis code creates a `Quaternion` object named `q`, and uses it to rotate a `Vector3f` object by 180 degrees around the y-axis (using the `rotate()` method). The resulting rotated vector is then stored in the `up` variable."},"name":"getUp","code":"public Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}","location":{"start":455,"insert":444,"offset":"\t","indent":1,"comment":{"start":443,"end":454}},"item_type":"method","length":3,"docLength":11},{"id":"bdf81a6d-e783-d18c-6346-c547533db74d","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"rotates a `Vector3f` instance by 90 degrees around the z-axis, resulting in a vector pointing downwards from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of 0 and a direction that points downward from the original vector's position.\n\nThe output is a `Vector3f` object representing the downward direction from the current position.\nIt is created by applying a rotation to the original position using the `rotate` method.\nThe rotation is performed based on the position of the current object, which means that the resulting vector points in the opposite direction of the current object's movement.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion q = new Quaternion();\n    Vector3f downVector = q.getDown();\n    System.out.println(\"downVector: \" + downVector);\n}\n","description":"\nThe code will print out a vector with x, y and z values as 0 and w value -1. This is because the method rotate(this) rotates the quaternion by its own rotation in order to get the down vector.\n\nIn general, it would be best to test this with different quaternions to ensure that you are getting the correct result, but this example should be sufficient for understanding how the code works."},"name":"getDown","code":"public Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}","location":{"start":474,"insert":459,"offset":"\t","indent":1,"comment":{"start":458,"end":473}},"item_type":"method","length":3,"docLength":15},{"id":"585bd5b8-a38d-5dad-4e4c-d1b7ddac9938","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"rotates a `Vector3f` instance by 90 degrees around the x-axis, resulting in a new vector that points towards the right direction.","params":[],"returns":{"type_name":"Vector3f","description":"a rotation of the original vector by 90 degrees around the x-axis.\n\n* The output is a new `Vector3f` object that represents the rightward orientation of the current vector.\n* The rotation is performed by taking the original vector and applying a rotate transformation using the `rotate` method, which takes no arguments.\n* The resulting vector has a magnitude of 1 and a direction that is 90 degrees counter-clockwise from the original vector's direction.","complex_type":true},"usage":{"language":"java","code":"Vector3f up = new Vector3f(0, 1, 0).rotate(quaternion);\n","description":"\nIn this example, a vector representing the y-axis (upward direction) is created and rotated by the given quaternion. This is equivalent to getting the right vector of a rotated coordinate system. The resulting vector will represent the new x-axis."},"name":"getRight","code":"public Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}","location":{"start":489,"insert":478,"offset":"\t","indent":1,"comment":{"start":477,"end":488}},"item_type":"method","length":3,"docLength":11},{"id":"d335e449-043a-e7b3-ac4d-82aa72519e59","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"rotates a vector by 90 degrees counterclockwise around the x-axis, resulting in a new vector that points left from the original one.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated version of the original vector, with its x-component changed to -1.\n\n* The return type is `Vector3f`, indicating that it is a 3D vector with floating-point values.\n* The expression `-1, 0, 0` represents the coordinates of the leftmost point in the original vector.\n* The `rotate` method is applied to the original vector to produce the rotated vector.\n\nThe properties of the output depend on the type of rotation performed by the `rotate` method. In this case, it is a clockwise rotation around the origin, resulting in a vector that points in the negative z-direction.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nVector3f v = q.getLeft();\nSystem.out.println(\"q = \" + q + \", v = \" + v);\n","description":"\nThis code would output the following:\n"},"name":"getLeft","code":"public Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}","location":{"start":508,"insert":493,"offset":"\t","indent":1,"comment":{"start":492,"end":507}},"item_type":"method","length":3,"docLength":15},{"id":"ac788af4-69ba-c791-8147-dc2c3d1051a5","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"sets the values of a Quaternion object's `x`, `y`, `z`, and `w` fields to the specified arguments.","params":[{"name":"x","type_name":"float","description":"3D position of the quaternion along the x-axis.","complex_type":false},{"name":"y","type_name":"float","description":"2D component of the quaternion.","complex_type":false},{"name":"z","type_name":"float","description":"3rd component of the quaternion, which is updated to match the provided value.","complex_type":false},{"name":"w","type_name":"float","description":"4th component of the quaternion, which is used to rotate the object along the `z` axis.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a new instance of the `Quaternion` class with the updated values of `x`, `y`, `z`, and `w`.\n\nThe `Quaternion` object is updated with the provided values for `x`, `y`, `z`, and `w`. These values are assigned to the corresponding fields of the object.\n\nAs a result, the returned `Quaternion` object has the updated values of its fields, which can be used to represent the rotation more accurately. The returned object is the same as the original one, indicating that the method is idempotent.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nq.set(5, 6, 7, 8).equals(new Quaternion(5, 6, 7, 8)); // true\n","description":"\nThis is because set method takes 4 float arguments and sets them to the current instance of Quaternion object which will be equal to the new Quaternion object created with the same values.  \n\nThis is a very simple example that does not require an explanation because it uses basic arithmetic operations. In general, this type of code should be used in tests, not in production code. It is also generally considered as bad practice to write \"hallucinated\" input values for testing purposes.\n\nNote that the method set() returns a reference to the modified object which is the same as the original object passed as an argument. This allows chaining of operations and makes the code more readable."},"name":"set","code":"public Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}","location":{"start":538,"insert":512,"offset":"\t","indent":1,"comment":{"start":511,"end":537}},"item_type":"method","length":7,"docLength":26},{"id":"f36893bf-ed8e-aaa5-5241-0536dda2cc82","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"takes a `Vector3f` object representing Euler angles and returns a Quaternion object representing the corresponding rotation transformation.","params":[{"name":"eulerAngles","type_name":"Vector3f","description":"3D Euler angles of a rotation, which are used to calculate the quaternion representation of the rotation.\n\n* `phi`: The Euler angle representing the rotation around the x-axis.\n* `theta`: The Euler angle representing the rotation around the y-axis.\n* `yota`: The Euler angle representing the rotation around the z-axis.\n\nThe function then stores the necessary cosines and sins of these angles locally to avoid recalculating them, before constructing the quaternion output.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a quaternion representation of the input Euler angles.\n\n* `q0`, `q1`, `q2`, and `q3` are the four components of the quaternion representation of the rotation angle. These values range from -1 to 1 and can be interpreted as the x, y, z, and w components of a quaternion, respectively.\n* The quaternion is represented in the form `q = q0 + q1*i + q2*j + q3*k`, where `i`, `j`, and `k` are the imaginary units that satisfy the quaternion algebra rules.\n* The quaternion is normalized to have a length of 1, ensuring that it represents a valid rotation angle in 3D space.\n* The function returns a new Quaternion object containing the resulting quaternion representation of the input Euler angles.","complex_type":true},"name":"fromEuler","code":"public static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}","location":{"start":551,"insert":546,"offset":"\t","indent":1,"comment":{"start":545,"end":550}},"item_type":"method","length":23,"docLength":5},{"id":"8d133f54-3800-04a2-e44e-dcbd23d4cffb","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"sets the quaternion components of the provided `Quaternion` object to the corresponding values of the given quaternion.","params":[{"name":"r","type_name":"Quaternion","description":"4-element vector that contains the new values to be set for the quaternion's components.\n\nQuaternion `r`: This is the input quaternion that represents a rotation. It has four components: `x`, `y`, `z`, and `w`. Each component corresponds to a real number that represents a value between 0 and 1, inclusive.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a reference to the same `Quaternion` object, unchanged.\n\n* The `set` function takes four arguments, each representing a component of the input quaternion.\n* The function updates the corresponding components of this quaternion using the given values.\n* After updating the components, the function returns this quaternion as its output.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion quat1 = new Quaternion();\n    Quaternion quat2 = new Quaternion();\n    \n    quat1.setX(0.4f);\n    quat1.setY(-3.5f);\n    quat1.setZ(2.6f);\n    quat1.setW(-1.7f);\n    \n    quat2.set(quat1); // Quaternion object with values (0.4, -3.5, 2.6, -1.7) copied to another quaternion object.\n}\n","description":""},"name":"set","code":"public Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}","location":{"start":593,"insert":575,"offset":"\t","indent":1,"comment":{"start":574,"end":592}},"item_type":"method","length":4,"docLength":18},{"id":"2ed697dc-52be-01b2-c44f-bdf9cc63217f","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"retrieves the value of the `x` field, which is a `float` variable.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the variable `x`.","complex_type":false},"usage":{"language":"java","code":"public class Quaternion {\n    public float x;\n    public float y;\n    public float z;\n    public float w;\n    \n    /**\n     * Constructor for objects of class Quaternion\n     */\n    public Quaternion() {}\n    \n    /**\n     * Constructor for objects of class Quaternion\n     * \n     * @param x X component of the quaternion.\n     * @param y Y component of the quaternion.\n     * @param z Z component of the quaternion.\n     * @param w W component of the quaternion.\n     */\n    public Quaternion(float x, float y, float z, float w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    \n    /**\n     * Returns the X component of the quaternion.\n     * \n     * @return The X component of the quaternion.\n     */\n    public float getX() {\n        return x;\n    }\n}\n","description":"\nExample usage:\n"},"name":"getX","code":"public float getX() {\n\t\treturn x;\n\t}","location":{"start":603,"insert":598,"offset":"\t","indent":1,"comment":{"start":597,"end":602}},"item_type":"method","length":3,"docLength":5},{"id":"c52cc070-59a5-c595-c345-61983c0363e2","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"sets the value of the `x` field of the object on which it is called, to the argument passed as a float.","params":[{"name":"x","type_name":"float","description":"float value that will be assigned to the `x` field of the class object.","complex_type":false}],"usage":{"language":"java","code":"public class Quaternion {\n\tprivate float x, y, z, w;\n\n\t// getters and setters...\n}\n\nQuaternion myQuat = new Quaternion(1.0f, 2.0f, 3.0f, 4.0f);\nmyQuat.setX(-1.5f); // sets the x component of the quaternion to -1.5\n","description":"\nIn this example, `setX` is a method that takes one float parameter and returns no value, meaning it will modify the `x` field of its object reference parameter to match the value provided as an argument. In this case, the x component of the quaternion is set to -1.5 by calling `myQuat.setX(-1.5f)`."},"name":"setX","code":"public void setX(float x) {\n\t\tthis.x = x;\n\t}","location":{"start":614,"insert":607,"offset":"\t","indent":1,"comment":{"start":606,"end":613}},"item_type":"method","length":3,"docLength":7},{"id":"c8f0f166-fffd-ee8d-3140-9e5dd28ba3c0","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"returns the value of the variable `y`.","params":[],"returns":{"type_name":"float","description":"the value of the `y` field.","complex_type":false},"usage":{"language":"java","code":"Quaternion quat = new Quaternion(0, 1, 0, 0); // create a quaternion object with default values\nfloat y = quat.getY();                       // retrieve the value of the y field of quaternion object\nSystem.out.println(y);                      // print the value of the retrieved y field\n","description":"\nIn this example, we created a `Quaternion` object with default values and then retrieved its y component using the `getY()` method. We then printed the value retrieved from the y component to the console. The output should be 1.0f."},"name":"getY","code":"public float getY() {\n\t\treturn y;\n\t}","location":{"start":623,"insert":618,"offset":"\t","indent":1,"comment":{"start":617,"end":622}},"item_type":"method","length":3,"docLength":5},{"id":"4cc9a2b8-922c-6b87-e14c-9cda1536cf22","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"sets the value of the `y` field in the object to which it belongs.","params":[{"name":"y","type_name":"float","description":"2D coordinate's Y value that is being assigned to the `y` field of the object instance upon invocation of the `setY()` method.","complex_type":false}],"usage":{"language":"java","code":"public class Test {\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion();\n        \n        // Set the y-component of the quaternion to 1.0f\n        q.setY(1.0f);\n        \n        // Print out the y-component of the quaternion\n        System.out.println(\"The y-component of the quaternion is: \" + q.getY());\n    }\n}\n","description":""},"name":"setY","code":"public void setY(float y) {\n\t\tthis.y = y;\n\t}","location":{"start":633,"insert":627,"offset":"\t","indent":1,"comment":{"start":626,"end":632}},"item_type":"method","length":3,"docLength":6},{"id":"c1bc1686-8622-0789-3c42-9be00aa0796d","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"returns the value of the `z` field.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the z component of an object's position.","complex_type":false},"usage":{"language":"java","code":"public class Test {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion();\n        System.out.println(\"Quaternion Z: \" + quat.getZ());\n    }\n}\n","description":""},"name":"getZ","code":"public float getZ() {\n\t\treturn z;\n\t}","location":{"start":642,"insert":637,"offset":"\t","indent":1,"comment":{"start":636,"end":641}},"item_type":"method","length":3,"docLength":5},{"id":"cfca1474-0981-a294-3544-072e61552669","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"sets the value of the member variable `z` to the input float parameter.","params":[{"name":"z","type_name":"float","description":"3D position of an object or entity, and by assigning a new value to it within the function, the object's position is updated.","complex_type":false}],"usage":{"language":"java","code":"float z = 10.5; // Some arbitrary float value\nmyQuaternion.setZ(z);\n","description":"\nIn this example, we have a `myQuaternion` object of type Quaternion and are assigning the value `10.5` to its Z component. The method setZ takes in an argument of type `float` which is then assigned to the Quaternion's z component."},"name":"setZ","code":"public void setZ(float z) {\n\t\tthis.z = z;\n\t}","location":{"start":652,"insert":646,"offset":"\t","indent":1,"comment":{"start":645,"end":651}},"item_type":"method","length":3,"docLength":6},{"id":"8831ef22-696b-2798-ef4f-9aea0f790c9a","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"returns the `w` field's value.","params":[],"returns":{"type_name":"float","description":"a float value representing the variable `w`.","complex_type":false},"usage":{"language":"java","code":"public class MyClass {\n    private Quaternion myQuat;\n\n    public void doSomething() {\n        float w = myQuat.getW();\n        // use w here\n    }\n}\n","description":"\nIn this example, the method getW is being used to retrieve the w value of a quaternion object. It is then used as a local variable in the doSomething method to be used further on."},"name":"getW","code":"public float getW() {\n\t\treturn w;\n\t}","location":{"start":662,"insert":656,"offset":"\t","indent":1,"comment":{"start":655,"end":661}},"item_type":"method","length":3,"docLength":6},{"id":"000ab821-98d9-86a7-0e41-16cb4d29f10d","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"sets the value of the field `w` of the current object to the argument passed as a float value.","params":[{"name":"w","type_name":"float","description":"float value that sets the `w` field of the current object.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.setW(10);\n","description":"\nIn the above example, we have created a `Quaternion` object and set its `w` component to 10."},"name":"setW","code":"public void setW(float w) {\n\t\tthis.w = w;\n\t}","location":{"start":671,"insert":666,"offset":"\t","indent":1,"comment":{"start":665,"end":670}},"item_type":"method","length":3,"docLength":5},{"id":"1d3f2b15-a343-0088-bd43-9abd52146656","ancestors":["19e8e215-53aa-4a8f-084d-0452ec3fe116"],"type":"function","description":"compares two Quaternion objects by checking for exact matching of all component values.","params":[{"name":"r","type_name":"Quaternion","description":"4D vector that is being compared to the current 4D vector for equality.\n\n`x`, `y`, `z`, and `w` represent the respective components of the quaternion.","complex_type":true}],"returns":{"type_name":"Boolean","description":"a boolean value indicating whether two quaternions are equal.\n\n1. The method returns a boolean value indicating whether the specified `Quaternion` instance is equal to the current instance.\n2. The comparison is based on the values of the x, y, z, and w components of both instances.\n3. If any of these components differ, the method returns false.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 0, 0);\nQuaternion q2 = new Quaternion(0, 0, 0, 0);\n\nq1.setX(0);\nq1.setY(0);\nq1.setZ(0);\nq1.setW(0);\n\nq2.setX(0);\nq2.setY(0);\nq2.setZ(0);\nq2.setW(0);\n\nassertEquals(true, q1.equals(q2));\n","description":"\nThis example initializes two quaternions, `q1` and `q2`, with the same values for their x, y, z, and w components. The method `setX()` is then used to set these values to 0, followed by calls to `setY()`, `setZ()`, and `setW()` with the value of 0. The method `equals()` is called on both quaternions, which returns `true` indicating that they are equal in terms of their x, y, z, and w components."},"name":"equals","code":"public boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}","location":{"start":689,"insert":675,"offset":"\t","indent":1,"comment":{"start":674,"end":688}},"item_type":"method","length":3,"docLength":14}]}}}