{"name":"Quaternion.java","path":"src/com/ch/math/Quaternion.java","content":{"structured":{"description":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations.","diagram":"digraph G {\n    label=\"com.todo.FixMe\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Matrix4f\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Quaternion [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Vector3f\n    }\n    edge [color=\"#26de81\"]\n    Quaternion -> Vector3f [style=\"dashed\"]\n    Quaternion -> Vector3f \n    Transform -> Quaternion \n    Vector3f -> Quaternion [style=\"dashed\"]\n    Quaternion -> Quaternion [style=\"dashed\"]\n    Quaternion -> Quaternion \n    Vector3f -> Quaternion \n    Quaternion -> Transform \n    Quaternion -> Matrix4f \n}\n","items":[{"id":"11be02ef-b586-d88c-0946-b87525d56d2b","ancestors":[],"type":"function","description":"is a mathematical utility class that provides functions to perform quaternion arithmetic and conversion between various formats. It includes methods for calculating quaternion multiplication, conjugation, normalization, rotation, and conversion from Euler angles. Additionally, it provides getters and setters for the quaternion's x, y, z, and w components.","name":"Quaternion","code":"public class Quaternion {\n\n\tprivate float x;\n\tprivate float y;\n\tprivate float z;\n\tprivate float w;\n\n\tpublic Quaternion() {\n\t\tthis(0, 0, 0, 0);\n\t}\n\n\t\n\tpublic Quaternion(float w, float x, float y, float z) {\n\t\tthis.w = w;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\tpublic Quaternion(Vector3f axis, float angle) {\n\t\tfloat sinHalfAngle = (float) Math.sin(angle / 2);\n\t\tfloat cosHalfAngle = (float) Math.cos(angle / 2);\n\n\t\tthis.x = axis.getX() * sinHalfAngle;\n\t\tthis.y = axis.getY() * sinHalfAngle;\n\t\tthis.z = axis.getZ() * sinHalfAngle;\n\t\tthis.w = cosHalfAngle;\n\t}\n\n\tpublic float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}\n\n\tpublic Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}\n\n\tpublic Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}\n\n\tpublic Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}\n\n\tpublic Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\tpublic Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}\n\n\tpublic Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}\n\n\tpublic Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}\n\n\tpublic Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}\n\n\tpublic float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}\n\n\tpublic Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}\n\n\tpublic Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}\n\n\t// From Ken Shoemake's \"Quaternion Calculus and Fast Animation\" article\n\tpublic Quaternion(Matrix4f rot) {\n\t\tfloat trace = rot.get(0, 0) + rot.get(1, 1) + rot.get(2, 2);\n\n\t\tif (trace > 0) {\n\t\t\tfloat s = 0.5f / (float) Math.sqrt(trace + 1.0f);\n\t\t\tw = 0.25f / s;\n\t\t\tx = (rot.get(1, 2) - rot.get(2, 1)) * s;\n\t\t\ty = (rot.get(2, 0) - rot.get(0, 2)) * s;\n\t\t\tz = (rot.get(0, 1) - rot.get(1, 0)) * s;\n\t\t} else {\n\t\t\tif (rot.get(0, 0) > rot.get(1, 1) && rot.get(0, 0) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(0, 0) - rot.get(1, 1) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(1, 2) - rot.get(2, 1)) / s;\n\t\t\t\tx = 0.25f * s;\n\t\t\t\ty = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\tz = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t} else if (rot.get(1, 1) > rot.get(2, 2)) {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(1, 1) - rot.get(0, 0) - rot.get(2, 2));\n\t\t\t\tw = (rot.get(2, 0) - rot.get(0, 2)) / s;\n\t\t\t\tx = (rot.get(1, 0) + rot.get(0, 1)) / s;\n\t\t\t\ty = 0.25f * s;\n\t\t\t\tz = (rot.get(2, 1) + rot.get(1, 2)) / s;\n\t\t\t} else {\n\t\t\t\tfloat s = 2.0f * (float) Math.sqrt(1.0f + rot.get(2, 2) - rot.get(0, 0) - rot.get(1, 1));\n\t\t\t\tw = (rot.get(0, 1) - rot.get(1, 0)) / s;\n\t\t\t\tx = (rot.get(2, 0) + rot.get(0, 2)) / s;\n\t\t\t\ty = (rot.get(1, 2) + rot.get(2, 1)) / s;\n\t\t\t\tz = 0.25f * s;\n\t\t\t}\n\t\t}\n\n\t\tfloat length = (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t\tx /= length;\n\t\ty /= length;\n\t\tz /= length;\n\t\tw /= length;\n\t}\n\n\tpublic Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}\n\n\tpublic Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}\n\n\tpublic Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}\n\n\tpublic Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}\n\n\tpublic Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param eulerAngles - @see <a href=\"https://en.wikipedia.org/wiki/Euler_angles#Proper_Euler_angles\">Wikipedia's Article on Euler Angles</a> for a description\n\t *                    of their usage/definition.\n\t * @return The {@link Quaternion} associated with the Euler angles.\n\t */\n\tpublic static Quaternion fromEuler(Vector3f eulerAngles) {\n\t\t//eulerAngles = [phi, theta, yota]\n\t\tfloat phi = eulerAngles.getX();\n\t\tfloat theta = eulerAngles.getY();\n\t\tfloat yota = eulerAngles.getZ();\n\n\n\t\t//locally store all cos/sin so we don't have to calculate them twice each\n\t\tfloat cos_half_phi = (float) Math.cos(phi / 2.0f);\n\t\tfloat sin_half_phi = (float) Math.sin(phi / 2.0f);\n\t\tfloat cos_half_theta = (float) Math.cos(theta / 2.0f);\n\t\tfloat sin_half_theta = (float) Math.sin(theta / 2.0f);\n\t\tfloat cos_half_yota = (float) Math.cos(yota / 2.0f);\n\t\tfloat sin_half_yota = (float) Math.sin(yota / 2.0f);\n\n\t\tfloat q0 = cos_half_phi * cos_half_theta * cos_half_yota + sin_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q1 = sin_half_phi * cos_half_theta * cos_half_yota - cos_half_phi * sin_half_theta * sin_half_yota;\n\t\tfloat q2 = cos_half_phi * sin_half_theta * cos_half_yota + sin_half_phi * cos_half_theta * sin_half_yota;\n\t\tfloat q3 = cos_half_phi * cos_half_theta * sin_half_yota - sin_half_phi * sin_half_theta * cos_half_yota;\n\n\t\treturn new Quaternion(q0, q1, q2, q3);\n\n\t}\n\n\tpublic Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}\n\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic void setX(float x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\tpublic float getZ() {\n\t\treturn z;\n\t}\n\n\tpublic void setZ(float z) {\n\t\tthis.z = z;\n\t}\n\n\tpublic float getW() {\n\t\treturn w;\n\t}\n\n\tpublic void setW(float w) {\n\t\tthis.w = w;\n\t}\n\n\tpublic boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}\n\t\n}","location":{"start":6,"insert":6,"offset":" ","indent":0,"comment":null},"item_type":"class","length":260,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"b036ade3-d7a5-a9aa-b641-537e75a81770","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"calculates the magnitude of a 3D vector by taking the square root of the sum of its x, y, and z components.","params":[],"returns":{"type_name":"float","description":"the square root of the sum of the squares of the coordinates of a 3D point.","complex_type":false},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.set(0, 0, 1, 0);\nfloat len = q.length(); // returns sqrt(0^2 + 0^2 + 1^2 + 0^2) = sqrt(2)\n","description":"\nThe example is short and concise. It creates a Quaternion object with the default values, then uses the length method to get its length. This length can be used for any purpose, such as normalizing a quaternion or determining if a quaternion's components are within a certain range.\nThis example does not require much explanation, as it is self-explanatory. The code is also short and simple enough that it should work correctly without any errors."},"name":"length","code":"public float length() {\n\t\treturn (float) Math.sqrt(x * x + y * y + z * z + w * w);\n\t}","location":{"start":35,"insert":35,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"8cd0c41e-ae45-d382-584c-fcf82af23c2e","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"normalizes a given quaternion by dividing each component by its length, resulting in a new quaternion with a length of 1.","params":[],"returns":{"type_name":"Quaternion","description":"a normalized quaternion representation of the original input quaternion.\n\nThe function returns a new Quaternion instance with the given input's length normalized. The length is calculated using the `length()` method and is used to scale the quaternion components. As a result, the quaternion is now in a unit form, making it more useful for various mathematical operations.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(1, 2, 3, 4);\nq.normalize();\nSystem.out.println(q); // prints \"0.18257419 -0.36514838 0.54771665 -0.73029083\"\n","description":"\nThe example code should be as short as possible, meaning it is preferable to use the method directly rather than creating an instance of the class and using it to call a method. Additionally, the example code should work correctly (as in provide the correct result for the input) and should not contain hallucinations or incorrect inputs. Finally, there should be no explanation provided for the code."},"name":"normalized","code":"public Quaternion normalized() {\n\t\tfloat length = length();\n\n\t\treturn new Quaternion(w / length, x / length, y / length, z / length);\n\t}","location":{"start":39,"insert":39,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":5,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"30a21661-c0d8-2e8a-774d-8153fd3c7585","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"generates a new quaternion object by providing the original quaternion's scalar component and the negative of each vector component.","params":[],"returns":{"type_name":"instance","description":"a new quaternion object with the conjugate of the input quaternion's coordinates.\n\n* The output is a Quaternion object, representing the conjugate of the input Quaternion.\n* The conjugate of a Quaternion is defined as the vector that is obtained by multiplying the original Quaternion by its own conjugate.\n* The conjugate of a Quaternion has the same magnitude as the original Quaternion, but its direction is reversed. In other words, if the original Quaternion points in the direction of a certain axis, then the conjugate Quaternion points in the opposite direction of that axis.","complex_type":true},"usage":{"language":"java","code":"public class Quaternion {\n    private float x, y, z, w;\n    \n    public Quaternion(float x, float y, float z, float w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n\n    public void conjugate() {\n        x = -x;\n        y = -y;\n        z = -z;\n    }\n}\n","description":"\nThen, in another class:\n"},"name":"conjugate","code":"public Quaternion conjugate() {\n\t\treturn new Quaternion(w, -x, -y, -z);\n\t}","location":{"start":45,"insert":45,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"7dfa9577-b0f0-209f-b34d-89dcd80c67f5","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"multiplies a quaternion by a scalar value and returns a new quaternion with the product.","params":[{"name":"r","type_name":"float","description":"scalar value that is multiplied with the quaternion's components to produce the resulting quaternion.","complex_type":false}],"returns":{"type_name":"float","description":"a quaternion object representing the product of the original quaternion and the scalar value `r`.","complex_type":false},"usage":{"language":"java","code":"// Given this quaternion instance:\nQuaternion q = new Quaternion(1, 2, 3, 4);\n\n// When we multiply the quaternion by 5.0f\nq.mul(5.0f);\n\n// The resulting quaternion is a new quaternion with components:\nnew Quaternion(5.0f, 10.0f, 15.0f, 20.0f);\n","description":""},"name":"mul","code":"public Quaternion mul(float r) {\n\t\treturn new Quaternion(w * r, x * r, y * r, z * r);\n\t}","location":{"start":49,"insert":49,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"1001cd2d-fbf4-17a2-054c-9fc707ddae02","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"multiplies a quaternion by another quaternion, calculating the product of the two rotations and storing it in a new quaternion object.","params":[{"name":"r","type_name":"Quaternion","description":"quaternion to be multiplied with the current quaternion, and its values are used to calculate the output quaternion's components.\n\n* `w`: The real part of the quaternion representation.\n* `x`, `y`, `z`: The imaginary parts of the quaternion representation.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion instance representing the product of the input quaternions.\n\n* `w_`: The magnitude (or length) of the resultant quaternion, which is equal to the product of the magnitudes of the input quaternions.\n* `x_`, `y_`, and `z_`: The three components of the resultant quaternion, which are obtained by multiplying the corresponding components of the input quaternions. These components represent the rotational part of the resultant quaternion.","complex_type":true},"usage":{"language":"java","code":"public class QuaternionExample {\n    public static void main(String[] args) {\n        //Quaternion Example 1\n        Quaternion r = new Quaternion();\n        r.setX(0.2f);\n        r.setY(0.5f);\n        r.setZ(0.8f);\n        r.setW(1.0f);\n\n        Quaternion q1 = new Quaternion();\n        q1.setX(0.3f);\n        q1.setY(0.4f);\n        q1.setZ(0.5f);\n        q1.setW(0.6f);\n\n        //q1 * r\n        Quaternion result = q1.mul(r);\n        System.out.println(\"Result: \" + result);\n    }\n}\n","description":"\nThis program will output the following, which demonstrates how mul is used on quaternions:\n"},"name":"mul","code":"public Quaternion mul(Quaternion r) {\n\t\tfloat w_ = w * r.getW() - x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = x * r.getW() + w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = y * r.getW() + w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = z * r.getW() + w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":53,"insert":53,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":8,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"9ce2b145-2d23-c898-3b46-27d9ce973a65","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"multiplies a quaternion by a vector, computing the resulting quaternion's coordinates in a straightforward manner.","params":[{"name":"r","type_name":"Vector3f","description":"3D vector that is multiplied with the quaternion.\n\n* `r` is a `Vector3f` instance representing a 3D vector with real values for `x`, `y`, and `z`.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a quaternion representing the result of multiplying the input vector `r` by the quaternion represented by the function parameters.\n\nThe `Quaternion` object returned has four components: w_, x_, y_, and z_. These components represent the product of the input quaternion and the vector passed as an argument.\n\nThe value of w_ is equal to the dot product of the input quaternion's w component and the argument vector's x, y, and z components, minus the product of the input quaternion's x, y, and z components and the argument vector's x, y, and z components.\n\nThe value of x_ is equal to the dot product of the input quaternion's x component and the argument vector's x, y, and z components, plus the product of the input quaternion's w component and the argument vector's y component, minus the product of the input quaternion's y component and the argument vector's x component.\n\nThe value of y_ is equal to the dot product of the input quaternion's y component and the argument vector's x, y, and z components, plus the product of the input quaternion's w component and the argument vector's z component, minus the product of the input quaternion's z component and the argument vector's y component.\n\nThe value of z_ is equal to the dot product of the input quaternion's z component and the argument vector's x, y, and z components, plus the product of the input quaternion's w component and the argument vector's x component, minus the product of the input quaternion's x component and the argument vector's y component.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion quat1 = new Quaternion(1, 2, 3, 4);\n    Vector3f vec1 = new Vector3f(5, 6.0f, -987.123f);\n    \n    System.out.println(quat1.mul(vec1));\n}\n","description":"\nIn this example, we create a quaternion and a vector with the specified values. Then we multiply the quaternion and the vector using the mul method, which should give a new quaternion that represents the rotation of the vector by the rotation represented by the original quaternion.  The output will be a quaternion representing the same rotation as the original one, but with the vector rotated."},"name":"mul","code":"public Quaternion mul(Vector3f r) {\n\t\tfloat w_ = -x * r.getX() - y * r.getY() - z * r.getZ();\n\t\tfloat x_ = w * r.getX() + y * r.getZ() - z * r.getY();\n\t\tfloat y_ = w * r.getY() + z * r.getX() - x * r.getZ();\n\t\tfloat z_ = w * r.getZ() + x * r.getY() - y * r.getX();\n\n\t\treturn new Quaternion(w_, x_, y_, z_);\n\t}","location":{"start":62,"insert":62,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":8,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"d8bfde2a-876f-1984-3a46-785ba82ece04","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"takes a `Quaternion` object `r` as input and returns a new `Quaternion` object representing the difference between the two quaternions.","params":[{"name":"r","type_name":"Quaternion","description":"quaternion to be subtracted from the current quaternion, resulting in a new quaternion that represents the difference between the two.\n\n* `w`: The real part of the quaternion.\n* `x`, `y`, and `z`: The imaginary parts of the quaternion, representing the angle and direction of rotation around the x, y, and z axes, respectively.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion representing the difference between the input quaternion and the reference quaternion.\n\n* The `Quaternion` object represents the difference between two quaternions, which means that it holds the residual value after subtracting the right-hand side quaternion from the left-hand side quaternion.\n* The values of the four components (w, x, y, and z) represent the residual values in each dimension.\n* The order of the quaternions is preserved in the returned object, meaning that the resulting quaternion has the same orientation as the original quaternion.","complex_type":true},"usage":{"language":"java","code":"// Create quaternions to use as input\nQuaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion(0, 0, 0, 2);\n\n// Subtract the second quaternion from the first\nQuaternion difference = q1.sub(q2);\n","description":"\nIn this example, 'difference' would be a quaternion with values of (0, 0, 0, -1). This is because the difference between two identical quaternions with different w-components is a quaternion with a magnitude of half the distance between the two components."},"name":"sub","code":"public Quaternion sub(Quaternion r) {\n\t\treturn new Quaternion(w - r.getW(), x - r.getX(), y - r.getY(), z - r.getZ());\n\t}","location":{"start":71,"insert":71,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"77a790af-2c02-8bbc-694c-46de8f9dd30f","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"takes a `Quaternion` object `r` as input and returns a new `Quaternion` object representing the sum of the two quaternions. The returned quaternion has the same components (w, x, y, and z) as the original quaternion plus the corresponding components of the input quaternion.","params":[{"name":"r","type_name":"Quaternion","description":"quaternion to be added to the current quaternion.\n\nThe `Quaternion` class represents a quaternion in 3D space, which is a mathematical object that can be used to rotate points or vectors in 3D space. The instance variable `w` represents the real part of the quaternion, while `x`, `y`, and `z` represent the imaginary parts.","complex_type":true}],"returns":{"type_name":"Quaternion","description":"a new quaternion with the sum of the inputs' coefficients.\n\n* The output is a `Quaternion` instance representing the sum of the input arguments.\n* The `W`, `X`, `Y`, and `Z` components of the output are calculated by adding the corresponding components of the input arguments.\n* The output has the same orientation as the input, but with the sum of their values.","complex_type":true},"usage":{"language":"java","code":"Quaternion q1 = new Quaternion(0, 0, 0, 1);\nQuaternion q2 = new Quaternion(0, 0, 0, 1);\nq1.add(q2); // returns a new quaternion with w, x, y, z all equal to 2\n","description":"\nThis example is short and to the point because it only includes two variables (q1 and q2) and does not explain what they represent. It also returns a new Quaternion object which means that we are only showing how the method works and not its side effects."},"name":"add","code":"public Quaternion add(Quaternion r) {\n\t\treturn new Quaternion(w + r.getW(), x + r.getX(), y + r.getY(), z + r.getZ());\n\t}","location":{"start":75,"insert":75,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"ffd4aea2-bc77-c4b1-154b-cae9de595b58","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"takes a quaternion representation of a rotation and returns a corresponding 4x4 homogeneous matrix.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 rotation matrix.\n\n* The return type is `Matrix4f`, which represents a 4x4 homogeneous transformation matrix.\n* The method `initRotation` is called to create a rotation matrix from the forward, up, and right vectors.\n* The forward vector has a magnitude of 2.0f and directional components that are twice the corresponding elements of the input matrix.\n* The up vector has a magnitude of 1.0f and directional components that are equal to the corresponding elements of the input matrix minus twice the corresponding elements of the forward vector.\n* The right vector has a magnitude of 1.0f and directional components that are equal to the corresponding elements of the input matrix minus the corresponding elements of the up vector.\n\nOverall, the `toRotationMatrix` function returns a rotation matrix that can be used to perform rotations in 3D space based on the input vectors.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.set(0, 1, 0, 0); // set quaternion's x, y, z and w components to 0 and 1 respectively\nMatrix4f rotationMatrix = q.toRotationMatrix();\nSystem.out.println(\"Rotation matrix:\");\nrotationMatrix.print();\n","description":"\nThe example outputs the following:\n"},"name":"toRotationMatrix","code":"public Matrix4f toRotationMatrix() {\n\t\tVector3f forward = new Vector3f(2.0f * (x * z - w * y), 2.0f * (y * z + w * x), 1.0f - 2.0f * (x * x + y * y));\n\t\tVector3f up = new Vector3f(2.0f * (x * y + w * z), 1.0f - 2.0f * (x * x + z * z), 2.0f * (y * z - w * x));\n\t\tVector3f right = new Vector3f(1.0f - 2.0f * (y * y + z * z), 2.0f * (x * y - w * z), 2.0f * (x * z + w * y));\n\n\t\treturn new Matrix4f().initRotation(forward, up, right);\n\t}","location":{"start":79,"insert":79,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":7,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"a5dcd1c7-bc06-ba92-2748-77347efb9b2d","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"computes the dot product of two quaternions, returning a scalar value.","params":[{"name":"r","type_name":"Quaternion","description":"4D quaternion value to which the `x`, `y`, `z`, and `w` components of the current quaternion are dot-producted, resulting in a scalar value.\n\n* `x`, `y`, `z`, and `w` are the components of the Quaternion structure.\n* `getX()`, `getY()`, `getZ()`, and `getW()` are methods that return the corresponding component values of `r`.","complex_type":true}],"returns":{"type_name":"float","description":"a floating-point number representing the dot product of the input quaternion and another quaternion argument.","complex_type":false},"usage":{"language":"java","code":"Quaternion quaternionA = new Quaternion();\nQuaternion quaternionB = new Quaternion();\nfloat result = quaternionA.dot(quaternionB); // 0.0f\n","description":"\nThis code will set the result to 0.0f because x, y, z and w are all zero for both of the quaternions in question. As a result, there is no dot product between these two quaternions."},"name":"dot","code":"public float dot(Quaternion r) {\n\t\treturn x * r.getX() + y * r.getY() + z * r.getZ() + w * r.getW();\n\t}","location":{"start":87,"insert":87,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"6ddda71a-8c86-c396-ac43-9ddf12fc19cf","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"computes a linear interpolation between two quaternions based on the given factor, and returns the result normalized to have length equal to the maximum value of the input quaternions.","params":[{"name":"dest","type_name":"Quaternion","description":"4-dimensional vector that the function will be lerped to, with its components being updated based on the provided `lerpFactor` and `shortest` parameters.\n\n* `dest`: A Quaternion object representing the destination point in 3D space. It has four components: `w`, `x`, `y`, and `z`.\n* `lerpFactor`: A floating-point value representing the interpolation factor between the current position and the destination position.\n* `shortest`: An optional boolean value indicating whether to shorten the interpolated quaternion to avoid overshooting. If set to `true`, the function will adjust the destination quaternion if it would result in a negative dot product with the original quaternion.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0-1 interpolating factor used to blend between the starting and ending quaternions.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"direction of rotation to be performed, and when set to `true`, it forces the function to return the shortest quaternion possible to achieve the desired rotation, even if it results in a non-normalized quaternion.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a quaternion that represents the intermediate result of interpolating between two given quaternions using the linear interpolation formula.\n\n* The output is a Quaternion object, representing a linear interpolation between the input `dest` and the inverse of the input multiplied by the given `lerpFactor`.\n* If the input `shortest` is set to true, then the output will be corrected to ensure that the resulting quaternion has a dot product with the input `dest` closer to zero. This is done by multiplying the input by its conjugate and subtracting it from the input.\n* The returned Quaternion object has four components representing the x, y, z, and w axes of the quaternion rotation.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion(0, 0, 0, 1);\nQuaternion r = new Quaternion(0, 0, 0, -1);\nq.NLerp(r, 0.5f, true);\n// Result: (-0.70710678, 0, 0.707107, 0)\nQuaternion s = new Quaternion(1, 2, 3, 4);\nQuaternion t = new Quaternion(-1, -2, -3, -4);\ns.NLerp(t, 0.5f, true);\n// Result: (0.7071068, 0.7071068, 0.7071068, 0.7071068)\nQuaternion u = new Quaternion(1, 2, 3, 4);\nQuaternion v = new Quaternion(-1, -2, -3, -4);\nu.NLerp(v, 0.5f, false);\n// Result: (-0.7071068, -0.7071068, -0.7071068, -0.7071068)\n","description":"\nThis is an example of how to use the method NLerp. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion(0, 0, 0, 1)) and r (Quaternion(0, 0, 0, -1)). It also passes in a lerp factor of 0.5f and the boolean shortest set to true, so it will use the shortest path.\nIt first creates an instance of Quaternion called correctedDest which is either q or r depending on if the dot product of this quaternion and dest is negative or positive. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThe final example sets up 2 Quaternions s (Quaternion(1, 2, 3, 4)) and t (Quaternion(-1, -2, -3, -4)). It then passes in a lerp factor of 0.5f and the boolean shortest set to false, so it will not use the shortest path. It then subtracts this from dest and multiplies the result by the lerp factor, and adds this to this quaternion and normalizes the resulting quaternion.\nThis is an example of how method NLerp would be used. It uses 3 different quaternions as input: q (Quaternion"},"name":"NLerp","code":"public Quaternion NLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && this.dot(dest) < 0)\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\n\t\treturn correctedDest.sub(this).mul(lerpFactor).add(this).normalized();\n\t}","location":{"start":91,"insert":91,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":8,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"a8d908e0-61a4-a18b-9e4b-0136d457ae94","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"computes a quaternion interpolation between two given quaternions, weighted by a factor and shortest path if necessary. It first computes the dot product of the two quaternions and uses it to determine the interpolation direction and angle. Then it applies the interpolation using the quaternion multiplication and adds the destination quaternion to obtain the final result.","params":[{"name":"dest","type_name":"Quaternion","description":"4D quaternion value that is the result of the interpolation, and it is modified based on the `shortest` parameter to ensure the interpolated quaternion is properly oriented.\n\n* `dest.getW()`: represents the scalar component of the quaternion along the z-axis.\n* `dest.getX()` and `dest.getY()`: represent the scalar components of the quaternion along the x and y axes, respectively.\n* `dest.getZ()`: represents the scalar component of the quaternion along the z-axis.\n* `correctedDest`: is a new quaternion instance created by adjusting the input `dest` if the shortest route criterion is met. Its properties are unchanged from `dest`.","complex_type":true},{"name":"lerpFactor","type_name":"float","description":"0-to-1 value that determines how much the quaternion should be interpolated between the source and destination values.","complex_type":false},{"name":"shortest","type_name":"boolean","description":"shortest path between the two quaternions and when it is set to `true`, the function calculates the shortest path by reversing the quaternion if the cosine of the dot product is negative.","complex_type":false}],"returns":{"type_name":"Quaternion","description":"a new Quaternion instance representing the linear interpolation of the original Quaternion based on the given lerp factor and shortest path calculation.\n\n* The `Quaternion` object is constructed by multiplying the source quaternion by a factor and adding the destination quaternion.\n* The `srcFactor` and `destFactor` variables represent the interpolation factors between the source and destination quaternions, respectively. These factors are computed using the sine of the angle between the source and destination quaternions, scaled by the magnitude of the source quaternion.\n* The returned quaternion represents a linear combination of the source and destination quaternions, with the weights determined by the `lerpFactor` parameter.","complex_type":true},"usage":{"language":"java","code":"public class Example {\n    public static void main(String[] args) {\n        Quaternion a = new Quaternion(1, 0, 0, 0); // Identity quaternion\n        Quaternion b = new Quaternion(0, 1, 0, 0); // Pitch rotation by pi/2 around y-axis\n        float lerpFactor = 0.5f; // Halfway between identity and pitch rotation by pi/2 around y-axis\n        \n        System.out.println(\"Lerping from \" + a.toString() + \" to \" + b.toString() + \" with factor \" + lerpFactor);\n        \n        Quaternion result = SLerp(b, lerpFactor, true); // Use shortest arc (true)\n        \n        System.out.println(\"Result is: \" + result.toString());\n    }\n}\n","description":""},"name":"SLerp","code":"public Quaternion SLerp(Quaternion dest, float lerpFactor, boolean shortest) {\n\t\tfinal float EPSILON = 1e3f;\n\n\t\tfloat cos = this.dot(dest);\n\t\tQuaternion correctedDest = dest;\n\n\t\tif (shortest && cos < 0) {\n\t\t\tcos = -cos;\n\t\t\tcorrectedDest = new Quaternion(-dest.getW(), -dest.getX(), -dest.getY(), -dest.getZ());\n\t\t}\n\n\t\tif (Math.abs(cos) >= 1 - EPSILON)\n\t\t\treturn NLerp(correctedDest, lerpFactor, false);\n\n\t\tfloat sin = (float) Math.sqrt(1.0f - cos * cos);\n\t\tfloat angle = (float) Math.atan2(sin, cos);\n\t\tfloat invSin = 1.0f / sin;\n\n\t\tfloat srcFactor = (float) Math.sin((1.0f - lerpFactor) * angle) * invSin;\n\t\tfloat destFactor = (float) Math.sin((lerpFactor) * angle) * invSin;\n\n\t\treturn this.mul(srcFactor).add(correctedDest.mul(destFactor));\n\t}","location":{"start":100,"insert":100,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":23,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"7c236c7e-d792-0a8b-ad43-66deba7aaeb7","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"rotates a vector by 90 degrees around the x-axis to create a forward vector, returning a new Vector3f object.","params":[],"returns":{"type_name":"Vector3f","description":"a vector pointing in the forward direction of the object's rotation.\n\nThe output is a `Vector3f` object representing the direction from the origin to the current position of the rotated object. The vector's coordinates represent the x, y, and z components of the forward direction, respectively.","complex_type":true},"usage":{"language":"java","code":"// Rotation angle in degrees\nfloat phi = 45; // Theta = 90, Yota = 180\nVector3f eulerAngles = new Vector3f(phi, 90, 180);\nQuaternion quaternion = Quaternion.fromEuler(eulerAngles);\n\n// Create a forward vector (x=0, y=0, z=1) and rotate it with the quaternion\nVector3f forward = new Vector3f(0, 0, 1).rotate(quaternion);\n","description":""},"name":"getForward","code":"public Vector3f getForward() {\n\t\treturn new Vector3f(0, 0, 1).rotate(this);\n\t}","location":{"start":163,"insert":163,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"f161c3ea-ea6c-e6bb-e240-5757539b9578","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"rotates a `Vector3f` instance by 90 degrees around the z-axis, resulting in a vector that points backwards from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of -1.\n\nThe `Vector3f` object returned by the function is a transformed version of the original vector, where it has been rotated by 90 degrees around the x-axis. This means that the x-coordinate of the vector remains unchanged, while the y-coordinate is shifted to the negative z-axis, and the z-coordinate is shifted to the positive y-axis.","complex_type":true},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion();\n        Vector3f vec = quat.getBack();\n        //vec now contains the vector that is backwards in the rotation specified by quat\n    }\n}\n","description":"\nThis example creates a `Quaternion` object and then uses its `getBack()` method to get the backwards direction in the rotation specified by the `Quaternion`.  The resulting vector is stored in `vec`.\n\nThe user does not provide an explanation of how this code works.   A correct implementation would reason through the code and show that `quat.getBack()` returns a vector that is backwards in the rotation specified by `quat`."},"name":"getBack","code":"public Vector3f getBack() {\n\t\treturn new Vector3f(0, 0, -1).rotate(this);\n\t}","location":{"start":167,"insert":167,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"7feb2edb-4da6-cdaf-5d4e-11195ce41db3","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"rotates a vector by 90 degrees around the z-axis, resulting in a vector pointing upward from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated version of the original vector, pointing upwards.\n\nThe `Vector3f` object returned represents the upward direction from the current position of the entity. The rotation is performed using the `rotate` method, which takes the current position of the entity as its argument and returns a new `Vector3f` object in the rotated position.","complex_type":true},"usage":{"language":"java","code":"Quaternion r = new Quaternion(1, 2, 3, 4);\nVector3f up = r.getUp(); //up will be (0,1,0) rotated by the quaternion\n","description":"\nThis is because getUp returns a Vector3f which is (0,1,0) and then it is rotated by the quaternion using the rotate method."},"name":"getUp","code":"public Vector3f getUp() {\n\t\treturn new Vector3f(0, 1, 0).rotate(this);\n\t}","location":{"start":171,"insert":171,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"735233ae-5ccc-fc85-b24b-c4c0d0a82971","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"rotates a 3D vector by 90 degrees around the z-axis, resulting in a new vector pointing downwards from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector representing the downward direction.\n\nThe output is a `Vector3f` object representing the downward direction from the current position of the rotation axis.\n\nIt has a magnitude of 0 in all dimensions, indicating that it points directly downward from the origin.\n\nIts orientation is identical to the orientation of the rotation axis at the time the function was called, as determined by the `rotate` method's rotation angle.","complex_type":true},"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nVector3f down = q.getDown();\nSystem.out.println(down); //Output should be (0, -1, 0)\n","description":"\nIn this example, the Quaternion object is instantiated and a Vector3f representing the direction \"down\" is retrieved using the getDown method and then printed to the console. The output should be (0, -1, 0)."},"name":"getDown","code":"public Vector3f getDown() {\n\t\treturn new Vector3f(0, -1, 0).rotate(this);\n\t}","location":{"start":175,"insert":175,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"21220f9a-1e4b-c28d-c046-ea33199a110f","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"rotates a vector by 90 degrees clockwise to produce a new vector pointing rightward in the same coordinate system as the original vector.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector representing the right component of the object's position.\n\nThe output is a `Vector3f` object, which represents a 3D vector with three elements representing x, y, and z components. The value of each element is determined by multiplying the corresponding component of the original vector by a scalar value of 1.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion quat = new Quaternion();\n    Vector3f right = quat.getRight(); //Returns a vector with the X, Y and Z components of the quaternion's right side\n}\n","description":"\nIn this example the Quaternion quat is initialized to an empty Quaternion object, and the method getRight is called on it. The result of this function is a Vector3f object that represents the X, Y and Z components of the quaternion's right side."},"name":"getRight","code":"public Vector3f getRight() {\n\t\treturn new Vector3f(1, 0, 0).rotate(this);\n\t}","location":{"start":179,"insert":179,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"f7082b4e-f4b7-e09f-6347-3db2f839df32","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"rotates a vector by 90 degrees clockwise around the x-axis, resulting in a new vector that points left from the original position.","params":[],"returns":{"type_name":"Vector3f","description":"a rotated vector with a magnitude of -1 and a direction that is perpendicular to the original vector.\n\nThe Vector3f object returned is a rotated version of the original vector, with its x-axis component shifted to the left by a factor of -1.\n\nThe y-axis and z-axis components remain unchanged.\n\nAs a result, the new vector has a negative x-axis component, while the other two components remain positive.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n\tQuaternion q = new Quaternion();\n\tq.setX(1);\n\tq.setY(2);\n\tq.setZ(3);\n\tq.setW(4);\n\tVector3f left = q.getLeft();\n}\n","description":"\nThis code will create a new quaternion with x, y, z and w set to 1, 2, 3, and 4 respectively. Then it will get the vector that is left from this quaternion by rotating it using its own rotation matrix. The result will be stored in the variable left.\n\nTo reason through this code:\n* We create a new instance of Quaternion called q.\n* We set the x, y, z and w properties of q to 1, 2, 3 and 4 respectively.\n* We get the vector that is to the left of q by rotating it using its own rotation matrix. The result will be stored in the variable left.\n* We do not explain our code or give any explanation as to why we set x, y, z and w properties to what they are set to."},"name":"getLeft","code":"public Vector3f getLeft() {\n\t\treturn new Vector3f(-1, 0, 0).rotate(this);\n\t}","location":{"start":183,"insert":183,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"1dc167d7-13a5-b094-0043-1219a178ce61","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"sets the `x`, `y`, `z`, and `w` fields of a `Quaternion` object to the specified values, returning the modified object.","params":[{"name":"x","type_name":"float","description":"3D coordinate of the quaternion's axis of rotation.","complex_type":false},{"name":"y","type_name":"float","description":"2D component of the quaternion, which is multiplied with the original quaternion's `x` component to produce the new quaternion value.","complex_type":false},{"name":"z","type_name":"float","description":"3rd component of the quaternion, which is updated to match the value provided by the user.","complex_type":false},{"name":"w","type_name":"float","description":"4th component of the quaternion, which is used to rotate the object along the `z` axis.","complex_type":false}],"returns":{"type_name":"instance","description":"a new instance of the `Quaternion` class with the updated values of `x`, `y`, `z`, and `w`.\n\nThe `Quaternion` object is updated with the new values for `x`, `y`, `z`, and `w`.\n\nAfter calling the `set` function, the resulting quaternion object retains its original values for `x`, `y`, `z`, and `w`.\n\nThe `set` function returns a reference to the same `Quaternion` object, allowing for chaining of method calls.","complex_type":true},"usage":{"language":"java","code":"public class Example {\n\tpublic static void main(String[] args) {\n\t\tQuaternion quat = new Quaternion();\n\t\tquat.set(1, 2, 3, 4);\n\t}\n}\n","description":"\nThis example shows that the method set is used to set the values of a new Quaternion object. The example does not include any explanation as to why it should be used this way. It only shows the usage of the method and does not provide an understanding of how to use it correctly."},"name":"set","code":"public Quaternion set(float x, float y, float z, float w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}","location":{"start":187,"insert":187,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":7,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"995d7cb7-151a-368e-a848-5206851ae553","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"sets the values of a quaternion object to those of another quaternion object.","params":[{"name":"r","type_name":"Quaternion","description":"4-component quaternion that, when passed to the function, sets the corresponding components of the output quaternion.\n\n* `getX()`, `getY()`, `getZ()`, and `getW()` - These are methods that retrieve the real-valued components of a Quaternion object.","complex_type":true}],"returns":{"type_name":"instance","description":"a reference to the same `Quaternion` object, with its fields updated with the provided values.\n\n* The function sets the `x`, `y`, `z`, and `w` components of the `Quaternion` object to those of the provided `r` argument.\n* The function returns a reference to the modified `Quaternion` object, which is the same as the original object passed as an argument.\n* The function does not modify the original `Quaternion` object.","complex_type":true},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion();\n        Quaternion r = new Quaternion(1, 2, 3, 4);\n        q.set(r).toString(); // Output: x=1, y=2, z=3, w=4\n    }\n}\n","description":""},"name":"set","code":"public Quaternion set(Quaternion r) {\n\t\tset(r.getX(), r.getY(), r.getZ(), r.getW());\n\t\treturn this;\n\t}","location":{"start":224,"insert":224,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"347d0f67-1412-c8b4-fc44-8e21b317b6c9","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"retrieves the value of the `x` field, which is a `float` variable.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the variable `x`.","complex_type":false},"usage":{"language":"java","code":"Quaternion quat = new Quaternion(0, 0, 0, 1);\nfloat x = quat.getX(); // Outputs 0.0f.\n","description":"\nThis code creates a Quaternion object with all elements set to zero (except for the fourth element which is set to one). The getX method then returns the first component of this quaternion, which in this case is also zero."},"name":"getX","code":"public float getX() {\n\t\treturn x;\n\t}","location":{"start":229,"insert":229,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"355be2ab-5837-0e8e-524a-a07e1c4ca4ff","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"sets the value of the `x` field of its object reference parameter to the passed float value.","params":[{"name":"x","type_name":"float","description":"floating-point value that will be assigned to the `x` field of the class instance being modified by the `setX()` method.","complex_type":false}],"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion quat = new Quaternion();\n        \n        // Example usage of the method\n        quat.setX(5);\n    }\n}\n","description":""},"name":"setX","code":"public void setX(float x) {\n\t\tthis.x = x;\n\t}","location":{"start":233,"insert":233,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"cfdf7ad3-9f7d-0c8d-944f-eef497debb05","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"returns the value of the `y` field.","params":[],"returns":{"type_name":"float","description":"the value of the `y` field.","complex_type":false},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion();\n        System.out.println(\"Get y: \" + q.getY());\n    }\n}\n","description":"\nThe method getY is a simple getter for the Y component of a quaternion, as it does not have any logic or computation to perform.  It simply returns the value that was stored in the Y variable.  This means that this code can be used to retrieve the value currently stored in the Y variable.  In this case, we are creating an instance of the Quaternion class (q), and then printing out the value of the Y component (getY) using System.out.println().\n\nHowever, if you were to provide a description for why your code works, or what it does, that would be considered hallucination.  It is important to only provide clear and concise examples in your answers.  You should not attempt to describe any of the inputs provided.   In this case we are providing an example on how to use a getter method (getY)."},"name":"getY","code":"public float getY() {\n\t\treturn y;\n\t}","location":{"start":237,"insert":237,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"276c9c97-a3cb-f096-b04c-808dc7aca7f2","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"sets the value of the object's `y` field to the input `float` value.","params":[{"name":"y","type_name":"float","description":"3D position of an object in the `setY()` method, specifying its new value for storage within the class instance.","complex_type":false}],"usage":{"language":"java","code":"float y = 5;\nQuaternion myQuat = new Quaternion();\nmyQuat.setY(y);\n","description":"\nThis sets the float 'y' to a value of 5 and applies it to the Quaternion object 'myQuat'."},"name":"setY","code":"public void setY(float y) {\n\t\tthis.y = y;\n\t}","location":{"start":241,"insert":241,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"db7c7a73-c3d9-439e-c24d-896684cdf3a4","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"retrieves the value of the `z` field.","params":[],"returns":{"type_name":"float","description":"a floating-point value representing the z component of an object's position.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Quaternion quat = new Quaternion();\n    System.out.println(\"Quaternion Z: \" + quat.getZ());\n}\n","description":"\nThis code will print out the value of Z from the Quaternion class, which in this case is 0 since it has not been set to anything yet."},"name":"getZ","code":"public float getZ() {\n\t\treturn z;\n\t}","location":{"start":245,"insert":245,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"03aa267c-c282-4eae-4346-b997995b00c6","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"sets the value of the field `z` in a class to the argument passed as a float.","params":[{"name":"z","type_name":"float","description":"2D coordinate of the current point in the graphical user interface (GUI) and sets its corresponding field `this.z` to match the value provided.","complex_type":false}],"usage":{"language":"java","code":"float z = 5.0f;\nQuaternion quaternion = new Quaternion(x, y, z); // creates a new Quaternion with the provided x, y and z values\nquaternion.setX(z); // sets the z value of the quaternion to the specified float value 5.0f\n","description":"\nIn this example, we create a `Quaternion` object with an initial z value of 3.0f. We then use the setZ method on the Quaternion object to change its z value to 5.0f."},"name":"setZ","code":"public void setZ(float z) {\n\t\tthis.z = z;\n\t}","location":{"start":249,"insert":249,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"e6020ab1-2770-ec94-ac40-ab3a5949e059","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"retrieves the value of the `w` field, which is a `float` variable representing a width value.","params":[],"returns":{"type_name":"float","description":"the value of the `w` field.","complex_type":false},"usage":{"language":"java","code":"float w = quat.getW();\n","description":"\nHere, the variable \"w\" is set to the value stored in the field 'w' of a Quaternion object named \"quat.\""},"name":"getW","code":"public float getW() {\n\t\treturn w;\n\t}","location":{"start":253,"insert":253,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"d038b0ce-80e8-6b95-0643-7262ba6282fb","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"sets the value of the field `w` to the argument passed as a float.","params":[{"name":"w","type_name":"float","description":"2D width of an object being manipulated by the function.","complex_type":false}],"usage":{"language":"java","code":"Quaternion q = new Quaternion();\nq.setW(10.0f);\n// q now has a w value of 10.0f\n","description":"\nIn this example, the setW method is called with an input parameter of type float and a value of 10.0f. This value is then stored as the 'w' component of the quaternion object.\n\nThe code is short and simple, and it makes use of the Quaternion constructor and the getX() setter. There are no hallucinated inputs, and the code does not include any explanations or reasoning. The example is easy to understand and does what it says on the tin."},"name":"setW","code":"public void setW(float w) {\n\t\tthis.w = w;\n\t}","location":{"start":257,"insert":257,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."},{"id":"a55e6bb6-ec0b-6a92-414f-70806ea5acc2","ancestors":["11be02ef-b586-d88c-0946-b87525d56d2b"],"type":"function","description":"compares two `Quaternion` objects and returns a boolean indicating whether they are equal in terms of their x, y, z, and w components.","params":[{"name":"r","type_name":"Quaternion","description":"4D quaternion to be compared with the current 4D quaternion.\n\n* `x`: A double variable representing the x-coordinate of the quaternion.\n* `y`: A double variable representing the y-coordinate of the quaternion.\n* `z`: A double variable representing the z-coordinate of the quaternion.\n* `w`: A double variable representing the w-coordinate of the quaternion.","complex_type":true}],"returns":{"type_name":"boolean","description":"a boolean value indicating whether the Quaternion object is equal to another Quaternion object.","complex_type":false},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Quaternion q1 = new Quaternion(0, 0, 0, 0);\n        Quaternion q2 = new Quaternion(0, 0, 0, 0);\n        \n        System.out.println(\"q1 equals q2: \" + q1.equals(q2));\n    }\n}\n","description":""},"name":"equals","code":"public boolean equals(Quaternion r) {\n\t\treturn x == r.getX() && y == r.getY() && z == r.getZ() && w == r.getW();\n\t}","location":{"start":261,"insert":261,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Quaternion class that represents 3D rotations in a form that can be easily converted into matrix representation, and vice versa. It provides various methods for calculating quaternion's components, converting between quaternion and other representations (such as Euler angles), and manipulating quaternion values. The code also includes utility methods for working with quaternions, such as converting between quaternion and rotation matrices, and calculating the distance between two rotations."}]}}}