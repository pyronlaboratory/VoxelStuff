{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"","diagram":"digraph G {\n    label=\"com.ch.math.Matrix4f\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        Chunk\n    }\n    subgraph cluster_1 {\n        label=\"math\"\n        color=\"#33363A\"\n        Vector3f\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Matrix4f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Quaternion\n    }\n    Camera\n    Shader\n    Transform\n    Camera3D\n    CameraStruct\n    Chunk -> Matrix4f \n    Transform -> Matrix4f \n    Matrix4f -> Matrix4f [style=\"dashed\"]\n    Quaternion -> Matrix4f \n    Matrix4f -> Shader \n    Vector3f -> Matrix4f \n    Matrix4f -> Matrix4f \n    Camera3D -> Matrix4f \n    Vector3f -> Matrix4f [style=\"dashed\"]\n    CameraStruct -> Matrix4f [style=\"dashed\"]\n    Camera -> Matrix4f \n}\n","items":[{"id":"bb0d8f02-0948-4ded-b03e-5420554c785c","ancestors":[],"type":"function","name":"initTranslation","location":{"offset":"\t","indent":1,"insert":52,"start":77},"returns":"Matrix4f","params":[{"name":"x","type":"float"},{"name":"y","type":"float"},{"name":"z","type":"float"}],"code":"public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"docLength":25,"length":21,"comment":{"description":"Initializes a matrix with translation values for x, y, and z coordinates. It modifies the matrix elements to represent the translation vectors and returns the modified matrix reference.","params":[{"name":"x","type":"float","description":"3D translation amount in the x-axis direction."},{"name":"y","type":"float","description":"2D translation component in the returned matrix, where it is assigned to the value of `data[1][1]`."},{"name":"z","type":"float","description":"3rd coordinate of the translation vector and is used to set the z-component of the resulting matrix."}],"returns":{"type":"Matrix4f","description":"a modified Matrix4f object with translated coordinates."}}},{"id":"cbb03b61-cce4-4155-8256-e54d0aec5f70","ancestors":[],"type":"function","name":"initRotation","location":{"offset":"\t","indent":1,"insert":99,"start":130},"returns":"Matrix4f","params":[{"name":"x","type":"float"},{"name":"y","type":"float"},{"name":"z","type":"float"}],"code":"public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}","skip":false,"docLength":31,"length":64,"comment":{"description":"Generates a rotation matrix based on three Euler angles (x, y, and z) using the Rodrigues formula. It returns a Matrix4f object representing the rotation.","params":[{"name":"x","type":"float","description":"3D rotation around the x-axis."},{"name":"y","type":"float","description":"2D rotation angle around the y-axis, which is used to compute the rotation matrix for the x and z axes."},{"name":"z","type":"float","description":"3D rotation axis around which the matrix will be rotated, and its value is used to calculate the cosine and sine of the angle of rotation in radians, which are then applied to the creation of the rotation matrix."}],"returns":{"type":"Matrix4f","description":"a new Matrix4f object representing the rotation matrix."}}},{"id":"f54fbf9f-4673-430b-88d7-f3d1744b7ad7","ancestors":[],"type":"function","name":"initScale","location":{"offset":"\t","indent":1,"insert":194,"start":219},"returns":"Matrix4f","params":[{"name":"x","type":"float"},{"name":"y","type":"float"},{"name":"z","type":"float"}],"code":"public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"docLength":25,"length":20,"comment":{"description":"Sets the scale factor for a matrix, assigning values to the respective elements in the data array.","params":[{"name":"x","type":"float","description":"3D scale factor for the X-axis of the matrix."},{"name":"y","type":"float","description":"2nd element of the scaling factor for the matrix, which is applied to the rows of the matrix."},{"name":"z","type":"float","description":"3rd element of the scaling matrix and sets its value to the input parameter, which is used to scale the 3D coordinates of the object being transformed."}],"returns":{"type":"Matrix4f","description":"a modified instance of the `Matrix4f` class."}}},{"id":"0ea127f7-147e-4cd8-acc5-a68e98e975e7","ancestors":[],"type":"function","name":"initPerspective","location":{"offset":"\t","indent":1,"insert":239,"start":274},"returns":"Matrix4f","params":[{"name":"fov","type":"float"},{"name":"aspectRatio","type":"float"},{"name":"zNear","type":"float"},{"name":"zFar","type":"float"}],"code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}","skip":false,"docLength":35,"length":23,"comment":{"description":"Initializes a matrix for a perspective projection, where the view frustum is defined by the field of view (fov), aspect ratio, and near and far distances.","params":[{"name":"fov","type":"float","description":"field of view (FOV) of the perspective projection, which determines the angular range of vision visible in the generated matrix."},{"name":"aspectRatio","type":"float","description":"2D aspect ratio of the view frustum, which determines the shape of the perspective projection and affects the field of view."},{"name":"zNear","type":"float","description":"near plane distance in the perspective projection matrix, which determines how far the image appears to be from the viewer."},{"name":"zFar","type":"float","description":"4th coordinate of the perspective matrix and sets the distance from the eye point to the farthest point in the image, which is used in calculation of the Z-range."}],"returns":{"type":"Matrix4f","description":"a `Matrix4f` object with pre-multiplied values for perspective projection."}}},{"id":"01c7c0ea-6644-4933-8a1e-a66758640b61","ancestors":[],"type":"function","name":"initOrthographic","location":{"offset":"\t","indent":1,"insert":298,"start":335},"returns":"Matrix4f","params":[{"name":"left","type":"float"},{"name":"right","type":"float"},{"name":"bottom","type":"float"},{"name":"top","type":"float"},{"name":"near","type":"float"},{"name":"far","type":"float"}],"code":"public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"docLength":37,"length":24,"comment":{"description":"Sets up a 4x4 matrix representing an orthographic projection, with the specified parameters determining the size and orientation of the projection.","params":[{"name":"left","type":"float","description":"left edge of the orthographic projection."},{"name":"right","type":"float","description":"right edge of the orthographic projection, which is used to calculate the values for the matrix's data elements."},{"name":"bottom","type":"float","description":"2D coordinate of the bottom-left corner of the orthographic projection, which is used to calculate the height of the projection."},{"name":"top","type":"float","description":"2D coordinate of the top edge of the orthographic projection, which is used to calculate the corresponding 3D coordinate in the matrix."},{"name":"near","type":"float","description":"near plane of the orthographic projection, and it determines the distance from the viewer to the near side of the projection."},{"name":"far","type":"float","description":"3D distance from the viewer to the near end of the orthographic projection, and it is used to calculate the depth aspect of the projected matrix."}],"returns":{"type":"Matrix4f","description":"a `Matrix4f` object with the necessary transformation values for orthographic projection."}}},{"id":"618345fa-681f-469e-90e4-6179a418d617","ancestors":[],"type":"function","name":"initRotation","location":{"offset":"\t","indent":1,"insert":360,"start":402},"returns":"Matrix4f","params":[{"name":"forward","type":"Vector3f"},{"name":"up","type":"Vector3f"}],"code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}","skip":false,"docLength":42,"length":10,"comment":{"description":"Generates a rotation matrix from three vectors: `forward`, `up`, and `r`. The resulting matrix rotates an object around its `forward` axis while maintaining its orientation relative to the `up` axis.","params":[{"name":"forward","type":"Vector3f","description":"3D direction that the rotation will be applied to."},{"name":"up","type":"Vector3f","description":"2D plane that defines the rotation axis, which is used to create a rotation matrix that aligns with the given 3D vector."}],"returns":{"type":"Matrix4f","description":"a Matrix4f object representing a rotation matrix based on the given vector inputs."}}},{"id":"876798a0-2dbe-4bd1-bee2-e8bb8f096160","ancestors":[],"type":"function","name":"initRotation","location":{"offset":"\t","indent":1,"insert":413,"start":459},"returns":"Matrix4f","params":[{"name":"forward","type":"Vector3f"},{"name":"up","type":"Vector3f"},{"name":"right","type":"Vector3f"}],"code":"public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","skip":false,"docLength":46,"length":24,"comment":{"description":"Sets up a rotation matrix based on three input vectors representing the x, y, and z components of the rightward, upward, and forward directions. The resulting matrix is returned.","params":[{"name":"forward","type":"Vector3f","description":"3D vector that points in the direction of rotation, which is used to initialize the X component of the rotation matrix."},{"name":"up","type":"Vector3f","description":"3D unit vector pointing upwards, which is used to initialize the rotation matrix's third column."},{"name":"right","type":"Vector3f","description":"3D right vector of the rotation, which is used to construct the rotation matrix."}],"returns":{"type":"Matrix4f","description":"a `Matrix4f` object representing a rotation matrix based on the provided vectors."}}},{"id":"5c31b9e2-cec4-4f75-98d4-c41fd7c0bb0d","ancestors":[],"type":"function","name":"transform","location":{"offset":"\t","indent":1,"insert":484,"start":516},"returns":"Vector3f","params":[{"name":"r","type":"Vector3f"}],"code":"public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}","skip":false,"docLength":32,"length":4,"comment":{"description":"Takes a `Vector3f` argument `r` and returns a new `Vector3f` object with transformed coordinates based on a set of coefficients `data`.","params":[{"name":"r","type":"Vector3f","description":"3D vector that transforms the output of the `transform()` function."}],"returns":{"type":"Vector3f","description":"a new vector with the result of multiplying each element of the input vector `r` by the corresponding elements of a given matrix `data`, and adding the resulting values."}}},{"id":"d60603d9-b55b-4e9c-8595-7ae178602758","ancestors":[],"type":"function","name":"mul","location":{"offset":"\t","indent":1,"insert":522,"start":542},"returns":"Matrix4f","params":[{"name":"r","type":"Matrix4f"}],"code":"public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}","skip":false,"docLength":20,"length":11,"comment":{"description":"Takes a second matrix `r` as input and multiplies it element-wise with the current matrix, storing the result in the current matrix.","params":[{"name":"r","type":"Matrix4f","description":"4x4 matrix to be multiplied with the current matrix, resulting in the updated matrix."}],"returns":{"type":"Matrix4f","description":"a matrix with the product of the input matrices element-wise."}}},{"id":"1a946a0d-f594-47e8-bf7f-6da0c0e51095","ancestors":[],"type":"function","name":"get","location":{"offset":"\t","indent":1,"insert":597,"start":608},"returns":"float","params":[{"name":"x","type":"int"},{"name":"y","type":"int"}],"code":"public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}","skip":false,"docLength":11,"length":3,"comment":{"description":"Returns the value stored at a specific position in an array, given the coordinates `x` and `y`.","params":[{"name":"x","type":"int","description":"1D position of a pixel in the image data within the range of [0, dimensions-1]."},{"name":"y","type":"int","description":"2nd dimension of the data array that is being accessed by the function."}],"returns":{"type":"float","description":"a floating-point value representing the value at the specified position in the 2D array `data`."}}},{"id":"0be49c8c-e487-45b2-9df5-ccd0b163d002","ancestors":[],"type":"function","name":"SetM","location":{"offset":"\t","indent":1,"insert":611,"start":624},"returns":false,"params":[{"name":"data","type":"float[][]"}],"code":"public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}","skip":false,"docLength":13,"length":3,"comment":{"description":"Sets the value of the object's `data` field to the input parameter `data`.","params":[{"name":"data","type":"float[][]","description":"2D array of float values that will be stored in the class instance variable `data`."}],"returns":null}},{"id":"a5bb54a7-f6bc-400c-8047-0c8f31f47e5e","ancestors":[],"type":"function","name":"set","location":{"offset":"\t","indent":1,"insert":627,"start":638},"returns":false,"params":[{"name":"x","type":"int"},{"name":"y","type":"int"},{"name":"value","type":"float"}],"code":"public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}","skip":false,"docLength":11,"length":3,"comment":{"description":"Sets a value at a specific coordinate within an array of integers.","params":[{"name":"x","type":"int","description":"0-based index of a pixel in the grid, which is used to determine the specific location within the grid where the `value` parameter is assigned."},{"name":"y","type":"int","description":"2nd dimension of the data array being manipulated, and it corresponds to the vertical position of the cell being updated with the provided value."},{"name":"value","type":"float","description":"3D point value that is assigned to the corresponding position in the `data` array."}],"returns":null}}]}}}