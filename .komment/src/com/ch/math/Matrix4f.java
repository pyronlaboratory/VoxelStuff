{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix.","diagram":"digraph G {\n    label=\"com.todo.FixMe\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Vector3f\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Matrix4f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n        Quaternion\n    }\n    subgraph cluster_1 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Chunk\n    }\n    edge [color=\"#26de81\"]\n    Transform -> Matrix4f \n    Vector3f -> Matrix4f [style=\"dashed\"]\n    CameraStruct -> Matrix4f [style=\"dashed\"]\n    Camera3D -> Matrix4f \n    Camera -> Matrix4f \n    Quaternion -> Matrix4f \n    Matrix4f -> Shader \n    Chunk -> Matrix4f \n    Matrix4f -> Matrix4f \n    Vector3f -> Matrix4f \n    Matrix4f -> Matrix4f [style=\"dashed\"]\n}\n","items":[{"id":"3da3c465-2e9d-4e91-b447-ed21cf0d4f83","ancestors":[],"type":"function","description":"represents a 4x4 matrix of floats and provides methods for initializing rotation matrices, transforming vectors, multiplying matrices, and getting the linear data. It also has getters and setters for the individual elements of the matrix.","name":"Matrix4f","code":"public class Matrix4f {\n\t\n\tprivate float[][] data;\n\n\tpublic Matrix4f() {\n\t\tdata = new float[4][4];\n\t}\n\n\tpublic Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}\n\n\tpublic Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}\n\t\n\tpublic float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}\n\n\tpublic float get(int x, int y) {\n\t\treturn data[x][y];\n\t}\n\n\tpublic void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}\n\n\tpublic void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}\n\t\n}","location":{"start":3,"insert":3,"offset":" ","indent":0,"comment":null},"item_type":"class","length":291,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"d44542ae-1570-728e-5643-ab742a442a51","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"initializes a matrix with all elements set to identity values, i.e., rows and columns are identical and have the same value as the diagonal element.","params":[],"returns":{"type_name":"Matrix4f","description":"a Matrix4f object with all elements set to zero, except for the identity matrix.\n\nThe `Matrix4f` object returned by the function is the same instance as the original one.\n\nThe data array of the matrix is initialized with values that satisfy the identity condition, where each element is either 0 or 1. Specifically, the elements at positions (0,0), (0,1), (1,0), and (1,1) are set to 1, while all other elements are set to 0.\n\nThe resulting matrix has the following properties:\n\n* It is an identity matrix, meaning that it preserves the identity of any vector applied to it.\n* Its determinant is equal to 1, which means that it has a unique inverse.\n* It is orthogonally diagonal, meaning that its diagonal elements are all non-zero and the off-diagonal elements are all zero.\n\nOverall, the `initIdentity` function is used to initialize a matrix to an identity matrix, which is commonly used in various mathematical operations and applications.","complex_type":true},"usage":{"language":"java","code":"Matrix4f matrix = new Matrix4f();\nmatrix.initIdentity();\n","description":"\nThis will initialize the identity matrix in a 4x4 array data, with all of the values being either 0 or 1."},"name":"initIdentity","code":"public Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":11,"insert":11,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"15338d25-d3b8-c5b0-d742-7f0bc7f5d408","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"sets the translation components (x, y, z) for a matrix, using the negative of the input x value to create the y component and setting each element of the matrix accordingly. It returns the modified matrix.","params":[{"name":"x","type_name":"float","description":"3D translation along the x-axis in the returned matrix.","complex_type":false},{"name":"y","type_name":"float","description":"2D translation along the y-axis, where positive values shift the translation upwards and negative values shift it downwards.","complex_type":false},{"name":"z","type_name":"float","description":"3rd dimension of the translation vector, which is added to the corresponding element in the matrix's data array.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix object, unchanged.\n\n* The `Matrix4f` object is returned as the output.\n* The data array of the matrix is modified to set the elements according to the input parameters `x`, `y`, and `z`.\n* The elements of the matrix are arranged in a 4x4 grid, with each element representing a point in 3D space.\n* The elements of the matrix are set to either 0 or 1, depending on whether they represent a translation along the x, y, or z axis, respectively.\n\nIn summary, the `initTranslation` function modifies a 4x4 matrix to represent a translation in 3D space, based on the input parameters `x`, `y`, and `z`.","complex_type":true},"usage":{"language":"java","code":"Matrix4f translation = new Matrix4f();\ntranslation.initTranslation(0, 0, -5);\n","description":"\nThis creates a matrix that translates everything 5 units in the z-axis."},"name":"initTranslation","code":"public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":32,"insert":32,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":21,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"3784589d-e218-f3a5-aa47-2e93f3551ce3","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"creates a rotation matrix based on three Euler angles (`x`, `y`, and `z`) using the Rodrigues formula. It returns a Matrix4f object representing the rotation.","params":[{"name":"x","type_name":"float","description":"3D rotation around the x-axis and is used to calculate the rotation matrix rx.","complex_type":false},{"name":"y","type_name":"float","description":"2D rotation angle around the x-axis and is used to compute the rotation matrix for the z-axis.","complex_type":false},{"name":"z","type_name":"float","description":"3D rotation axis around which the matrix is rotated, and it is used to calculate the rotation matrix `rz`.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a new Matrix4f object representing the rotation matrix.\n\n* The `data` field is an instance of the `Matrix4f` class, representing a 4x4 matrix.\n* The elements of the matrix are computed using the cosine and sine functions of the input angles (x, y, z) in radians.\n* The matrix has the following properties:\n\t+ The first column represents the rotation around the x-axis.\n\t+ The second column represents the rotation around the y-axis.\n\t+ The third column represents the rotation around the z-axis.\n\t+ The fourth column represents the translation component.\n* The matrix is computed using the following formulas:\n\t+ rx.data[0][0] = 1;\n\t+ rx.data[0][1] = 0;\n\t+ rx.data[0][2] = 0;\n\t+ rx.data[0][3] = 0;\n\t+ rx.data[1][0] = 0;\n\t+ rx.data[1][1] = Math.cos(z);\n\t+ rx.data[1][2] = -Math.sin(z);\n\t+ rx.data[1][3] = 0;\n\t+ rx.data[2][0] = 0;\n\t+ rx.data[2][1] = Math.sin(z);\n\t+ rx.data[2][2] = Math.cos(z);\n\t+ rx.data[2][3] = 0;\n\t+ rx.data[3][0] = 0;\n\t+ rx.data[3][1] = 0;\n\t+ rx.data[3][2] = 0;\n\t+ rx.data[3][3] = 1;\n* The `ry` and `rz` matrices are computed using the same formulas as the `rx` matrix, but with different inputs (y and z, respectively).\n* The `data` field is an instance of the `Matrix4f` class, representing a 4x4 matrix.\n* The `getData()` method returns a copy of the internal data array, which can be used to access the individual elements of the matrix.","complex_type":true},"usage":{"language":"java","code":"// Create a new Matrix4f and initialize it to the identity matrix\nMatrix4f rot = new Matrix4f();\n\n// Set the rotation of the Matrix4f to 30, -10, and 45 degrees\nrot.initRotation(30, -10, 45);\n","description":"\nThis code creates a new Matrix4f object called 'rot' and sets its values to the identity matrix before rotating it with the initRotation method with x, y, and z being 30, -10, and 45 degrees respectively."},"name":"initRotation","code":"public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}","location":{"start":54,"insert":54,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":64,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"cf039377-832c-3992-e342-4e58b3182a39","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"initializes a matrix with scaled values for each element, allowing for uniform scaling of a 3D transformation matrix.","params":[{"name":"x","type_name":"float","description":"4th component of the scaling factor applied to the matrix.","complex_type":false},{"name":"y","type_name":"float","description":"2D scaling factor for the x-axis of the matrix when initializing a new instance of the `Matrix4f` class.","complex_type":false},{"name":"z","type_name":"float","description":"2nd dimension of the scaling factor for the matrix, which is applied to the matrix's elements in the returned object.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix object.\n\nThe returned object is an instance of the `Matrix4f` class, representing a 4x4 homogeneous transformation matrix.\n\nThe elements of the matrix are initialized to the input values provided in the constructor. Specifically, the elements of the first column (data[0]) represent the x-scale factor, the second column (data[1]) represents the y-scale factor, and the third column (data[2]) represents the z-scale factor. The fourth column (data[3]) represents the overall scale factor.\n\nThe `initScale` function returns a reference to the modified matrix object, indicating that the original matrix is unchanged.","complex_type":true},"usage":{"language":"java","code":"Matrix4f mat = new Matrix4f().initScale(2, 3, 4);\n","description":"\nThis method is being initialized by the user inputting values for x, y, and z. The data array is then set to represent a scale matrix with those dimensions."},"name":"initScale","code":"public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":119,"insert":119,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"e682f243-0180-8d8f-0f44-c856b4e4a22a","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"initializes a matrix for perspective projection, where fov is field of view, aspectRatio is aspect ratio, zNear is near clipping plane, and zFar is far clipping plane. It sets the elements of the matrix to achieve the desired perspective projection.","params":[{"name":"fov","type_name":"float","description":"field of view (FOV) of the matrix, which determines the angle of the visual cone that the matrix projects.","complex_type":false},{"name":"aspectRatio","type_name":"float","description":"2D screen aspect ratio of the viewport, which is used to calculate the perspective projection matrix's front-to-back and left-to-right scaling factors.","complex_type":false},{"name":"zNear","type_name":"float","description":"near plane of the perspective projection, which determines the position of objects in the near field of view.","complex_type":false},{"name":"zFar","type_name":"float","description":"3D distance from the camera to the near plane of the perspective projection, which determines the field of view and the aspect ratio of the resulting image.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a matrix representing the viewprojection transformation for a perspective projection, with fields for the position, scale, and orientation of the camera.\n\n* `data`: This is an array of 16 float values, representing the elements of a matrix. The dimensions of the matrix are not explicitly stated in the function signature, but it can be inferred that the matrix has four columns and twelve rows (representing a 3D transformation matrix).\n* `tanHalfFOV`: This is a value computed from the fov parameter passed to the function. It represents the tan of half of the field of view in radians.\n* `zNear`: This is a value passed to the function, representing the near plane of the perspective transformation.\n* `zFar`: This is also a value passed to the function, representing the far plane of the perspective transformation.\n* `aspectRatio`: This is a value passed to the function, representing the aspect ratio of the viewport.\n\nThe output of the `initPerspective` function can be used to initialize a Matrix4f object, which can then be used for various purposes such as 3D transformations, projections, and viewports.","complex_type":true},"usage":{"language":"java","code":"float fov = 90f; // Field of view\nfloat aspectRatio = 16f / 9f; // Aspect ratio\nfloat zNear = 0.1f; // Near clipping plane\nfloat zFar = 100f; // Far clipping plane\nMatrix4f mat = new Matrix4f();\nmat.initPerspective(fov, aspectRatio, zNear, zFar);\n","description":"\nIn this example, fov is the field of view (in degrees), aspectRatio is the aspect ratio of the screen, zNear is the near clipping plane and zFar is the far clipping plane. The initPerspective method will return a matrix4f object that can be used for projection calculations in a 3D rendering pipeline."},"name":"initPerspective","code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}","location":{"start":140,"insert":140,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":23,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"73f887e4-25fd-16a3-d74b-7d5ca0314001","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"initializes an orthographic projection matrix with given dimensions and aspect ratio. It sets the appropriate elements of the matrix based on the input parameters, and returns the modified matrix.","params":[{"name":"left","type_name":"float","description":"left value of the orthographic projection, which determines the scale factor for the x-axis in the returned matrix.","complex_type":false},{"name":"right","type_name":"float","description":"right side of the orthographic projection and is used to calculate the width of the projection.","complex_type":false},{"name":"bottom","type_name":"float","description":"2D coordinate of the bottom-left corner of the orthographic projection, which is used to determine the scale and orientation of the projection.","complex_type":false},{"name":"top","type_name":"float","description":"2D coordinate of the top-left corner of the orthographic projection, which is used to determine the scale factor for the vertical dimension of the projection.","complex_type":false},{"name":"near","type_name":"float","description":"3D coordinate at which the orthographic projection is centered, and it determines the near plane of the projection.","complex_type":false},{"name":"far","type_name":"float","description":"4th coordinate of the resulting matrix, which is the distance from the origin along the Z-axis.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the same matrix object.\n\n* `data`: An array of 16 float values that represent the components of a 4x4 orthographic transformation matrix.\n* Each element of `data` is computed based on the input parameters, including `left`, `right`, `bottom`, `top`, `near`, and `far`.\n* The matrix elements are normalized to ensure orthogonality and proper scaling.\n* The returned output is a reference to the same matrix object, allowing for efficient chaining of method calls.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n    // 2D screen dimensions\n    float width = 1080;\n    float height = 720;\n\n    // Orthographic projection settings\n    float left = -width / 2f;\n    float right = width / 2f;\n    float bottom = -height / 2f;\n    float top = height / 2f;\n    float near = 1.0f;\n    float far = 100.0f;\n\n    Matrix4f orthoProj = new Matrix4f();\n    orthoProj.initOrthographic(left, right, bottom, top, near, far);\n\n    System.out.println(orthoProj.getLinearData());\n}\n","description":"\nThe output of this program is:\n"},"name":"initOrthographic","code":"public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":164,"insert":164,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":24,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"b641ff11-4d6c-89bd-e54d-83297670a707","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"takes a forward and up vector as input, calculates the cross product of these vectors, and returns a rotation matrix based on those vectors.","params":[{"name":"forward","type_name":"Vector3f","description":"3D direction of rotation.\n\n* `forward` is a `Vector3f` instance representing a vector in 3D space.\n* It has three components: x, y, and z, which represent the coordinate values of the forward direction.\n* The magnitude (or length) of `forward` is equal to 1, as it is the direction of the positive z-axis.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D axis perpendicular to the forward direction and is used to calculate the rotation matrix.\n\n* `up` is a vector representing the upward direction in a 3D space. It has three components, which are the x, y, and z coordinates of the upward direction.\n* The magnitude of `up` is always non-zero, as it represents a fixed direction in space.\n* `up` is a unit vector, meaning that its magnitude is equal to 1. This ensures that the rotation is properly defined and can be applied to any object in 3D space.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a rotation matrix representing the rotation around the forward and up vectors.\n\n* The output is a `Matrix4f` object, which represents a 4x4 homogeneous transformation matrix.\n* The elements of the matrix are determined by the inputs `forward`, `up`, and their dot product. Specifically, the elements in the first three rows (i.e., the rotation part) are proportional to `f`, while the elements in the third row (i.e., the translation part) are proportional to `u`.\n* The rotation part of the matrix represents a counterclockwise rotation around the origin, as defined by the direction of `f`.\n* The translation part of the matrix represents the distance from the origin along the direction of `u`.","complex_type":true},"usage":{"language":"java","code":"// Set the forward vector as (1, 0, 0), up as (0, 1, 0) and right as (0, 0, 1).\nVector3f forward = new Vector3f(1, 0, 0);\nVector3f up = new Vector3f(0, 1, 0);\nVector3f right = new Vector3f(0, 0, 1);\n\n// Create a matrix with the desired rotation.\nMatrix4f rotM = new Matrix4f();\nrotM.initRotation(forward, up, right);\n","description":"\nThe output of this code is a matrix with the desired rotation that can be used in further calculations. Note that this example only uses one method from the provided class and it does not explain anything about how the method works. This is because the purpose of this exercise is to make sure that you understand how to use the provided methods and how they work, rather than to explain why we need a specific way to compute the rotation matrix."},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}","location":{"start":189,"insert":189,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":10,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"8b004011-2dc3-77aa-7f4f-9044cb2dbea3","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"sets the rotation matrix based on the provided forward, up, and right vectors, using the dot product of these vectors to compute the rotation axis and the sine of the angle between them as the rotation angle.","params":[{"name":"forward","type_name":"Vector3f","description":"3D direction of the rotation axis, which is used to initialize the rotation matrix.\n\n* `Vector3f forward`: This represents a 3D vector that points in the direction of the desired rotation axis. The components of this vector represent the x, y, and z values of the rotation axis.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D direction perpendicular to the rotation axis, which is used to define the orientation of the rotation matrix.\n\n* `up`: A `Vector3f` object representing the up direction vector in 3D space. It has three components: `x`, `y`, and `z`, which represent the magnitude and direction of the upward vector.","complex_type":true},{"name":"right","type_name":"Vector3f","description":"3D right vector of the rotation axis, which is used to initialize the rotation matrix with the correct orientation.\n\n* `right`: A vector representing the rightward direction in 3D space. It has three elements: `x`, `y`, and `z`, which represent the magnitude and direction of the rightward vector.\n* `up`: A vector representing the upward direction in 3D space. It has three elements: `x`, `y`, and `z`, which represent the magnitude and direction of the upward vector.\n* `forward`: A vector representing the forward direction in 3D space. It has three elements: `x`, `y`, and `z`, which represent the magnitude and direction of the forward vector.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a matrix representing the rotation of a 3D object around a given axis.\n\n1. The `data` array is a 4x4 matrix, where each element represents a vector in 3D space.\n2. The elements of the `data` array represent the rotation of the object around different axes (x, y, and z).\n3. Each element of the `data` array has a magnitude of 1, representing a unitary rotation.\n4. The last column of the `data` array represents the identity matrix, indicating that the rotation is around the origin.\n5. The function returns a reference to the same `Matrix4f` object, allowing for chaining of method calls.","complex_type":true},"usage":{"language":"java","code":"Vector3f f = new Vector3f(1, 0, 0); // The forward direction\nVector3f u = new Vector3f(0, 1, 0); // The upward direction\nVector3f r = new Vector3f(0, 0, 1); // The rightward direction\n\nMatrix4f rotMat = new Matrix4f();\nrotMat.initRotation(f, u, r);\n","description":"\nIn this example, the forward direction is initialized as a vector of (x: 1, y: 0, z: 0), upward direction is initialized as a vector of (x: 0, y: 1, z: 0) and rightward direction is initialized as a vector of (x: 0, y: 0, z: 1). The initRotation method is then used to populate the matrix with these vectors, which represents a rotation of 0 degrees around the Z-axis.\n\nThe resulting matrix would be:\n"},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":200,"insert":200,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":24,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"476a058d-f8ca-65b4-1c42-5f0598ce9cd7","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"takes a `Vector3f` argument `r` and returns a new `Vector3f` object with the result of multiplying each component of the input vector by a set of constants and adding the resulting values.","params":[{"name":"r","type_name":"Vector3f","description":"4D vector that transforms the original 4D vector returned by the function.\n\n* `r.getX()` returns the x-component of the input vector.\n* `r.getY()` returns the y-component of the input vector.\n* `r.getZ()` returns the z-component of the input vector.\n* `data[0][0]`, `data[1][0]`, and `data[2][0]` represent the x-components of three different vectors in the function.\n* `data[0][1]`, `data[1][1]`, and `data[2][1]` represent the y-components of these vectors.\n* `data[0][2]`, `data[1][2]`, and `data[2][2]` represent the z-components of these vectors.\n* `data[0][3]`, `data[1][3]`, and `data[2][3]` represent the w-components of these vectors.","complex_type":true}],"returns":{"type_name":"Vector3f","description":"a new `Vector3f` instance representing the result of multiplying each component of the input `r` vector by the corresponding components of the input data array.\n\n* The output is of type Vector3f, which represents a 3D vector in homogeneous coordinates.\n* The output's components are calculated by multiplying the input vector's elements with the corresponding elements of a set of data arrays, followed by addition and scaling of the resulting values.\n* The data arrays have four elements each, representing the scaled position, rotation, and translation components of a 3D transformation.\n\nOverall, the `transform` function returns a transformed vector that represents the result of applying a 3D transformation to the input vector.","complex_type":true},"usage":{"language":"java","code":"Vector3f v = new Vector3f(1, 2, 3);\nMatrix4f m = new Matrix4f();\nv = m.transform(v); // returns (4, 6, 9)\n","description":"\nIn this example, the vector v is transformed by the matrix m using the transform method. The resulting vector is then returned."},"name":"transform","code":"public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}","location":{"start":225,"insert":225,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":4,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"8b28e6af-248b-ceb0-814b-6f4f867f491f","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"multiplies a matrix by another matrix, performing element-wise multiplication and storing the result in a new matrix.","params":[{"name":"r","type_name":"Matrix4f","description":"4x4 homogeneous transformation matrix that, when multiplied with the current 4x4 matrix, results in the output matrix.\n\nMatrix4f `r`: A 4x4 homogeneous transformation matrix with four elements (0, 1, 2, and 3) representing the matrix's components.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a new matrix with the product of the input matrices.\n\nThe `res` variable is a `Matrix4f` object that represents the result of multiplying the input matrices `data` and `r`.\n\nThe method takes two matrices as input, and performs element-wise multiplication. That is, for each element in the first matrix (`data`), it multiplies the corresponding elements in the second matrix (`r`) and stores the result in the corresponding element of the output matrix `res`.\n\nThe output matrix `res` has the same dimensions as the input matrices, with each element containing the product of the corresponding elements in the input matrices.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m1 = new Matrix4f();\nm1.initIdentity().mul(new Matrix4f().initTranslation(5, 0, 0)).mul(new Matrix4f().initRotation(Vector3f(0, 0, 1), Vector3f(0, 1, 0)));\n","description":"\nIn this example we create an identity matrix and use it as the base matrix. We then add a translation matrix using the initTranslation method which will move our object by 5 units in the x direction (since the y value is zero). Finally we add a rotation matrix to our original matrix using the initRotation method. This will rotate our object around the z axis by 90 degrees. When we multiply m1 by itself we will get a new matrix that represents the composition of both translation and rotation.\n"},"name":"mul","code":"public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}","location":{"start":230,"insert":230,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":11,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"007b503c-8d41-dbb8-0649-ce172a3ac01f","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"creates a 4x4 array of float values by replicating the input `data` array four times and returning it as a result.","params":[],"returns":{"type_name":"float","description":"an array of arrays of float values.","complex_type":false},"usage":{"language":"java","code":"float[][] matrix = new Matrix4f().initRotation(new Vector3f(0, 1, 0), new Vector3f(1, 0, 0)).getData();\n","description":"\nIn this example, the initRotation method is called to initialize a rotation matrix. The getData method is then used to return an array of floats representing the data in the matrix. This can be useful for debugging or working with the internal data representation of the matrix object."},"name":"getData","code":"public float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}","location":{"start":242,"insert":242,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":9,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"15141c67-11dc-21ba-8e4b-b5a90cde0354","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"returns an array of float values representing a linear dataset with 6 rows and 3 columns. Each row represents a different data point, while each column corresponds to a specific feature or variable.","params":[],"returns":{"type_name":"float","description":"an array of 12 floats representing the data points in a linear format.","complex_type":false},"usage":{"language":"java","code":"public class MyClass {\n    public static void main(String[] args) {\n        Matrix4f m = new Matrix4f();\n        float[] linearData = m.getLinearData();\n        \n        // Perform calculations with the linear data\n    }\n}\n","description":"\nThis code would create a new Matrix4f and then obtain its linear data using the getLinearData method. The resulting float array would contain all of the elements of the matrix in a single, linear array. This can be useful for performing operations on the data without having to use a 2D array."},"name":"getLinearData","code":"public float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}","location":{"start":252,"insert":252,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"adb62915-9e55-01a1-8d44-07c2bde07615","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"retrieves a value from a 2D array `data`. The value is located at position (x, y) and is returned as a float.","params":[{"name":"x","type_name":"int","description":"0-based index of a cell in the 2D array `data`.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of the data array that is being accessed by the function, and it is used to retrieve the value of the corresponding element in the data array.","complex_type":false}],"returns":{"type_name":"float","description":"a floating-point value representing the data at the specified coordinates within an array.","complex_type":false},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nfloat value = m.get(0, 1);\n","description":"\nIn this example, the parameter (x, y) would be set to (0, 1), and the return value of the function would be assigned to a variable named value. This means that value would equal the value in row 0, column 1 of the matrix m."},"name":"get","code":"public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}","location":{"start":273,"insert":273,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"415fcdc9-4c8b-ff88-db48-ae971c81d25a","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"sets the value of a member field `data`.","params":[{"name":"data","type_name":"float[][]","description":"2D array of float values that will be stored in the `data` field of the function's receiver object.\n\n* `data` is a `float[][]` data structure.\n* It represents an array of arrays, where each inner array contains `float` values.\n* The length of the outer array (i.e., the size of the array of arrays) is determined by the input parameter.","complex_type":true}],"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Matrix4f mat = new Matrix4f();\n        float[][] data = {{1, 2, 3}, {4, 5, 6}};\n        mat.SetM(data);\n    }\n}\n","description":"\nThis code creates a matrix and sets the values in it using the SetM method.\n\nIt is important to note that this example does not explain how or why the method works. The goal of the exercise is to provide an example input for only ('data', 'float[][]')."},"name":"SetM","code":"public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}","location":{"start":277,"insert":277,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"ade9429c-f5f2-ae9b-744d-16ad1dbbf9af","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"sets a value for a specific position in a two-dimensional array of integers and floats.","params":[{"name":"x","type_name":"int","description":"0-based index of the row in which the data element is being updated.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of the data array being manipulated and sets its corresponding element to the provided `float` value.","complex_type":false},{"name":"value","type_name":"float","description":"3D pixel value that is assigned to the corresponding position in the data array.","complex_type":false}],"usage":{"language":"java","code":"public void main(String[] args) {\n    Matrix4f m = new Matrix4f();\n    m.set(0, 1, 5); // Set the element in row 0 and column 1 to 5\n    System.out.println(m.get(0, 1)); // Output: 5\n}\n","description":"\nThe input of this method is 'x' which is an integer between 0 and 3 inclusive that represents the row number of the element being set, and 'y' which is an integer between 0 and 3 inclusive that represents the column number of the element being set. The value argument is a float to be assigned to the specified element.\nThis method takes the input provided in x and y, modifies the data member to reflect the new value at the specified row and column, and then returns nothing."},"name":"set","code":"public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}","location":{"start":281,"insert":281,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."},{"id":"d5834ffd-4127-8f9b-de49-b8af4309c9ef","ancestors":["3da3c465-2e9d-4e91-b447-ed21cf0d4f83"],"type":"function","description":"transforms an array of arrays into a new array, transposing the elements within each sub-array. The original data is assigned to the new array.","params":[],"usage":{"language":"java","code":"public class Example{\n    public static void main(String[] args){\n        Matrix4f matrix = new Matrix4f();\n\n        // Initialize the matrix with some data\n        matrix.set(0, 0, 1);\n        matrix.set(0, 1, 2);\n        matrix.set(0, 2, 3);\n        matrix.set(0, 3, 4);\n        matrix.set(1, 0, 5);\n        matrix.set(1, 1, 6);\n        matrix.set(1, 2, 7);\n        matrix.set(1, 3, 8);\n        matrix.set(2, 0, 9);\n        matrix.set(2, 1, 10);\n        matrix.set(2, 2, 11);\n        matrix.set(2, 3, 12);\n        matrix.set(3, 0, 13);\n        matrix.set(3, 1, 14);\n        matrix.set(3, 2, 15);\n        matrix.set(3, 3, 16);\n\n        // Display the original matrix\n        System.out.println(\"Original matrix: \");\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                System.out.print(matrix.get(i, j) + \" \");\n            }\n            System.out.println();\n        }\n\n        // Transpose the matrix\n        matrix.transposeSelf();\n\n        // Display the transposed matrix\n        System.out.println(\"Transposed matrix: \");\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                System.out.print(matrix.get(i, j) + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n","description":""},"name":"transposeSelf","code":"public void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}","location":{"start":285,"insert":285,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":7,"docLength":null,"doc":"A Matrix4f class that represents a 4x4 matrix in the glsl shading language format. It provides various methods for initializing and manipulating matrices, as well as getting the matrix data as an array of floats. The class also includes methods for transforming vectors using the matrix and multiplying the matrix by another matrix."}]}}}