{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"A class called `SetM` that can transform a 3D point `r` using a matrix `data`. The `data` matrix is defined as a 4x4 array of floats, and it can be modified using various methods such as `set`, `transform`, and `mul`. These methods allow for manipulating the matrix elements and performing transformations on 3D points. Additionally, the class provides a `getLinearData()` method that returns an array of float values representing the linear transformation of the matrix.","diagram":"digraph G {\n    label=\"com.todo.FixMe\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Vector3f\n        Quaternion\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Matrix4f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n    }\n    subgraph cluster_1 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Chunk\n    }\n    edge [color=\"#26de81\"]\n    Matrix4f -> Matrix4f [style=\"dashed\"]\n    Quaternion -> Matrix4f \n    Matrix4f -> Matrix4f \n    Camera3D -> Matrix4f \n    Chunk -> Matrix4f \n    Transform -> Matrix4f \n    CameraStruct -> Matrix4f [style=\"dashed\"]\n    Camera -> Matrix4f \n    Vector3f -> Matrix4f \n    Vector3f -> Matrix4f [style=\"dashed\"]\n    Matrix4f -> Shader \n}\n","items":[{"id":"b80c3a50-6cf8-9cbf-0e4a-e443caa3f40e","ancestors":[],"type":"function","description":"is a Java class that represents a 4x4 matrix, providing methods for initializing, rotating, and transforming matrices. It also provides methods for getting and setting the matrix elements, as well as transposing the matrix.","name":"Matrix4f","code":"public class Matrix4f {\n\t\n\tprivate float[][] data;\n\n\tpublic Matrix4f() {\n\t\tdata = new float[4][4];\n\t}\n\tpublic Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\t/**\n\t * initializes a matrix with translation data, where `x`, `y`, and `z` are set to\n\t * specified values, replacing previous values.\n\t * \n\t * @param x 3D translation amount in the x-axis direction.\n\t * \n\t * @param y 2D translation amount of the matrix in the x-axis direction, which is\n\t * added to the previous value of the y-axis component of the matrix.\n\t * \n\t * @param z 3rd dimension of the translation vector, which is added to the matrix's\n\t * elements in the (2,2) position.\n\t * \n\t * @returns a matrix that represents the translation of a point in 4D space.\n\t */\n\tpublic Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * Initializes a rotation matrix from three Euler angles (x, y, z). It calculates the\n\t * rotation matrix using the law of cosines and stores it in a `Matrix4f` object\n\t * called `data`. The function returns a reference to the same `Matrix4f` object.\n\t * \n\t * @param x 3D rotation around the x-axis and is used to calculate the z-component\n\t * of the resulting matrix.\n\t * \n\t * @param y 2D rotation axis around the z-axis, which is used to create a new rotation\n\t * matrix based on the dot product of the 3D rotation axis and the x-axis, resulting\n\t * in a 4x4 rotation matrix that represents the combined rotation.\n\t * \n\t * @param z 3D rotation axis around which the rotation is performed, and it is used\n\t * to calculate the rotational component of the matrix along that axis.\n\t * \n\t * @returns a `Matrix4f` object representing the rotated coordinate system.\n\t */\n\tpublic Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * sets the scale factors for a matrix, modifying its elements accordingly. It returns\n\t * the modified matrix.\n\t * \n\t * @param x 3D scale along the x-axis of the matrix.\n\t * \n\t * @param y 2nd component of the scale vector in the initialization of the matrix's\n\t * data.\n\t * \n\t * @param z 2nd coordinate of the scaling factor for the matrix, which is applied to\n\t * the 2D projection of the 3D vector in the resulting matrix.\n\t * \n\t * @returns a reference to the same `Matrix4f` instance.\n\t */\n\tpublic Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * initializes a matrix with values for a perspective projection, where the field of\n\t * view (fov), aspect ratio, near and far distances are provided as inputs. The\n\t * function returns the initialized matrix.\n\t * \n\t * @param fov field of view (FOV) of the perspective projection, which determines the\n\t * angle of the vertical line that appears to be parallel to the viewer in the resulting\n\t * image.\n\t * \n\t * @param aspectRatio 2D screen aspect ratio of the viewport, which is used to scale\n\t * the perspective projection matrix accordingly.\n\t * \n\t * @param zNear near plane distance of the perspective projection, which determines\n\t * how far the near objects will appear from the viewer's position.\n\t * \n\t * @param zFar 3D space far clip plane distance, which is used to compute the near\n\t * and far clipping planes distances and ultimately affects the perspective projection\n\t * of the output matrix.\n\t * \n\t * @returns a matrix representing a perspective projection, with the appropriate\n\t * values for the near and far planes.\n\t */\n\tpublic Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * initializes a matrix for orthographic projection, setting its elements to preserve\n\t * proportions and ensure consistency with the specified viewing parameters.\n\t * \n\t * @param left left edge of the orthogonal projection in the X-axis.\n\t * \n\t * @param right right side of the orthographic projection, which determines the scale\n\t * factor for the x-axis of the resulting matrix.\n\t * \n\t * @param bottom 2D coordinate of the bottom-left corner of the orthographic projection,\n\t * which is used to determine the dimensions and angles of the projection matrix.\n\t * \n\t * @param top 2D coordinate of the top edge of the orthographic projection, which\n\t * determines the scale factor for the y-axis in the resulting matrix.\n\t * \n\t * @param near near plane of the orthographic projection, and it is used to calculate\n\t * the ratio of the far plane to the near plane in the function.\n\t * \n\t * @param far 3D far distance of the orthographic projection, which determines how\n\t * the 3D points are projected onto the image plane.\n\t * \n\t * @returns a new instance of the `Matrix4f` class with orthographic projection parameters.\n\t */\n\tpublic Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * generates a rotation matrix based on two input vectors: `forward` and `up`. The\n\t * resulting matrix represents a rotation around the cross product of `forward` and\n\t * `up`.\n\t * \n\t * @param forward 3D direction of the object's motion.\n\t * \n\t * @param up 2D plane that defines the orientation of the rotation, and it is used\n\t * to create the cross product with the `forward` parameter to determine the rotation\n\t * axis.\n\t * \n\t * @returns a 4x4 matrix representing the rotation transformation.\n\t */\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}\n\n\t\n\t/**\n\t * sets the rotation matrix based on three input vectors: forward, up, and right. It\n\t * returns a rotated matrix.\n\t * \n\t * @param forward 3D direction in which the rotation will be applied.\n\t * \n\t * @param up 3D direction of the up vector in the rotation, which is used to generate\n\t * the third row of the matrix.\n\t * \n\t * @param right 3D right vector of the rotation, which is used to set the elements\n\t * of the matrix's data array accordingly.\n\t * \n\t * @returns a Matrix4f object representing the rotation transformation.\n\t */\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\t\n\t/**\n\t * takes a vector `r` as input and returns a transformed vector with the same components,\n\t * but scaled by the values stored in the `data` array.\n\t * \n\t * @param r 3D vector that transforms the output of the function.\n\t * \n\t * @returns a new Vector3f object with the result of multiplying each component of\n\t * the input vector `r` by the corresponding components of the input data matrix, and\n\t * summing them together.\n\t */\n\tpublic Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}\n\n\t\n\t/**\n\t * multiplies a given matrix by another matrix, resulting in a new matrix with the\n\t * element-wise multiplication of the corresponding elements.\n\t * \n\t * @param r 4x4 matrix that is multiplied with the current matrix to produce the\n\t * result matrix.\n\t * \n\t * @returns a matrix that represents the product of two 4x4 matrices.\n\t */\n\tpublic Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t\n\tpublic float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}\n\t\n\t\n\tpublic float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}\n\n\t\n\t/**\n\t * retrieves the value stored at a specific coordinate within an array of float values.\n\t * \n\t * @param x 1D coordinate of the point in the grid where the data is retrieved.\n\t * \n\t * @param y 2nd dimension of the data array being accessed by the function.\n\t * \n\t * @returns a float value representing the data at the specified coordinates.\n\t */\n\tpublic float get(int x, int y) {\n\t\treturn data[x][y];\n\t}\n\n\t\n\t/**\n\t * sets the `data` member of the current object to the given array of floats.\n\t * \n\t * @param data 2D array of floating-point values that will be assigned to the `data`\n\t * field of the `SetM` method.\n\t */\n\tpublic void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}\n\n\t\n\t/**\n\t * updates a two-dimensional array 'data' by setting the element at the specified\n\t * coordinate (x, y) to the given value.\n\t * \n\t * @param x 0-based index of the array element being written to with the `value` parameter.\n\t * \n\t * @param y 2D coordinate of the element in the array being manipulated, and it is\n\t * used to specify the position within the array where the value should be stored.\n\t * \n\t * @param value 3D point value that is to be assigned to the corresponding position\n\t * in the `data` array.\n\t */\n\tpublic void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}\n\n\t\n\tpublic void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}\n\t\n}","location":{"start":3,"insert":3,"offset":" ","indent":0,"comment":null},"item_type":"class","length":465,"docLength":null,"doc":"A class called `SetM` that can transform a 3D point `r` using a matrix `data`. The `data` matrix is defined as a 4x4 array of floats, and it can be modified using various methods such as `set`, `transform`, and `mul`. These methods allow for manipulating the matrix elements and performing transformations on 3D points. Additionally, the class provides a `getLinearData()` method that returns an array of float values representing the linear transformation of the matrix."},{"id":"595c803b-8b95-aab8-c64b-edcc46abbd82","ancestors":["b80c3a50-6cf8-9cbf-0e4a-e443caa3f40e"],"type":"function","description":"initializes a matrix with identity values, meaning all elements are either 0 or 1, and the matrices row and column major properties are preserved.","params":[],"returns":{"type_name":"Matrix4f","description":"a reference to the same Matrix4f object.\n\n* The `Matrix4f` object is returned as the output, which represents an identity matrix with all elements set to 0 or 1.\n* The `data` array contains the components of the matrix, where each element is a 3x3 sub-matrix representing the component of the larger matrix.\n* Each sub-matrix has dimensions 3x3 and consists of elements that are either 0 or 1.\n* The order of the output is (4,4), indicating that the returned matrix is a 4x4 identity matrix.","complex_type":true},"usage":{"language":"java","code":"Matrix4f matrix = new Matrix4f(); // Creates a new instance of the Matrix4f class. \nmatrix.initIdentity(); // Set the identity for the matrix. \n\n// Get the values from the matrix to verify it is correctly set. \nSystem.out.println(\"First row, first column: \" + matrix.data[0][0]);\nSystem.out.println(\"Second row, second column: \" + matrix.data[1][1]);\nSystem.out.println(\"Third row, third column: \" + matrix.data[2][2]);\nSystem.out.println(\"Fourth row, fourth column: \" + matrix.data[3][3]);\n","description":"\nThe output of the code would be: \nFirst row, first column: 1 \nSecond row, second column: 1 \nThird row, third column: 1 \nFourth row, fourth column: 1 \nThis is a very simple example, in real world cases it will be more complex."},"name":"initIdentity","code":"public Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":10,"insert":10,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null,"doc":"A class called `SetM` that can transform a 3D point `r` using a matrix `data`. The `data` matrix is defined as a 4x4 array of floats, and it can be modified using various methods such as `set`, `transform`, and `mul`. These methods allow for manipulating the matrix elements and performing transformations on 3D points. Additionally, the class provides a `getLinearData()` method that returns an array of float values representing the linear transformation of the matrix."},{"id":"7eda62ed-26b4-60b1-e84e-fd5fbdcc28d1","ancestors":["b80c3a50-6cf8-9cbf-0e4a-e443caa3f40e"],"type":"function","description":"generates a 4x4 float array `res` from an input array `data`. It does so by iterating over the rows and columns of `data` and copying the values to their corresponding positions in `res`.","params":[],"returns":{"type_name":"float","description":"an array of arrays containing the original data.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n    Matrix4f matrix = new Matrix4f();\n    float[][] data = matrix.getData();\n    \n    // do something with data\n}\n","description":"\nThis code creates a new instance of the Matrix4f class and then uses the getData method to retrieve its internal data array. The resulting array is then used in some way. Note that the main function does not need to be included in the example, as it only serves to show how to use the getData method."},"name":"getData","code":"public float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}","location":{"start":384,"insert":384,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":9,"docLength":null,"doc":"A class called `SetM` that can transform a 3D point `r` using a matrix `data`. The `data` matrix is defined as a 4x4 array of floats, and it can be modified using various methods such as `set`, `transform`, and `mul`. These methods allow for manipulating the matrix elements and performing transformations on 3D points. Additionally, the class provides a `getLinearData()` method that returns an array of float values representing the linear transformation of the matrix."},{"id":"81f7dd25-87d8-27bb-0448-ba187049504e","ancestors":["b80c3a50-6cf8-9cbf-0e4a-e443caa3f40e"],"type":"function","description":"returns an array of floats representing the linear data. The array contains the data points (x,y) for a linear dataset.","params":[],"returns":{"type_name":"float","description":"an array of 12 floats, representing the data points for a linear regression model.","complex_type":false},"usage":{"language":"java","code":"public class Main {\n    public static void main(String[] args) {\n        Matrix4f mat = new Matrix4f();\n        float[] linearData = mat.getLinearData();\n        System.out.println(\"linear data:\\n\");\n        for (float x : linearData) {\n            System.out.print(\"\" + x);\n            if ((x % 4) == 3) System.out.println(\"\");\n            else System.out.print(\", \");\n        }\n    }\n}\n","description":"\nIn this example, we first create a new Matrix4f object, which is an empty 4x4 matrix. Then, we call the getLinearData method on the newly created Matrix4f object to retrieve its linear data representation in row-major order. Afterwards, we print the resulting array of floats using a simple for loop.\nThe output should be a string containing all the elements of the matrix, with each element separated by a comma or a new line (depending on whether it is at a multiple of 4).  \nFor example:  \nlinear data:  \n-1.23, -2.78, -3.45, -4.67, -5.00, -6.21, -7.34, -8.95, -1.09, 2.12, 3.27, 4.39, 5.46  \nThe output is an array of floats, which correspond to the elements in a linear representation of the matrix (in row-major order)."},"name":"getLinearData","code":"public float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}","location":{"start":395,"insert":395,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null,"doc":"A class called `SetM` that can transform a 3D point `r` using a matrix `data`. The `data` matrix is defined as a 4x4 array of floats, and it can be modified using various methods such as `set`, `transform`, and `mul`. These methods allow for manipulating the matrix elements and performing transformations on 3D points. Additionally, the class provides a `getLinearData()` method that returns an array of float values representing the linear transformation of the matrix."},{"id":"d72c1e8c-e778-33b5-1e49-fa6a62352af5","ancestors":["b80c3a50-6cf8-9cbf-0e4a-e443caa3f40e"],"type":"function","description":"transposes an array of float arrays, replacing each element with the corresponding element from the original array.","params":[],"usage":{"language":"java","code":"Matrix4f mat = new Matrix4f();\nmat.SetM(new float[][] {\n    new float[] {1, 0, 0, 0},\n    new float[] {0, 1, 0, 0},\n    new float[] {0, 0, 1, 0},\n    new float[] {0, 0, 0, 1}\n});\nmat.transposeSelf();\n\n// mat is now:\n// [[1, 0, 0, 0],\n// [0, 1, 0, 0],\n// [0, 0, 1, 0],\n// [0, 0, 0, 1]]\n","description":"\nThe code above first creates a matrix4f object mat. It then uses the SetM method to assign a 2D array of float values to it, and then the transposeSelf method is used to transpose the matrix. The resulting output will be the same as the input matrix."},"name":"transposeSelf","code":"public void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}","location":{"start":459,"insert":459,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":7,"docLength":null,"doc":"A class called `SetM` that can transform a 3D point `r` using a matrix `data`. The `data` matrix is defined as a 4x4 array of floats, and it can be modified using various methods such as `set`, `transform`, and `mul`. These methods allow for manipulating the matrix elements and performing transformations on 3D points. Additionally, the class provides a `getLinearData()` method that returns an array of float values representing the linear transformation of the matrix."}]}}}