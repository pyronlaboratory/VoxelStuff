{"name":"Matrix4f.java","path":"src/com/ch/math/Matrix4f.java","content":{"structured":{"description":"A Matrix4f class that represents a 4x4 homogeneous transformation matrix in the form of a float array. The class has several static factory methods for creating matrices with different properties such as identity, translation, rotation, and scaling. Additionally, the class provides methods for transforming vectors and getting the linear data of the matrix.","diagram":"digraph G {\n    label=\"com.todo.FixMe\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    subgraph cluster_0 {\n        label=\"math\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Vector3f\n        Quaternion\n        subgraph cluster_main {\n            // style=filled;\n            color=\"#00000000\"; \n            Matrix4f [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n            label = \"\"\n        }\n    }\n    subgraph cluster_1 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n        Chunk\n    }\n    edge [color=\"#26de81\"]\n    Matrix4f -> Shader \n    Quaternion -> Matrix4f \n    Matrix4f -> Matrix4f [style=\"dashed\"]\n    Transform -> Matrix4f \n    Camera -> Matrix4f \n    Vector3f -> Matrix4f \n    Camera3D -> Matrix4f \n    Matrix4f -> Matrix4f \n    CameraStruct -> Matrix4f [style=\"dashed\"]\n    Chunk -> Matrix4f \n    Vector3f -> Matrix4f [style=\"dashed\"]\n}\n","items":[{"id":"157b8842-9a61-dc9f-d148-7094e5a9bb13","ancestors":[],"type":"function","description":"represents a 4x4 matrix and provides various methods for manipulating it, including setting and getting individual elements, transforming vectors, and multiplying with another matrix. It also provides an array of floats to represent the matrix data and methods to get or set specific elements of the matrix.","name":"Matrix4f","code":"public class Matrix4f {\n\t\n\tprivate float[][] data;\n\n\tpublic Matrix4f() {\n\t\tdata = new float[4][4];\n\t}\n\n\tpublic Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}\n\n\tpublic Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}\n\n\tpublic Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}\n\n\n\tpublic Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}\n\t\n\tpublic float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}\n\n\n\tpublic float get(int x, int y) {\n\t\treturn data[x][y];\n\t}\n\n\tpublic void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}\n\n\tpublic void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}\n\t\n}","location":{"start":3,"insert":3,"offset":" ","indent":0,"comment":null},"item_type":"class","length":293,"docLength":null},{"id":"d0da62e9-e71e-818b-384a-fccd4525ce73","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"sets all elements of a Matrix4f object to identity values, i.e., elements are equal to their own row and column sums.","params":[],"returns":{"type_name":"Matrix4f","description":"a matrix with all elements initialized to their identity values.\n\n* The `data` array is a 4D matrix with dimensions [width, height, depth, channels], where each element is a floating-point value representing a component of the matrix.\n* Each dimension of the matrix contains values that are either 1 or 0, indicating whether the corresponding component is set to its default value (0) or not (1).\n* The matrix has no translation, rotation, or scaling components, as these have been initialized to their default values.\n* The matrix is in the identity transformation group, meaning that it does not change the position or orientation of any point in space.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initIdentity();\n","description":"\nThis code creates a new instance of the Matrix4f class and calls its initIdentity method to set it to the identity matrix, which consists of all 0s except for the diagonal entries being 1. The resulting matrix can then be used in calculations involving rotations and translations of 3D objects.\n\nThis is how the code would be used:\n"},"name":"initIdentity","code":"public Matrix4f initIdentity() {\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":11,"insert":11,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null},{"id":"114c02a0-904e-9c9a-9e4d-3bac75ef1893","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"initializes a matrix with translation coordinates x, y, and z. It sets the corresponding elements of the matrix to the appropriate values and returns the modified matrix.","params":[{"name":"x","type_name":"float","description":"3D translation vector component along the x-axis.","complex_type":false},{"name":"y","type_name":"float","description":"2nd element of the translation vector, which is added to the upper-left corner of the matrix's data array.","complex_type":false},{"name":"z","type_name":"float","description":"3rd dimension of the translation vector, which is added to the current position of the matrix.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix object, which has been modified to represent the translation.\n\n* The `Matrix4f` object is returned as the output, which represents a 4x4 homogeneous transformation matrix.\n* The elements of the matrix are set to specific values based on the input parameters `x`, `y`, and `z`.\n* The matrix data structure consists of four rows and four columns, with each element representing a component of the transformation matrix.\n* The matrix is initialized with the identity matrix, with the exception of the last row and column, which are set to the input values `x`, `y`, and `z` respectively.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initTranslation(5, 10, -2);\nSystem.out.println(m.getData()); // This will print out the matrix with all its values.\n","description":"\nThis is how you would use initTranslation method for the following inputs:\n* x = -5, y = 0, z = 0\n* x = 0, y = 5, z = 0\n* x = 0, y = 0, z = 10\n* x = 5, y = 10, z = 2\n\nThe matrix m will be the following for all of those inputs:\n"},"name":"initTranslation","code":"public Matrix4f initTranslation(float x, float y, float z) {\n//        x = -x;\n\t\tdata[0][0] = 1;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = x;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = y;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = 1;\n\t\tdata[2][3] = z;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":32,"insert":32,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":21,"docLength":null},{"id":"fe4a3041-c2ba-6cac-8d44-112b5ba23866","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"creates a rotation matrix based on three Euler angles (x, y, z) and returns the resulting rotation matrix as a new Matrix4f object.","params":[{"name":"x","type_name":"float","description":"azimuth angle of rotation, which is used to calculate the rotation matrix for the x-axis.","complex_type":false},{"name":"y","type_name":"float","description":"2D rotation angle around the z-axis, which is used to calculate the rotation matrix rz.","complex_type":false},{"name":"z","type_name":"float","description":"3D rotation axis around the z-axis, which is used to create a rotation matrix by multiplying it with other rotation matrices.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a new `Matrix4f` object representing the rotation matrix based on the provided angles.\n\n* The `data` field is an instance of `Matrix4f`, which represents a 4x4 homogeneous transformation matrix.\n* The elements of the matrix represent the rotation and scaling components of the overall transformation.\n* The matrices `rx`, `ry`, and `rz` are created by rotating the origin around the x, y, and z axes, respectively.\n* The `mul()` method is used to multiply the matrices element-wise, resulting in a 4x4 matrix that represents the combined rotation and scaling.\n* The `getData()` method is used to retrieve the elements of the resulting matrix as a flattened array.\n\nIn summary, the `initRotation` function returns a transformed matrix that represents the result of rotating the origin around three axes by a specified amount, followed by a scaling transformation.","complex_type":true},"usage":{"language":"java","code":"Matrix4f rotation = new Matrix4f();\nrotation.initRotation(30, 60, 90); // Initialize the matrix for rotating by 30, 60 and 90 degrees around the x, y and z axis respectively.\n// Use rotation to rotate objects.\n","description":"\nThis code will initialize a matrix that can be used to rotate an object by 30 degrees around the X axis, followed by another rotation of 60 degrees around the Y axis, then finally 90 degrees around the Z axis. Note that this method does not actually rotate anything in place, but rather initializes a new transformation matrix that can be used with other methods to perform rotations on objects."},"name":"initRotation","code":"public Matrix4f initRotation(float x, float y, float z) {\n\t\tMatrix4f rx = new Matrix4f();\n\t\tMatrix4f ry = new Matrix4f();\n\t\tMatrix4f rz = new Matrix4f();\n\n\t\tx = (float) Math.toRadians(x);\n\t\ty = (float) Math.toRadians(y);\n\t\tz = (float) Math.toRadians(z);\n\n\t\trz.data[0][0] = (float) Math.cos(z);\n\t\trz.data[0][1] = -(float) Math.sin(z);\n\t\trz.data[0][2] = 0;\n\t\trz.data[0][3] = 0;\n\t\trz.data[1][0] = (float) Math.sin(z);\n\t\trz.data[1][1] = (float) Math.cos(z);\n\t\trz.data[1][2] = 0;\n\t\trz.data[1][3] = 0;\n\t\trz.data[2][0] = 0;\n\t\trz.data[2][1] = 0;\n\t\trz.data[2][2] = 1;\n\t\trz.data[2][3] = 0;\n\t\trz.data[3][0] = 0;\n\t\trz.data[3][1] = 0;\n\t\trz.data[3][2] = 0;\n\t\trz.data[3][3] = 1;\n\n\t\trx.data[0][0] = 1;\n\t\trx.data[0][1] = 0;\n\t\trx.data[0][2] = 0;\n\t\trx.data[0][3] = 0;\n\t\trx.data[1][0] = 0;\n\t\trx.data[1][1] = (float) Math.cos(x);\n\t\trx.data[1][2] = -(float) Math.sin(x);\n\t\trx.data[1][3] = 0;\n\t\trx.data[2][0] = 0;\n\t\trx.data[2][1] = (float) Math.sin(x);\n\t\trx.data[2][2] = (float) Math.cos(x);\n\t\trx.data[2][3] = 0;\n\t\trx.data[3][0] = 0;\n\t\trx.data[3][1] = 0;\n\t\trx.data[3][2] = 0;\n\t\trx.data[3][3] = 1;\n\n\t\try.data[0][0] = (float) Math.cos(y);\n\t\try.data[0][1] = 0;\n\t\try.data[0][2] = -(float) Math.sin(y);\n\t\try.data[0][3] = 0;\n\t\try.data[1][0] = 0;\n\t\try.data[1][1] = 1;\n\t\try.data[1][2] = 0;\n\t\try.data[1][3] = 0;\n\t\try.data[2][0] = (float) Math.sin(y);\n\t\try.data[2][1] = 0;\n\t\try.data[2][2] = (float) Math.cos(y);\n\t\try.data[2][3] = 0;\n\t\try.data[3][0] = 0;\n\t\try.data[3][1] = 0;\n\t\try.data[3][2] = 0;\n\t\try.data[3][3] = 1;\n\n\t\tdata = rz.mul(ry.mul(rx)).getData();\n\n\t\treturn this;\n\t}","location":{"start":54,"insert":54,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":64,"docLength":null},{"id":"3f2ef9e4-3058-0f85-bf4a-13e7770c79ef","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"sets the scale factors for a matrix, by setting the corresponding elements of the matrix to the input values x, y, and z.","params":[{"name":"x","type_name":"float","description":"2D scaling factor for the x-axis of the matrix.","complex_type":false},{"name":"y","type_name":"float","description":"2nd component of the scaling vector, which is applied to the matrix's 2nd row.","complex_type":false},{"name":"z","type_name":"float","description":"2nd dimension of the scale factor for the matrix, which is multiplied by the corresponding element in the matrix to transform the coordinate system.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the original matrix.\n\nThe returned object is a `Matrix4f` instance, indicating that it is a 4x4 matrix with floating-point elements.\n\nThe `data` array of the returned matrix contains the scale factors for each dimension, where the first element represents the x-axis, the second element represents the y-axis, and the third element represents the z-axis. Each element is a single float value representing the scaling factor for that axis.\n\nTherefore, the returned matrix will have the same values as the input matrix, but with the x, y, and z scales updated to the specified values.","complex_type":true},"usage":{"language":"java","code":"// x, y, and z are float values\nMatrix4f mat = new Matrix4f();\nmat.initScale(x, y, z);\n","description":"\nThis sets the scale of the matrix to the values specified in the input parameters x, y, and z."},"name":"initScale","code":"public Matrix4f initScale(float x, float y, float z) {\n\t\tdata[0][0] = x;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = y;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = z;\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":119,"insert":119,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null},{"id":"7ec0ffaa-24ef-6da3-0843-bd1b87e713c3","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"initializes a matrix for perspective projection, setting the proper values for the view volume, aspect ratio, near and far distances, and resulting matrices.","params":[{"name":"fov","type_name":"float","description":"field of view of the camera, which determines the aspect ratio of the projection matrix and affects the scaling of the view volume.","complex_type":false},{"name":"aspectRatio","type_name":"float","description":"2D aspect ratio of the viewport, which is used to scale the horizontal and vertical dimensions of the projection matrix.","complex_type":false},{"name":"zNear","type_name":"float","description":"near clipping plane of the perspective projection, which determines the distance from the viewer at which objects appear to be part of the scene.","complex_type":false},{"name":"zFar","type_name":"float","description":"2D perspective's far clipping plane distance, which determines the range of depth values that are visible and affects the rendering result.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a `Matrix4f` object that represents a perspective projection matrix.\n\n* `data`: This is an array of 16 float values that represent the components of a 4x4 matrix.\n* `tanHalfFOV`: This variable represents the tangent of half of the field of view in radians.\n* `aspectRatio`: This variable represents the aspect ratio of the viewport.\n* `zNear`: This variable represents the near plane distance in the perspective projection.\n* `zFar`: This variable represents the far plane distance in the perspective projection.\n\nThe properties of the returned matrix include:\n\n* The matrix has a 4x4 size, with 16 float values representing its components.\n* The matrix is initialized with values that represent the perspective projection transformation for a given field of view, aspect ratio, near plane distance, and far plane distance.\n* The matrix can be used to transform 3D points into the perspective projection space.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initPerspective(90, 16 / 9, 0.1f, 100);\n","description":"\nThis code creates a new object of the class Matrix4f and then calls the initPerspective method to create an orthogonal projection matrix with a vertical field of view of 90 degrees, an aspect ratio of 16 / 9, near plane distance of 0.1, and far plane distance of 100. The resulting matrix is stored in the data member of the object m."},"name":"initPerspective","code":"public Matrix4f initPerspective(float fov, float aspectRatio, float zNear, float zFar) {\n\t\tfloat tanHalfFOV = (float) Math.tan(Math.toRadians(fov) / 2);\n\t\tfloat zRange = zNear - zFar;\n\n\t\tdata[0][0] = 1.0f / (tanHalfFOV * aspectRatio);\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 1.0f / tanHalfFOV;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = (-zNear - zFar) / zRange;\n\t\tdata[2][3] = 2 * zFar * zNear / zRange;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 1;\n\t\tdata[3][3] = 0;\n\n\t\treturn this;\n\t}","location":{"start":140,"insert":140,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":23,"docLength":null},{"id":"975c1721-85b5-6eb7-5147-376f0dc8cb11","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"initializes a matrix representing an orthographic projection, where the near and far planes are separated by a distance `depth`, and the left, right, bottom, and top edges are separated by distances `width`, `height`, and `near`, respectively.","params":[{"name":"left","type_name":"float","description":"left edge of the orthographic projection in the x-axis.","complex_type":false},{"name":"right","type_name":"float","description":"right edge of the orthographic projection, which is used to compute the scaling factors for the matrix.","complex_type":false},{"name":"bottom","type_name":"float","description":"2D distance from the top of the image, and is used to calculate the z-coordinate of each pixel in the resulting orthographic projection.","complex_type":false},{"name":"top","type_name":"float","description":"2D coordinate of the top edge of the orthographic projection, which is used to compute the values for the matrix elements in the Y dimension.","complex_type":false},{"name":"near","type_name":"float","description":"near clipping plane of the orthographic projection, and it is used to calculate the values of the matrix elements related to the near plane.","complex_type":false},{"name":"far","type_name":"float","description":"3D far clip plane, which determines how much of the scene beyond the near clip plane is visible and can be rendered.","complex_type":false}],"returns":{"type_name":"Matrix4f","description":"a reference to the same Matrix4f object.\n\n* The matrix data is stored in a 4x4 array, with each element representing a linear transformation component.\n* The elements of the matrix are computed based on the input parameters, such as the aspect ratio of the image and the near and far clipping planes.\n* The matrix is a orthographic projection matrix, which means it maps all points in the 3D space to their corresponding 2D positions on the image plane.\n* The matrix has a determinant of 1, indicating that it is an invertible matrix.\n* The matrix has no shear or rotation components, only scaling and translation components.\n\nIn summary, the `initOrthographic` function returns an orthographic projection matrix that can be used to transform 3D points into their corresponding 2D image coordinates.","complex_type":true},"usage":{"language":"java","code":"public class Test {\n    public static void main(String[] args) {\n        Matrix4f mat = new Matrix4f();\n        float left, right, bottom, top, near, far;\n        // set some values for left, right, bottom, top, near and far.\n        mat.initOrthographic(left, right, bottom, top, near, far);\n    }\n}\n","description":""},"name":"initOrthographic","code":"public Matrix4f initOrthographic(float left, float right, float bottom, float top, float near, float far) {\n\t\tfloat width = right - left;\n\t\tfloat height = top - bottom;\n\t\tfloat depth = far - near;\n\n\t\tdata[0][0] = 2 / width;\n\t\tdata[0][1] = 0;\n\t\tdata[0][2] = 0;\n\t\tdata[0][3] = -(right + left) / width;\n\t\tdata[1][0] = 0;\n\t\tdata[1][1] = 2 / height;\n\t\tdata[1][2] = 0;\n\t\tdata[1][3] = -(top + bottom) / height;\n\t\tdata[2][0] = 0;\n\t\tdata[2][1] = 0;\n\t\tdata[2][2] = -2 / depth;\n\t\tdata[2][3] = -(far + near) / depth;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":164,"insert":164,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":24,"docLength":null},{"id":"6595d413-72be-618f-774f-6d1043e0b4f4","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"initializes a rotation matrix from three vectors: forward, up, and a cross product of two of these vectors. The resulting rotation matrix is returned.","params":[{"name":"forward","type_name":"Vector3f","description":"3D direction of rotation.\n\n* `forward` is a vector in 3D space with a length of 3 elements (x, y, z).\n* The x, y, and z components of `forward` represent the direction of the forward vector.\n* `forward` is normalized, meaning that its length is equal to 1.\n* `forward` has no explicit attributes beyond its magnitude and direction.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D direction perpendicular to the forward direction, which is used to compute the rotation matrix.\n\n* `up`: A vector representing the upward direction in the 3D space. It is a normalized vector with magnitude equal to 1.\n* `normalized`: The vector is scaled so that its magnitude is equal to 1, which means that it has been divided by its magnitude without changing its direction. This property ensures that the vector has the same direction as the original upward vector.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a matrix representation of a rotation transformation based on the provided forward and up vectors.\n\nThe returned output is a `Matrix4f` object that represents a rotation matrix. The matrix has three columns representing the x, y, and z rotations, respectively. These rotations are calculated using the input vectors `forward` and `up`, which represent the forward direction and the upward direction of the rotation, respectively.\n\nThe matrix is initialized with the values computed from the cross products of the input vectors. Specifically, the x-axis rotation is given by the vector `(f.x, f.y, 0, 0)`, where `f` is the normalized forward vector. The y-axis rotation is given by the vector `(0, f.y, 0, 0)`, and the z-axis rotation is given by the vector `(0, 0, f.z, 0)`. Finally, the rotation matrix includes the cross product of the two input vectors, which represents the roll angle of the rotation.\n\nIn summary, the `initRotation` function returns a rotation matrix that can be used to represent a 3D rotation in a 4D space. The matrix has three columns representing the x, y, and z rotations, respectively, and is initialized using the cross products of the input vectors `forward` and `up`.","complex_type":true},"usage":{"language":"java","code":"Vector3f forward = new Vector3f(1, 0, 0);\nVector3f up = new Vector3f(0, 1, 0);\nMatrix4f matrix = new Matrix4f();\nmatrix.initRotation(forward, up);\n","description":"\nIn this example, the input for forward and up are both vectors that point in the x and y directions respectively. The method initRotation is called on an instance of the Matrix4f class and the resulting rotation matrix will have the given rotation applied to it."},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up) {\n\t\tVector3f f = forward.normalized();\n\n\t\tVector3f r = up.normalized();\n\t\tr = r.cross(f);\n\n\t\tVector3f u = f.cross(r);\n\n\t\treturn initRotation(f, u, r);\n\t}","location":{"start":189,"insert":189,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":10,"docLength":null},{"id":"b12f4a75-4939-1dbb-c644-994d8c8459a8","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"initializes a rotation matrix based on three vectors: `forward`, `right`, and `up`. It sets the elements of the matrix to the corresponding components of the vectors.","params":[{"name":"forward","type_name":"Vector3f","description":"3D direction in which the rotation will be applied, and its value is used to set the x, y, and z components of the rotation matrix's data array.\n\n* `forward` is a `Vector3f` object that represents a 3D vector with its x, y, and z components.\n* It has three components: `x`, `y`, and `z`, which correspond to the coordinates of the forward direction in 3D space.","complex_type":true},{"name":"up","type_name":"Vector3f","description":"3D direction of the up vector, which is used to initialize the upper triangular matrix of the rotation matrix.\n\n* `up`: A `Vector3f` object representing the upward direction in 3D space. It has three attributes: `x`, `y`, and `z`, which represent the coordinates of the up vector in the local reference frame of the matrix.","complex_type":true},{"name":"right","type_name":"Vector3f","description":"3D rightward direction of the rotation, which is used to initialize the components of the rotation matrix.\n\n* `r.getX()` returns the x-component of the right vector.\n* `r.getY()` returns the y-component of the right vector.\n* `r.getZ()` returns the z-component of the right vector.\n\nTherefore, `data[0][0] = r.getX(); data[0][1] = r.getY(); data[0][2] = r.getZ();` sets the x, y, and z components of the rotation matrix to the corresponding values of the right vector.\n\nSimilarly, `data[1][0] = u.getX(); data[1][1] = u.getY(); data[1][2] = u.getZ();` sets the x, y, and z components of the rotation matrix to the corresponding values of the up vector.\n\nFinally, `data[2][0] = f.getX(); data[2][1] = f.getY(); data[2][2] = f.getZ();` sets the x, y, and z components of the rotation matrix to the corresponding values of the forward vector.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a `Matrix4f` object representing a rotation matrix.\n\n* `data`: This is an array of type `float[]`, where each element represents a component of the rotation matrix. The length of the array is 4, corresponding to the 4 dimensions of a 4D vector.\n* `this`: This refers to the `Matrix4f` object that was passed as a parameter to the function. It is returned unchanged as part of the output.","complex_type":true},"usage":{"language":"java","code":"Vector3f forward = new Vector3f(0, 1, 0);\nVector3f up = new Vector3f(0, 0, 1);\nVector3f right = new Vector3f(1, 0, 0);\nMatrix4f m = new Matrix4f();\nm.initRotation(forward, up, right);\n","description":"\nExplanation: The forward vector is (0, 1, 0), which means the z-axis points towards the sky and the y-axis points towards the ground. The up vector is (0, 0, 1), which means the z-axis also points towards the sky. The right vector is (1, 0, 0), which means the x-axis points to the east. These vectors are used to create a rotation matrix that aligns the object's axes with these directions.\nThe method initRotation first sets the columns of the matrix to the given vectors and then makes sure all elements in the matrix are correct according to the matrix's definition. It returns itself, which allows for chained calls like this: m.initRotation(forward, up, right).transposeSelf().\nThe transposeSelf() method simply changes the row order of the matrix so that it becomes a rotation matrix as well. The resulting matrix should look like this:\n"},"name":"initRotation","code":"public Matrix4f initRotation(Vector3f forward, Vector3f up, Vector3f right) {\n\t\tVector3f f = forward;\n\t\tVector3f r = right;\n\t\tVector3f u = up;\n\n\t\tdata[0][0] = r.getX();\n\t\tdata[0][1] = r.getY();\n\t\tdata[0][2] = r.getZ();\n\t\tdata[0][3] = 0;\n\t\tdata[1][0] = u.getX();\n\t\tdata[1][1] = u.getY();\n\t\tdata[1][2] = u.getZ();\n\t\tdata[1][3] = 0;\n\t\tdata[2][0] = f.getX();\n\t\tdata[2][1] = f.getY();\n\t\tdata[2][2] = f.getZ();\n\t\tdata[2][3] = 0;\n\t\tdata[3][0] = 0;\n\t\tdata[3][1] = 0;\n\t\tdata[3][2] = 0;\n\t\tdata[3][3] = 1;\n\n\t\treturn this;\n\t}","location":{"start":200,"insert":200,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":24,"docLength":null},{"id":"84c0ca49-53df-43a2-7f4b-0bec6a2420a4","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"takes a `Vector3f` object `r` as input and returns a new `Vector3f` object with the result of multiplying each component of `r` by the corresponding components of a 3x3 matrix `data`.","params":[{"name":"r","type_name":"Vector3f","description":"3D transformation to be applied to the output vector.\n\n* `r.getX()` and `r.getY()` represent the x- and y-coordinates of the input vector, respectively.\n* `r.getZ()` represents the z-coordinate of the input vector.\n* `data[0][0]`, `data[0][1]`, `data[0][2]`, and `data[0][3]` are values that make up the output vector.\n* `data[1][0]`, `data[1][1]`, `data[1][2]`, and `data[1][3]` are additional values that make up the output vector.\n* `data[2][0]`, `data[2][1]`, `data[2][2]`, and `data[2][3]` are even more values that contribute to the final output vector.","complex_type":true}],"returns":{"type_name":"Vector3f","description":"a new `Vector3f` instance with the result of multiplying each element of the input `r` vector by corresponding elements of a pre-defined data array, and then adding the results.\n\n* The return type is a Vector3f object, which represents a 3D vector with float values for x, y, and z components.\n* Each component of the returned vector is calculated by multiplying the corresponding element in the input vector (represented by `r`) by a specific value from the input data array (`data`), followed by adding the result to the corresponding component of the output vector.\n* The input data array has 4 elements, each representing a different component of the output vector.\n* The returned vector has 3 components, representing the x, y, and z coordinates of the transformed vector.","complex_type":true},"usage":{"language":"java","code":"Vector3f forward = new Vector3f(0, 0, -1);\nVector3f up = new Vector3f(0, 1, 0);\nMatrix4f rotation = new Matrix4f();\n\n// Initializes the rotation matrix with a forward and up vector.\nrotation.initRotation(forward, up);\n\n// Transforms the given vector r by rotating it by the given rotation matrix.\nVector3f result = rotation.transform(r);\n","description":"\nIn this example, we initialize a rotation matrix (rotation) with forward and up vectors. Then, we use the transform method to rotate a given vector (r) by the rotation matrix (rotation). The result of the transformation is stored in the variable result.\n\nIt's worth noting that this is just an example, you should always test your code and make sure it works as expected before using it."},"name":"transform","code":"public Vector3f transform(Vector3f r) {\n\t\treturn new Vector3f(data[0][0] * r.getX() + data[0][1] * r.getY() + data[0][2] * r.getZ() + data[0][3], data[1][0] * r.getX() + data[1][1] * r.getY() + data[1][2]\n\t\t\t\t* r.getZ() + data[1][3], data[2][0] * r.getX() + data[2][1] * r.getY() + data[2][2] * r.getZ() + data[2][3]);\n\t}","location":{"start":225,"insert":225,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":4,"docLength":null},{"id":"e56067b0-6209-ebb8-8e4e-f2136781a658","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"multiplies a matrix by another matrix, element-wise multiplying corresponding elements and storing the result in a new matrix.","params":[{"name":"r","type_name":"Matrix4f","description":"4x4 matrix to be multiplied with the current matrix, resulting in the new matrix being returned in the `res` output parameter.\n\n`Matrix4f r`: This is a floating-point matrix with 4 rows and 4 columns, representing a transformation matrix in 3D space. The matrix elements are represented by 4 doubles, which are multiplied element-wise with the corresponding elements of the input matrix `data`.","complex_type":true}],"returns":{"type_name":"Matrix4f","description":"a matrix that represents the product of two 4x4 matrices.\n\n* The returned value is a `Matrix4f` instance, representing the matrix product of the input matrices.\n* The elements of the resulting matrix are calculated by multiplying corresponding elements of the input matrices and summing them up.\n* The resulting matrix has the same dimensions as the input matrices.","complex_type":true},"usage":{"language":"java","code":"Matrix4f m1 = new Matrix4f();\nm1.initRotation(new Vector3f(0, 0, 1), new Vector3f(0, 1, 0));\n\nMatrix4f m2 = new Matrix4f();\nm2.initTranslation(new Vector3f(1, 1, 0));\n\nMatrix4f result = m1.mul(m2);\n","description":"\nThis example creates two matrices m1 and m2, one with rotation around the z-axis only and another with translation in the x+y plane only. Then it multiplies them together to produce a new matrix that first rotates and then translates the vector. \nIt is important to note that Matrix4f is not immutable class, this means that calling init method will change original object values, therefore it's better to use constructor which takes data as input or create a copy of object before modifying it."},"name":"mul","code":"public Matrix4f mul(Matrix4f r) {\n\t\tMatrix4f res = new Matrix4f();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tres.set(i, j, data[i][0] * r.get(0, j) + data[i][1] * r.get(1, j) + data[i][2] * r.get(2, j) + data[i][3] * r.get(3, j));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}","location":{"start":231,"insert":231,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":11,"docLength":null},{"id":"6f7960dd-1f51-6f82-b143-7acf98fbb6cf","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"returns an array of arrays, where each inner array represents a 4x4 matrix, containing the values of the `data` array at the specified indices.","params":[],"returns":{"type_name":"float","description":"an array of arrays of floating-point numbers.","complex_type":false},"usage":{"language":"java","code":"public static void main(String[] args) {\n\tMatrix4f m = new Matrix4f();\n\tfloat[][] data = m.getData();\n}\n","description":"\nIn this example, we are creating a new instance of the Matrix4f class and then using the getData method to retrieve the data contained within the object.  The returned value is then stored in a float[][]."},"name":"getData","code":"public float[][] getData() {\n\t\tfloat[][] res = new float[4][4];\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tres[i][j] = data[i][j];\n\n\t\treturn res;\n\t}","location":{"start":243,"insert":243,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":9,"docLength":null},{"id":"b4798d30-a096-c2a0-9f40-ae264124e011","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"returns an array of floats representing the linear data at each point in a two-dimensional space.","params":[],"returns":{"type_name":"float","description":"an array of 12 floats, representing the linear data for a 3x3 matrix.","complex_type":false},"usage":{"language":"java","code":"Matrix4f m = new Matrix4f();\nm.initIdentity().translate(new Vector3f(1, 2, 3)).rotate(new Vector3f(0, -1, 0), Math.toRadians(90));\nfloat[] linearData = m.getLinearData();\n","description":"\nIn this example, we initialize a Matrix4f object and set it to the identity matrix using initIdentity method. We then translate the matrix by one unit in x-axis direction and rotate it by 90 degrees around y-axis direction. After that, we get linear data of the matrix by calling getLinearData method.\nThe output of this code will be as follows:\n"},"name":"getLinearData","code":"public float[] getLinearData() {\n\t\treturn new float[] {\n\t\t\tdata[0][0],\n\t\t\tdata[1][0],\n\t\t\tdata[2][0],\n\t\t\tdata[3][0],\n\t\t\tdata[0][1],\n\t\t\tdata[1][1],\n\t\t\tdata[2][1],\n\t\t\tdata[3][1],\n\t\t\tdata[0][2],\n\t\t\tdata[1][2],\n\t\t\tdata[2][2],\n\t\t\tdata[3][2],\n\t\t\tdata[0][3],\n\t\t\tdata[1][3],\n\t\t\tdata[2][3],\n\t\t\tdata[3][3],\n\t\t};\n\t}","location":{"start":253,"insert":253,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":20,"docLength":null},{"id":"cf15f3a5-58bc-7baa-1f49-19271b09e8bf","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"retrieves a value from a two-dimensional array `data`. The value is located at position `(x, y)` and is returned as a `float` variable.","params":[{"name":"x","type_name":"int","description":"0-based index of a cell in the 2D array `data`.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of the data array that is being accessed by the function.","complex_type":false}],"returns":{"type_name":"float","description":"a floating-point value representing the value at the specified position in a 2D array.","complex_type":false},"usage":{"language":"java","code":"int x = 2; // some int value\nint y = 3; // some other int value\nfloat z = get(x,y); // get the float at index (x,y)\n","description":"\nThe above example would call the get method on an array of floats, with the values of x and y passed as the first and second argument respectively. The return value of this method is then stored in the variable z. In this case, since we are passing valid integer values for x and y, the returned float value should correspond to the element at those indices in the array."},"name":"get","code":"public float get(int x, int y) {\n\t\treturn data[x][y];\n\t}","location":{"start":275,"insert":275,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"78878446-faeb-d1b6-3246-56e6c26f918b","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"sets the value of a field named `data`.","params":[{"name":"data","type_name":"float[][]","description":"2D array of float values that are to be stored as the value of the class instance field `data`.\n\n* It is an array of arrays, where each inner array represents a matrix in the problem domain.\n* The size of the outer array corresponds to the number of matrices in the problem domain.\n* Each inner array has a length equal to the number of rows in the matrix, and contains values representing the elements of the matrix.","complex_type":true}],"usage":{"language":"java","code":"public class MyClass {\n    private float[][] data;\n\n    public void setData(float[][] data) {\n        this.data = data;\n    }\n}\n\nMyClass myObject = new MyClass();\nmyObject.setData(new float[][]{\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9},\n});\n","description":"\nThe float array passed to the method SetM has three elements, each of which is an array with three elements. The first element of each inner array represents the values for rows 1 through 3, respectively, while the second and third elements represent columns 1 through 3, respectively."},"name":"SetM","code":"public void SetM(float[][] data) {\n\t\tthis.data = data;\n\t}","location":{"start":279,"insert":279,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"281520b4-8067-9989-504b-4aab452c7a49","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"sets a value to an element at a specific position in a two-dimensional array.","params":[{"name":"x","type_name":"int","description":"0-based index of the row in the two-dimensional data array that contains the element to be set.","complex_type":false},{"name":"y","type_name":"int","description":"2nd dimension of the data array being modified by the function.","complex_type":false},{"name":"value","type_name":"float","description":"3D coordinate's value that will be stored at the specified position in the data array.","complex_type":false}],"usage":{"language":"java","code":"// Example 1:\nMatrix4f m = new Matrix4f();\nm.initIdentity().set(0, 2, 3); // Sets the element at (0, 2) to 3.\n\n// Example 2:\nMatrix4f n = new Matrix4f();\nn.initTranslation(1, 2, 3).set(0, 2, 5); // Sets the element at (0, 2) to 5.\n","description":"\nIn example 1, we create an empty matrix and set its element at position (0, 2) to 3 using the method `initIdentity`. In example 2, we create a matrix that represents a translation by (1, 2, 3), and then set the element at position (0, 2) to 5. This shows how the method works when used in different contexts."},"name":"set","code":"public void set(int x, int y, float value) {\n\t\tdata[x][y] = value;\n\t}","location":{"start":283,"insert":283,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"d70d53b9-c5b1-9d83-a546-03ddec791099","ancestors":["157b8842-9a61-dc9f-d148-7094e5a9bb13"],"type":"function","description":"transposes a given matrix by swapping rows and columns, then assigns the resulting matrix to the function's own `data` field.","params":[],"usage":{"language":"java","code":"public static void main(String[] args) {\n    Matrix4f matrix = new Matrix4f();\n    System.out.println(\"Initial matrix:\\n\" + matrix);\n    matrix.transposeSelf();\n    System.out.println(\"\\nTransposed matrix:\\n\" + matrix);\n}\n","description":"\nRunning this program will output the initial matrix and then its transposed version:\n"},"name":"transposeSelf","code":"public void transposeSelf() {\n\t\tfloat[][] tr = new float[4][4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\ttr[i][j] = data[j][i];\n\t\tthis.data = tr;\n\t}","location":{"start":287,"insert":287,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":7,"docLength":null}]}}}