{"name":"Camera.java","path":"src/com/ch/Camera.java","content":{"structured":{"description":"A `Camera` class that manages view and projection matrices for rendering 3D scenes. The class has an abstract method `calculateProjectionMatrix()` that returns a matrix for projecting 3D points onto a 2D image, and another abstract method `adjustToViewport()` that resizes the matrix to fit within the image's dimensions. The `Camera` class also has instance methods for calculating view and projection matrices based on transformations such as rotation and translation. These matrices are used to render 3D objects from different viewpoints.","image":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.43.0 (0)\n -->\n<!-- Title: com.ch.Camera.CameraStruct Pages: 1 -->\n<svg width=\"198pt\" height=\"82pt\"\n viewBox=\"0.00 0.00 198.00 82.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 78)\">\n<title>com.ch.Camera.CameraStruct</title>\n<!-- Node1 -->\n<g id=\"Node000001\" class=\"node\">\n<title>Node1</title>\n<g id=\"a_Node000001\"><a xlink:title=\" \">\n<polygon fill=\"#999999\" stroke=\"#666666\" points=\"176.5,-74 13.5,-74 13.5,-55 176.5,-55 176.5,-74\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-62\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera.CameraStruct</text>\n</a>\n</g>\n</g>\n<!-- Node2 -->\n<g id=\"Node000002\" class=\"node\">\n<title>Node2</title>\n<g id=\"a_Node000002\"><a xlink:href=\"classcom_1_1ch_1_1Camera3D_1_1CameraStruct3D.html\" target=\"_top\" xlink:title=\" \">\n<polygon fill=\"white\" stroke=\"#666666\" points=\"190,-19 0,-19 0,0 190,0 190,-19\"/>\n<text text-anchor=\"middle\" x=\"95\" y=\"-7\" font-family=\"Helvetica,sans-Serif\" font-size=\"10.00\">com.ch.Camera3D.CameraStruct3D</text>\n</a>\n</g>\n</g>\n<!-- Node1&#45;&gt;Node2 -->\n<g id=\"edge1_Node000001_Node000002\" class=\"edge\">\n<title>Node1&#45;&gt;Node2</title>\n<g id=\"a_edge1_Node000001_Node000002\"><a xlink:title=\" \">\n<path fill=\"none\" stroke=\"#63b8ff\" d=\"M95,-44.66C95,-35.93 95,-25.99 95,-19.09\"/>\n<polygon fill=\"#63b8ff\" stroke=\"#63b8ff\" points=\"91.5,-44.75 95,-54.75 98.5,-44.75 91.5,-44.75\"/>\n</a>\n</g>\n</g>\n</g>\n</svg>\n","diagram":"digraph G {\n    label=\"com.ch.Camera\"\n    bgcolor=\"#151719\"\n    fontcolor=\"#ECEDED\"\n    splines=ortho\n    fontname=\"Courier New\"\n    edge [color=\"#26de81\"]\n    node [style=filled,color=\"#717D86\", shape=rectangle, fontname=\"Courier New\"];\n    \n    subgraph cluster_0 {\n        label=\"voxel\"\n        color=\"#33363A\"\n        World\n    }\n    subgraph cluster_1 {\n        label=\"math\"\n        color=\"#33363A\"\n        Matrix4f\n    }\n    Transform\n    subgraph cluster_main {\n        // style=filled;\n        color=\"#00000000\"; \n        Camera [style=filled,color=\"#26de81\",shape=rectangle, fontname=\"Courier New\"];\n        label = \"\"\n    }\n    CameraStruct\n    Camera -> World \n    CameraStruct -> Camera \n    Camera -> Matrix4f \n    Camera -> Transform \n}\n","items":[{"id":"6ebeee18-3617-3e99-e843-a7754a25ee4b","ancestors":[],"type":"function","description":"is an abstract class that provides methods for calculating view and projection matrices, as well as transforming positions and rotations. It also has an abstract method for calculating the projection matrix and another for adjusting to a specified viewport size.","name":"Camera","code":"public abstract class Camera {\n\n\tprotected Matrix4f projection;\n\tprotected Matrix4f viewProjectionMat4;\n\tprotected CameraStruct values;\n\tprotected Transform transform;\n\n\tprotected Camera(Matrix4f projection) {\n\t\tthis.projection = projection;\n\t\ttransform = new Transform();\n\t}\n\n\tpublic Matrix4f getViewProjection() {\n\n\t\tif (viewProjectionMat4 == null || transform.hasChanged()) {\n\t\t\tcalculateViewMatrix();\n\t\t}\n\n\t\treturn viewProjectionMat4;\n\t}\n\n\tpublic Matrix4f calculateViewMatrix() {\n\n\t\tMatrix4f cameraRotation = transform.getTransformedRot().conjugate().toRotationMatrix();\n\t\tMatrix4f cameraTranslation = getTranslationMatrix();\n\n\t\treturn (viewProjectionMat4 = projection.mul(cameraRotation.mul(cameraTranslation)));\n\n\t}\n\n\tpublic Matrix4f getTranslationMatrix() {\n\t\tVector3f cameraPos = transform.getTransformedPos().mul(-1);\n\t\treturn new Matrix4f().initTranslation(cameraPos.getX(), cameraPos.getY(), cameraPos.getZ());\n\t}\n\n\tpublic Transform getTransform() {\n\t\treturn transform;\n\t}\n\t\n\tpublic abstract Matrix4f calculateProjectionMatrix(CameraStruct data);\n\n\tpublic abstract void adjustToViewport(int width, int height);\n\n\tprotected abstract class CameraStruct {\n\n\t\tprotected abstract Matrix4f getAsMatrix4();\n\n\t}\n\n}","location":{"start":6,"insert":6,"offset":" ","indent":0,"comment":null},"item_type":"class","length":50,"docLength":null},{"id":"9ef7e48d-6602-c585-c74c-5933e9d07926","ancestors":["6ebeee18-3617-3e99-e843-a7754a25ee4b"],"type":"function","description":"computes and returns a `Matrix4f` object representing the view projection transformation, which combines the camera's view matrix and projection matrix to produce the final output image.","params":[],"returns":{"type_name":"Matrix4f","description":"a `Matrix4f` object representing the view projection matrix.\n\n* The `viewProjectionMat4` variable is a matrix object that represents the view projection transformation.\n* It is initialized to `null` if no transformation has been applied or if the `transform` field has changed since the last calculation.\n* The `calculateViewMatrix()` method is called to compute the view matrix when the `viewProjectionMat4` is null or has changed.\n\nThe `viewProjectionMat4` object contains information about the view and projection transformations, including the position, orientation, and scale of the camera relative to the world coordinates. This information can be used in various applications such as rendering 3D graphics, performing physics simulations, or creating machine learning models.","complex_type":true},"usage":{"language":"java","code":"Matrix4f viewProjection = camera.getViewProjection();\n","description":""},"name":"getViewProjection","code":"public Matrix4f getViewProjection() {\n\n\t\tif (viewProjectionMat4 == null || transform.hasChanged()) {\n\t\t\tcalculateViewMatrix();\n\t\t}\n\n\t\treturn viewProjectionMat4;\n\t}","location":{"start":18,"insert":18,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":8,"docLength":null},{"id":"3cbe53a7-f827-c597-e048-882bf75da56e","ancestors":["6ebeee18-3617-3e99-e843-a7754a25ee4b"],"type":"function","description":"calculates a view matrix for a 3D camera based on its rotation and translation. The function takes the camera's rotational transformation and translation as input and returns the resulting view matrix.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 matrix representing the view transformation of a 3D camera.\n\n* The output is a 4x4 matrix, representing the view matrix.\n* The first three columns represent the rotation of the camera relative to the world axis, while the fourth column represents the translation of the camera along the z-axis.\n* The matrix is constructed by multiplying the rotation matrix (`cameraRotation`) with the translation matrix (`cameraTranslation`).\n* The resulting matrix (`viewProjectionMat4`) combines the effects of both the view and projection transformations, providing a unified representation of the camera's position and orientation in 3D space.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n\t// Create a camera object with a projection matrix\n\tCamera camera = new Camera(new Matrix4f());\n\t\n\t// Calculate the view matrix\n\tcamera.calculateViewMatrix();\n}\n","description":""},"name":"calculateViewMatrix","code":"public Matrix4f calculateViewMatrix() {\n\n\t\tMatrix4f cameraRotation = transform.getTransformedRot().conjugate().toRotationMatrix();\n\t\tMatrix4f cameraTranslation = getTranslationMatrix();\n\n\t\treturn (viewProjectionMat4 = projection.mul(cameraRotation.mul(cameraTranslation)));\n\n\t}","location":{"start":27,"insert":27,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":8,"docLength":null},{"id":"a23469b8-d435-0bad-f241-45f8d08c1e02","ancestors":["6ebeee18-3617-3e99-e843-a7754a25ee4b"],"type":"function","description":"generates a translation matrix representing the camera's position relative to its initial position.","params":[],"returns":{"type_name":"Matrix4f","description":"a 4x4 homogeneous transformation matrix that represents the negative of the current position of the transform.\n\nThe matrix is a 4x4 transformation matrix that represents a translation in 3D space.\nThe elements of the matrix represent the x, y, and z coordinates of the translation vector in homogeneous form. Specifically, the first three columns represent the translation in the x, y, and z directions, respectively, while the last column represents the 1.0 value that indicates a non-scaled translation.\nThe matrix is returned as an instance of the `Matrix4f` class, which provides methods for multiplying the matrix by other matrices or vectors, as well as accessing its individual elements.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n\tCamera camera = new Camera(new Matrix4f());\n\tcamera.getTranslationMatrix(); // This will return a translation matrix for the camera\n}\n","description":"\nIn this example, we create an instance of the Camera class and call its getTranslationMatrix method to obtain a translation matrix for the camera. We then print the resulting matrix to the console.\n\nNote that in order to use this method, you must first initialize the camera with a valid projection matrix. You can do this by passing a Matrix4f object to the Camera constructor or by setting the projection field directly after creating an instance of the class."},"name":"getTranslationMatrix","code":"public Matrix4f getTranslationMatrix() {\n\t\tVector3f cameraPos = transform.getTransformedPos().mul(-1);\n\t\treturn new Matrix4f().initTranslation(cameraPos.getX(), cameraPos.getY(), cameraPos.getZ());\n\t}","location":{"start":36,"insert":36,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":4,"docLength":null},{"id":"bcf38e45-2b5b-8a8b-bb4c-8d7e746b64f6","ancestors":["6ebeee18-3617-3e99-e843-a7754a25ee4b"],"type":"function","description":"returns the `transform` object, which is a crucial part of the program's functionality.","params":[],"returns":{"type_name":"Transform","description":"a reference to an instance of the `Transform` class.\n\n* The `transform` variable returns an instance of the `Transform` class, which represents a transformation matrix.\n* The `transform` field has several attributes, including `a`, `b`, `c`, and `d`, each representing a component of the transformation matrix.\n* These components can take on any valid value within the range of -1 to 1, indicating the amount of stretching or shrinking to apply to the corresponding axis.","complex_type":true},"usage":{"language":"java","code":"public class CameraExample extends Camera {\n    public static void main(String[] args) {\n        // Create a new instance of the Camera class\n        Camera myCamera = new Camera(new Matrix4f());\n\n        // Get the transform property from the camera object\n        Transform myTransform = myCamera.getTransform();\n\n        // Print out the transformation matrix\n        System.out.println(myTransform.toString());\n    }\n}\n","description":""},"name":"getTransform","code":"public Transform getTransform() {\n\t\treturn transform;\n\t}","location":{"start":41,"insert":41,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"2426f886-0fc3-36b5-274f-caad136511fb","ancestors":["6ebeee18-3617-3e99-e843-a7754a25ee4b"],"type":"function","description":"is an abstract class that serves as a base for other classes in the Camera package. It provides an abstract method called `getAsMatrix4()` which returns a Matrix4f object, but does not provide any implementation details. The class also does not contain any fields or methods of its own, and is intended to be extended by other classes in the package.","name":"CameraStruct","code":"protected abstract class CameraStruct {\n\n\t\tprotected abstract Matrix4f getAsMatrix4();\n\n\t}","location":{"start":49,"insert":49,"offset":"\t","indent":1,"comment":null},"item_type":"class","length":5,"docLength":null}]}}}